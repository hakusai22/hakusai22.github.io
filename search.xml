<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ThreadPoolExecutor</title>
      <link href="/2021/09/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2021/09/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="一-Java中有哪些方法获取多线程"><a href="#一-Java中有哪些方法获取多线程" class="headerlink" title="一. Java中有哪些方法获取多线程"></a>一. Java中有哪些方法获取多线程</h1><pre><code>  1.  实现Runnable接口  2.  实现Callable接口  3.  实例化Thread类  4.  使用线程池获取</code></pre><h2 id="①-实现Runnable接口"><a href="#①-实现Runnable接口" class="headerlink" title="①. 实现Runnable接口"></a>①. 实现Runnable接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现Runnable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="①-实现Callable接口"><a href="#①-实现Callable接口" class="headerlink" title="①. 实现Callable接口"></a>①. 实现Callable接口</h2><ul><li>实现Callable接口，也需要实现call方法，但是这个时候我们还需要有返回值，这个Callable接口的应用场景一般就在于批处理业务，比如转账的时候，需要给一会返回结果的状态码回来，代表本次操作成功还是失败</li></ul><p><img src="https://img-blog.csdnimg.cn/20210710211729424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Callable有返回值</span></span><br><span class="line"><span class="comment"> * 批量处理的时候，需要带返回值的接口（例如支付失败的时候，需要返回错误状态）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;come in Callable&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>最后我们需要做的就是通过Thread线程， 将MyThread2实现Callable接口的类包装起来</p></li><li><p>这里需要用到的是FutureTask类，他实现了Runnable接口，并且还需要传递一个实现Callable接口的类作为构造函数</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xizi.callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in Callable&quot;</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line">FutureTask&lt;Integer&gt; futureTask2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask2, <span class="string">&quot;B&quot;</span>).start();<span class="comment">//多个线程执行 一个FutureTask的时候，只会计算一次</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断futureTask是否计算完成</span></span><br><span class="line">        <span class="keyword">while</span>(!futureTask.isDone()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出FutureTask的返回值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;result FutureTask &quot;</span> + futureTask.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;result FutureTask2 &quot;</span> + futureTask2.get());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210710211556751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> 总结</p></blockquote><ol><li>多个线程执行 一个FutureTask的时候，只会计算一次</li><li>如果我们要两个线程同时计算任务的话，那么需要定义两个futureTask</li></ol><h1 id="二-ThreadPoolExecutor"><a href="#二-ThreadPoolExecutor" class="headerlink" title="二. ThreadPoolExecutor"></a>二. ThreadPoolExecutor</h1><h2 id="①-为什么用线程池"><a href="#①-为什么用线程池" class="headerlink" title="①. 为什么用线程池"></a>①. 为什么用线程池</h2><ul><li><p>线程池做的主要工作就是控制运行的线程的数量，处理过程中，将任务放入到队列中，然后线程创建后，启动这些任务，如果线程数量超过了最大数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。</p></li><li><p>它的主要特点为：<strong>线程复用、控制最大并发数、管理线程</strong>。</p></li><li><p>线程池中的任务是放入到阻塞队列中的。</p></li></ul><h2 id="②-线程池的好处"><a href="#②-线程池的好处" class="headerlink" title="②. 线程池的好处"></a>②. 线程池的好处</h2><blockquote><p><font color='red' size=4>多核处理的好处是：省略的上下文的切换开销</p></blockquote><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程，降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无线创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h2 id="③-架构说明"><a href="#③-架构说明" class="headerlink" title="③. 架构说明"></a>③. 架构说明</h2><ul><li>Java中线程池是通过Executor框架实现的，该框架中用到了Executor，Executors（代表工具类），ExecutorService，ThreadPoolExecutor这几个类。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210710212203608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="④-创建线程池"><a href="#④-创建线程池" class="headerlink" title="④. 创建线程池"></a>④. 创建线程池</h2><h3 id="1-Executors-newFixedThreadPool-int-i-：创建一个拥有-i-个线程的线程池"><a href="#1-Executors-newFixedThreadPool-int-i-：创建一个拥有-i-个线程的线程池" class="headerlink" title="1. Executors.newFixedThreadPool(int i) ：创建一个拥有 i 个线程的线程池"></a>1. Executors.newFixedThreadPool(int i) ：创建一个拥有 i 个线程的线程池</h3><ul><li>执行长期的任务，性能好很多</li><li>创建一个定长线程池，可控制线程数最大并发数，超出的线程会在队列中等待</li></ul><h3 id="2-Executors-newSingleThreadExecutor：创建一个只有1个线程的-单线程池"><a href="#2-Executors-newSingleThreadExecutor：创建一个只有1个线程的-单线程池" class="headerlink" title="2. Executors.newSingleThreadExecutor：创建一个只有1个线程的 单线程池"></a>2. Executors.newSingleThreadExecutor：创建一个只有1个线程的 单线程池</h3><ul><li>一个任务一个任务执行的场景</li><li>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行</li></ul><h3 id="3-Executors-newCacheThreadPool-创建一个可扩容的线程池"><a href="#3-Executors-newCacheThreadPool-创建一个可扩容的线程池" class="headerlink" title="3. Executors.newCacheThreadPool(); 创建一个可扩容的线程池"></a>3. Executors.newCacheThreadPool(); 创建一个可扩容的线程池</h3><ul><li>执行很多短期异步的小程序或者负载教轻的服务器</li><li>创建一个可缓存线程池，如果线程长度超过处理需要，可灵活回收空闲线程，如无可回收，则新建新线程</li></ul><h3 id="4-Executors-newScheduledThreadPool-int-corePoolSize-：线程池支持定时以及周期性执行任务"><a href="#4-Executors-newScheduledThreadPool-int-corePoolSize-：线程池支持定时以及周期性执行任务" class="headerlink" title="4.  Executors.newScheduledThreadPool(int corePoolSize)：线程池支持定时以及周期性执行任务"></a>4.  Executors.newScheduledThreadPool(int corePoolSize)：线程池支持定时以及周期性执行任务</h3><ul><li>创建一个corePoolSize为传入参数，最大线程数为整形的最大数的线程池</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一池5个处理线程（用池化技术，一定要记得关闭）</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个只有一个线程的线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个拥有N个线程的线程池，根据调度创建合适的线程</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newCacheThreadPool();</span><br></pre></td></tr></table></figure><h3 id="5-模拟10个用户来办理业务，每个用户就是一个来自外部请求线程"><a href="#5-模拟10个用户来办理业务，每个用户就是一个来自外部请求线程" class="headerlink" title="5. 模拟10个用户来办理业务，每个用户就是一个来自外部请求线程"></a>5. 模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xizi.TreadPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xizizzz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-7-10下午 01:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPoolDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Array  Arrays(辅助工具类)</span></span><br><span class="line">        <span class="comment">// Collection Collections(辅助工具类)</span></span><br><span class="line">        <span class="comment">// Executor Executors(辅助工具类)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一池5个处理线程（用池化技术，一定要记得关闭）</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//一池一线程</span></span><br><span class="line"><span class="comment">//        ExecutorService threadPool = Executors.newFixedThreadPool(1);</span></span><br><span class="line">        <span class="comment">//一池N线程</span></span><br><span class="line"><span class="comment">//        ExecutorService threadPool = Executors.newCachedThreadPool();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 循环十次，模拟业务办理，让5个线程处理这10个请求</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">tempInt</span> <span class="operator">=</span> i;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 给用户:&quot;</span> + tempInt + <span class="string">&quot; 办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=4> 一池5个处理线程 ExecutorService threadPool &#x3D; Executors.newFixedThreadPool(5);</p></blockquote><p><img src="https://img-blog.csdnimg.cn/202107102129029.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4>创建一个只有一个线程的线程池，ExecutorService threadPool &#x3D; Executors.newSingleThreadExecutor();</p></blockquote><p><img src="https://img-blog.csdnimg.cn/2021071021302331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> 创建一个拥有N个线程的线程池，ExecutorService threadPool &#x3D; Executors.newCacheThreadPool();</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210710213207176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="⑤-底层实现"><a href="#⑤-底层实现" class="headerlink" title="⑤. 底层实现"></a>⑤. 底层实现</h2><ul><li><p>我们通过查看源码，点击了Executors.newSingleThreadExecutor 和 Executors.newFixedThreadPool能够发现底层都是使用了ThreadPoolExecutor</p></li><li><p>我们可以看到线程池的内部，还使用到了LinkedBlockingQueue 链表阻塞队列</p></li><li><p>同时在查看Executors.newCacheThreadPool 看到底层用的是 SynchronousBlockingQueue阻塞队列</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210710213612403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210710213651593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210710213542167.png" alt="在这里插入图片描述"></p><h2 id="⑥-线程池的重要参数"><a href="#⑥-线程池的重要参数" class="headerlink" title="⑥. 线程池的重要参数"></a>⑥. 线程池的重要参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                             <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                             TimeUnit unit,</span></span><br><span class="line"><span class="params">                             BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                             ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                             RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210710213901468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> 线程池在创建的时候，一共有7大参数</p></blockquote><h3 id="1-corePoolSize：核心线程数，线程池中的常驻核心线程数"><a href="#1-corePoolSize：核心线程数，线程池中的常驻核心线程数" class="headerlink" title="1. corePoolSize：核心线程数，线程池中的常驻核心线程数"></a>1. corePoolSize：核心线程数，线程池中的常驻核心线程数</h3><ul><li>在创建线程池后，当有请求任务来之后，就会安排池中的线程去执行请求任务，近似理解为今日当值线程</li><li>当线程池中的线程数目达到corePoolSize后，就会把到达线程放到缓存队列中</li></ul><h3 id="2-maximumPoolSize：线程池能够容纳同时执行的最大线程数，此值必须大于等于1"><a href="#2-maximumPoolSize：线程池能够容纳同时执行的最大线程数，此值必须大于等于1" class="headerlink" title="2. maximumPoolSize：线程池能够容纳同时执行的最大线程数，此值必须大于等于1"></a>2. maximumPoolSize：线程池能够容纳同时执行的最大线程数，此值必须大于等于1</h3><ul><li>相当有扩容后的线程数，这个线程池能容纳的最多线程数</li></ul><h3 id="3-keepAliveTime：多余的空闲线程存活时间"><a href="#3-keepAliveTime：多余的空闲线程存活时间" class="headerlink" title="3. keepAliveTime：多余的空闲线程存活时间"></a>3. keepAliveTime：多余的空闲线程存活时间</h3><ul><li>当线程池数量超过corePoolSize时，当空闲时间达到keepAliveTime值时，多余的空闲线程会被销毁，直到只剩下corePoolSize个线程为止<br>- 默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用</li></ul><h3 id="4-unit：keepAliveTime的单位"><a href="#4-unit：keepAliveTime的单位" class="headerlink" title="4.  unit：keepAliveTime的单位"></a>4.  unit：keepAliveTime的单位</h3><h3 id="5-workQueue：任务队列，被提交的但未被执行的任务"><a href="#5-workQueue：任务队列，被提交的但未被执行的任务" class="headerlink" title="5.  workQueue：任务队列，被提交的但未被执行的任务"></a>5.  workQueue：任务队列，被提交的但未被执行的任务</h3><ul><li>LinkedBlockingQueue：链表阻塞队列</li><li>SynchronousBlockingQueue：同步阻塞队列</li></ul><h3 id="6-threadFactory：表示生成线程池中工作线程的线程工厂"><a href="#6-threadFactory：表示生成线程池中工作线程的线程工厂" class="headerlink" title="6.  threadFactory：表示生成线程池中工作线程的线程工厂"></a>6.  threadFactory：表示生成线程池中工作线程的线程工厂</h3><ul><li>用于创建线程池 一般用默认即可</li></ul><h3 id="7-handler：拒绝策略"><a href="#7-handler：拒绝策略" class="headerlink" title="7.  handler：拒绝策略"></a>7.  handler：拒绝策略</h3><ul><li>表示当队列满了并且工作线程大于线程池的最大线程数（maximumPoolSize3）时，如何来拒绝请求执行的Runnable的策略</li></ul><h2 id="⑦-拒绝策略"><a href="#⑦-拒绝策略" class="headerlink" title="⑦. 拒绝策略"></a>⑦. 拒绝策略</h2><blockquote><p><font color='red' size=4>以下所有拒绝策略都实现了RejectedExecutionHandler接口</p></blockquote><ul><li>AbortPolicy：默认，直接抛出RejectedExcutionException异常，阻止系统正常运行</li><li>DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常，如果运行任务丢失，这是一种好方案</li><li>CallerRunsPolicy：该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者</li><li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务</li></ul><blockquote><p><font color='red' size=4> 当营业窗口和阻塞队列中都满了时候，就需要设置拒绝策略</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210710214443938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="⑧-线程池底层工作原理"><a href="#⑧-线程池底层工作原理" class="headerlink" title="⑧. 线程池底层工作原理"></a>⑧. 线程池底层工作原理</h2><p><img src="https://img-blog.csdnimg.cn/20210710214521848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> 线程池工作过程</p></blockquote><ol><li><p>在创建了线程池后，等待提交过来的任务请求</p></li><li><p>当调用execute()方法添加一个请求任务时，线程池会做出如下判断</p></li><li><p>如果正在运行的线程池数量小于corePoolSize，那么马上创建线程运行这个任务</p></li><li><p>如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列</p></li><li><p>如果这时候队列满了，并且正在运行的线程数量还小于maximumPoolSize，那么还是创建非核心线程运行这个任务；</p></li><li><p>如果队列满了并且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行</p></li><li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行</p></li><li><p>当一个线程无事可做操作一定的时间(keepAliveTime)时，线程池会判断：</p></li><li><p>如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉</p></li><li><p>所以线程池的所有任务完成后，它会最终收缩到corePoolSize的大小</p></li></ol><blockquote><p><font color='red' size=4>  以顾客去银行办理业务为例，谈谈线程池的底层工作原理</p></blockquote><ol><li>最开始假设来了两个顾客，因为corePoolSize为2，因此这两个顾客直接能够去窗口办理</li><li>后面又来了三个顾客，因为corePool已经被顾客占用了，因此只有去候客区，也就是阻塞队列中等待</li><li>后面的人又陆陆续续来了，候客区可能不够用了，因此需要申请增加处理请求的窗口，这里的窗口指的是线程池中的线程数，以此来解决线程不够用的问题</li><li>假设受理窗口已经达到最大数，并且请求数还是不断递增，此时候客区和线程池都已经满了，为了防止大量请求冲垮线程池，已经需要开启拒绝策略</li><li>临时增加的线程会因为超过了最大存活时间，就会销毁，最后从最大数削减到核心数</li></ol><h2 id="⑨-为什么不用默认创建的线程池？"><a href="#⑨-为什么不用默认创建的线程池？" class="headerlink" title="⑨. 为什么不用默认创建的线程池？"></a>⑨. 为什么不用默认创建的线程池？</h2><blockquote><p><font color='red' size=4>  线程池创建的方法有：固定数的，单一的，可变的，那么在实际开发中，应该使用哪个？</p></blockquote><ul><li><p>我们一个都不用，在生产环境中是使用自己自定义的</p></li><li><p>为什么不用 Executors 中JDK提供的？</p></li></ul><blockquote><p><font color='red' size=4>  根据阿里巴巴手册：并发控制这章</p></blockquote><ul><li>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程</li><li>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题，如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题</li><li>线程池不允许使用Executors去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险<blockquote><p><font color='red' size=4>  Executors返回的线程池对象弊端如下：</p></blockquote></li><li>FixedThreadPool和SingleThreadPool：运行的请求队列长度为：Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM</li><li>CacheThreadPool和ScheduledThreadPool: 运行的请求队列长度为：Integer.MAX_VALUE，线程数上限太大导致OOM</li></ul><h2 id="⑩-手写线程池"><a href="#⑩-手写线程池" class="headerlink" title="⑩. 手写线程池"></a>⑩. 手写线程池</h2><h3 id="1-采用默认拒绝策略AbortPolicy"><a href="#1-采用默认拒绝策略AbortPolicy" class="headerlink" title="1. 采用默认拒绝策略AbortPolicy"></a>1. 采用默认拒绝策略AbortPolicy</h3><ol start="2"><li>从上面我们知道，因为默认的Executors创建的线程池，底层都是使用LinkBlockingQueue作为阻塞队列的，而LinkBlockingQueue虽然是有界的，但是它的界限是 Integer.MAX_VALUE 大概有20多亿，可以相当是无界的了，因此我们要使用ThreadPoolExecutor自己手动创建线程池，然后指定阻塞队列的大小</li></ol><blockquote><p><font color='red' size=4>下面我们创建了一个 核心线程数为2，最大线程数为5，并且阻塞队列数为3的线程池，然后使用for循环，模拟10个用户来进行请求</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xizi.TreadPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xizizzz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-7-10下午 01:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool_AbortPolicy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 手写线程池</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">corePoolSize</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">maximumPoolSize</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">keepAliveTime</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义线程池，只改变了LinkBlockingQueue的队列大小</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                corePoolSize,</span><br><span class="line">                maximumPoolSize,</span><br><span class="line">                keepAliveTime,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line">        <span class="comment">//设置的拒绝策略是默认的AbortPolicy，也就是抛异常的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 循环十次，模拟业务办理，让5个线程处理这10个请求</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">tempInt</span> <span class="operator">=</span> i;</span><br><span class="line">                executorService.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 给用户:&quot;</span> + tempInt + <span class="string">&quot; 办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=4>但是在用户执行到第九个的时候，触发了异常，程序中断</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210710215445371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>这是因为触发了拒绝策略，而我们设置的拒绝策略是默认的AbortPolicy，也就是抛异常的</p></li><li><p>触发条件是，请求的线程大于 阻塞队列大小 + 最大线程数 &#x3D; 8 的时候，也就是说第9个线程来获取线程池中的线程时，就会抛出异常从而报错退出。</p></li></ul><h3 id="2-采用CallerRunsPolicy拒绝策略"><a href="#2-采用CallerRunsPolicy拒绝策略" class="headerlink" title="2.  采用CallerRunsPolicy拒绝策略"></a>2.  采用CallerRunsPolicy拒绝策略</h3><ul><li>当我们更好其它的拒绝策略时，采用CallerRunsPolicy拒绝策略，也称为回退策略，就是把任务丢回原来的请求开启线程着，我们看运行结果</li></ul><p><img src="https://img-blog.csdnimg.cn/20210710215641501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>我们发现，输出的结果里面出现了main线程，因为线程池出发了拒绝策略，把任务回退到main线程，然后main线程对任务进行处理</li></ul><h3 id="3-采用-DiscardPolicy-拒绝策略"><a href="#3-采用-DiscardPolicy-拒绝策略" class="headerlink" title="3. 采用 DiscardPolicy 拒绝策略"></a>3. 采用 DiscardPolicy 拒绝策略</h3><ul><li>采用DiscardPolicy拒绝策略会，线程池会自动把后面的任务都直接丢弃，也不报异常，当任务无关紧要的时候，可以采用这个方式</li></ul><p><img src="https://img-blog.csdnimg.cn/20210710215715966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="4-采用DiscardOldestPolicy拒绝策略"><a href="#4-采用DiscardOldestPolicy拒绝策略" class="headerlink" title="4. 采用DiscardOldestPolicy拒绝策略"></a>4. 采用DiscardOldestPolicy拒绝策略</h3><p><img src="https://img-blog.csdnimg.cn/20210710215931677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="三-线程池的合理参数"><a href="#三-线程池的合理参数" class="headerlink" title="三. 线程池的合理参数"></a>三. 线程池的合理参数</h1><ul><li><p>生产环境中如何配置 <strong>corePoolSize 和 maximumPoolSize</strong></p></li><li><p>这个是根据具体业务来配置的，分为<strong>CPU密集型和IO密集型</strong></p></li></ul><h2 id="①-CPU密集型"><a href="#①-CPU密集型" class="headerlink" title="①. CPU密集型"></a>①. CPU密集型</h2><ul><li><p>CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行</p></li><li><p>CPU密集任务只有在真正的多核CPU上才可能得到加速（通过多线程）</p></li><li><p>而在单核CPU上，无论你开几个模拟的多线程该任务都不可能得到加速，因为CPU总的运算能力就那些。</p></li></ul><blockquote><p><font color='red' size=4>CPU密集型任务配置尽可能少的线程数量： 一般公式：CPU核数 + 1个线程数</p></blockquote><h2 id="②-IO密集型"><a href="#②-IO密集型" class="headerlink" title="②. IO密集型"></a>②. IO密集型</h2><ul><li><p>由于IO密集型任务线程并不是一直在执行任务，则可能多的线程，如 CPU核数 * 2</p></li><li><p>IO密集型，即该任务需要大量的IO操作，即大量的阻塞</p></li><li><p>在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力花费在等待上</p></li><li><p>所以IO密集型任务中使用多线程可以大大的加速程序的运行，即使在单核CPU上，这种加速主要就是利用了被浪费掉的阻塞时间。</p></li><li><p>IO密集时，大部分线程都被阻塞，故需要多配置线程数：</p></li></ul><blockquote><p><font color='red' size=4> 参考公式：CPU核数 &#x2F; (1 - 阻塞系数) 阻塞系数在0.8 ~ 0.9左右</p></blockquote><ul><li>例如：8核CPU：8&#x2F; (1 - 0.9) &#x3D; 80个线程数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-索引相关优化</title>
      <link href="/2021/09/06/MySQL-%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96/"/>
      <url>/2021/09/06/MySQL-%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="一-验证索引提升查询效率"><a href="#一-验证索引提升查询效率" class="headerlink" title="一. 验证索引提升查询效率"></a>一. 验证索引提升查询效率</h1><blockquote><p><font color='red' size=4> 根据ID 和name 进行精确查询查询 </p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210716214616446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="二-索引的使用-准备环境"><a href="#二-索引的使用-准备环境" class="headerlink" title="二. 索引的使用_准备环境"></a>二. 索引的使用_准备环境</h1><blockquote><p><font color='red' size=4> 创建联合索引</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210716214958795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_seller_name_sta_addr <span class="keyword">on</span> tb_seller(name,status,address);</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=4> 创建表和插入数据</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210716215147184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `tb_seller` (</span><br><span class="line">`sellerid` <span class="type">varchar</span> (<span class="number">100</span>),</span><br><span class="line">`name` <span class="type">varchar</span> (<span class="number">100</span>),</span><br><span class="line">`nickname` <span class="type">varchar</span> (<span class="number">50</span>),</span><br><span class="line">`password` <span class="type">varchar</span> (<span class="number">60</span>),</span><br><span class="line">`status` <span class="type">varchar</span> (<span class="number">1</span>),</span><br><span class="line">`address` <span class="type">varchar</span> (<span class="number">100</span>),</span><br><span class="line">`createtime` datetime,</span><br><span class="line">    <span class="keyword">primary</span> key(`sellerid`)</span><br><span class="line">)engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8mb4; </span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;alibaba&#x27;</span>,<span class="string">&#x27;阿里巴巴&#x27;</span>,<span class="string">&#x27;阿里小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;baidu&#x27;</span>,<span class="string">&#x27;百度科技有限公司&#x27;</span>,<span class="string">&#x27;百度小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;huawei&#x27;</span>,<span class="string">&#x27;华为科技有限公司&#x27;</span>,<span class="string">&#x27;华为小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;itcast&#x27;</span>,<span class="string">&#x27;传智播客教育科技有限公司&#x27;</span>,<span class="string">&#x27;传智播客&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;itheima&#x27;</span>,<span class="string">&#x27;黑马程序员&#x27;</span>,<span class="string">&#x27;黑马程序员&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;luoji&#x27;</span>,<span class="string">&#x27;罗技科技有限公司&#x27;</span>,<span class="string">&#x27;罗技小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;oppo&#x27;</span>,<span class="string">&#x27;OPPO科技有限公司&#x27;</span>,<span class="string">&#x27;OPPO官方旗舰店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;ourpalm&#x27;</span>,<span class="string">&#x27;掌趣科技股份有限公司&#x27;</span>,<span class="string">&#x27;掌趣小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;qiandu&#x27;</span>,<span class="string">&#x27;千度科技&#x27;</span>,<span class="string">&#x27;千度小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;sina&#x27;</span>,<span class="string">&#x27;新浪科技有限公司&#x27;</span>,<span class="string">&#x27;新浪官方旗舰店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;xiaomi&#x27;</span>,<span class="string">&#x27;小米科技&#x27;</span>,<span class="string">&#x27;小米官方旗舰店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;西安市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;yijia&#x27;</span>,<span class="string">&#x27;宜家家居&#x27;</span>,<span class="string">&#x27;宜家家居旗舰店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="三-避免索引失效"><a href="#三-避免索引失效" class="headerlink" title="三. 避免索引失效"></a>三. 避免索引失效</h1><h2 id="①-全值匹配-，对索引中所有列都指定具体值"><a href="#①-全值匹配-，对索引中所有列都指定具体值" class="headerlink" title="①. 全值匹配 ，对索引中所有列都指定具体值"></a>①. 全值匹配 ，对索引中所有列都指定具体值</h2><ul><li>该情况下，索引生效，执行效率高。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;北京市&#x27;</span>\G;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716215026690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="②-最左前缀法则-走索引"><a href="#②-最左前缀法则-走索引" class="headerlink" title="②. 最左前缀法则_走索引"></a>②. 最左前缀法则_走索引</h2><ul><li>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。</li></ul><blockquote><p><font color='red' size=4> 匹配最左前缀法则，走索引：</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716215323663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2021071621532888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span> <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;北京市&#x27;</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716215336240.png" alt="在这里插入图片描述"></p><h2 id="③-违反最左前缀法则-，-索引失效"><a href="#③-违反最左前缀法则-，-索引失效" class="headerlink" title="③.  违反最左前缀法则 ， 索引失效"></a>③.  违反最左前缀法则 ， 索引失效</h2><blockquote><p><font color='red' size=4> 违法最左前缀法则 ， 索引失效</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> status<span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;北京市&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716215330593.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210716215612168.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210716215615712.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> 如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span><span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;北京市&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716215339672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="④-范围查询右边的列，不能使用索引"><a href="#④-范围查询右边的列，不能使用索引" class="headerlink" title="④. 范围查询右边的列，不能使用索引"></a>④. 范围查询右边的列，不能使用索引</h2><blockquote><p><font color='red' size=4> 范围查询右边的列，不能使用索引 </p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span> <span class="keyword">and</span> status<span class="operator">&gt;</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;北京市&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716215619884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="⑤-不要在索引列上进行运算操作，-索引将失效"><a href="#⑤-不要在索引列上进行运算操作，-索引将失效" class="headerlink" title="⑤. 不要在索引列上进行运算操作， 索引将失效"></a>⑤. 不要在索引列上进行运算操作， 索引将失效</h2><blockquote><p><font color='red' size=4> 不要在索引列上进行运算操作， 索引将失效</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="built_in">substring</span>(name,<span class="number">3</span>,<span class="number">2</span>)<span class="operator">=</span><span class="string">&#x27;科技&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716220058143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="⑥-字符串不加单引号，造成索引失效"><a href="#⑥-字符串不加单引号，造成索引失效" class="headerlink" title="⑥. 字符串不加单引号，造成索引失效"></a>⑥. 字符串不加单引号，造成索引失效</h2><blockquote><p><font color='red' size=4>字符串不加单引号，造成索引失效</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/202107162201379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="⑦-尽量使用覆盖索引，避免select"><a href="#⑦-尽量使用覆盖索引，避免select" class="headerlink" title="⑦.  尽量使用覆盖索引，避免select  *"></a>⑦.  尽量使用覆盖索引，避免select  *</h2><ul><li>尽量使用覆盖索引（只访问索引的查询（索引列完全包含查询列）），减少select * 。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210716220323922.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> name,status,address <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716220329803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210716220343608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210716220353464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="⑧-如果查询列，超出索引列，也会降低性能。"><a href="#⑧-如果查询列，超出索引列，也会降低性能。" class="headerlink" title="⑧.  如果查询列，超出索引列，也会降低性能。"></a>⑧.  如果查询列，超出索引列，也会降低性能。</h2><blockquote><p><font color='red' size=4> 如果查询列，超出索引列，也会降低性能。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210716220515112.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210716220526315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> index ：使用覆盖索引的时候就会出现</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">where</span>：在查找使用索引的情况下，需要回表去查询所需的数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> index <span class="keyword">condition</span>：查找使用了索引，但是需要回表查询数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> index ; <span class="keyword">using</span> <span class="keyword">where</span>：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据</span><br></pre></td></tr></table></figure><h2 id="⑨-用or分割开的条件"><a href="#⑨-用or分割开的条件" class="headerlink" title="⑨.  用or分割开的条件"></a>⑨.  用or分割开的条件</h2><blockquote><p><font color='red' size=4>用or分割开的条件</p></blockquote><ul><li><p>如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</p></li><li><p>示例，name字段是索引列 ， 而nickname不是索引列，中间是or进行连接是不走索引的</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span> <span class="keyword">or</span> nickname<span class="operator">=</span><span class="string">&#x27;小米官方旗舰店&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716220600689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="⑩-以-开头的Like模糊查询，索引失效"><a href="#⑩-以-开头的Like模糊查询，索引失效" class="headerlink" title="⑩. 以%开头的Like模糊查询，索引失效"></a>⑩. 以%开头的Like模糊查询，索引失效</h2><blockquote><p><font color='red' size=4> 以%开头的Like模糊查询，索引失效</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> name,status <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%小米%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> name,status <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%小米&#x27;</span>;</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> name,status <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;小米%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716220710567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210716220714826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210716220728100.png" alt="在这里插入图片描述"></p><h2 id="十一-如果MySQL评估使用索引比全表更慢，则不使用索引"><a href="#十一-如果MySQL评估使用索引比全表更慢，则不使用索引" class="headerlink" title="十一. 如果MySQL评估使用索引比全表更慢，则不使用索引"></a>十一. 如果MySQL评估使用索引比全表更慢，则不使用索引</h2><blockquote><p><font color='red' size=4> 如果MySQL评估使用索引比全表更慢，则不使用索引</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> tb_seller;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">create</span> index idx_seller_address <span class="keyword">on</span> tb_seller(address);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716220834579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/202107162208110.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210716220916178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210716220923329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="十二-is-null，-is-not-null，-gt-有时索引失效。"><a href="#十二-is-null，-is-not-null，-gt-有时索引失效。" class="headerlink" title="十二.  is  null， is not null，&gt;有时索引失效。"></a>十二.  is  null， is not null，&gt;有时索引失效。</h2><blockquote><p><font color='red' size=4> is  NULL ， is NOT NULL  &gt;有时索引失效。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span>  <span class="keyword">from</span> tb_seller <span class="keyword">where</span> address <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span>  <span class="keyword">from</span> tb_seller <span class="keyword">where</span> address <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716220935222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="十三-in-走索引，-not-in-索引失效"><a href="#十三-in-走索引，-not-in-索引失效" class="headerlink" title="十三.  in 走索引， not in 索引失效"></a>十三.  in 走索引， not in 索引失效</h2><blockquote><p><font color='red' size=4>  in 走索引， not in 索引失效</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210716221053258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span>  <span class="keyword">from</span> tb_seller <span class="keyword">where</span> sellerid <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;oppo&#x27;</span>,<span class="string">&#x27;xiaomi&#x27;</span>,<span class="string">&#x27;sina&#x27;</span>);</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span>  <span class="keyword">from</span> tb_seller <span class="keyword">where</span> sellerid <span class="keyword">in</span> (<span class="string">&#x27;oppo&#x27;</span>,<span class="string">&#x27;xiaomi&#x27;</span>,<span class="string">&#x27;sina&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="十四-单列索引和复合索引"><a href="#十四-单列索引和复合索引" class="headerlink" title="十四. 单列索引和复合索引"></a>十四. 单列索引和复合索引</h2><ul><li>尽量使用复合索引，而少使用单列索引 。</li></ul><blockquote><p><font color='red' size=4> 创建复合索引进行测试</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_name_sta_address <span class="keyword">on</span> tb_seller(name, status, address);</span><br><span class="line"></span><br><span class="line">就相当于创建了三个索引 ： </span><br><span class="line">name</span><br><span class="line">name <span class="operator">+</span> status</span><br><span class="line">name <span class="operator">+</span> status <span class="operator">+</span> address</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716222147511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> index idx_seller_name_sta_addr  <span class="keyword">on</span> tb_seller;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716222201401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> 创建单列索引进行测试</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_seller_name <span class="keyword">on</span> tb_seller(name);</span><br><span class="line"><span class="keyword">create</span> index idx_seller_status <span class="keyword">on</span> tb_seller(status);</span><br><span class="line"><span class="keyword">create</span> index idx_seller_address <span class="keyword">on</span> tb_seller(address);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716222239213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4>数据库会选择一个最优的索引（辨识度最高索引）来使用，并不会使用全部索引 。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;西安市&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716222354116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210716222411794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4>创建组合索引进行测试</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210716222430316.png" alt="在这里插入图片描述"></p><h1 id="四-查看索引使用情况"><a href="#四-查看索引使用情况" class="headerlink" title="四. 查看索引使用情况"></a>四. 查看索引使用情况</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Handler_read%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Handler_read%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716222451119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210716222715876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap-Jdk1.8</title>
      <link href="/2021/09/04/ConcurrentHashMap---JDK1.8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/09/04/ConcurrentHashMap---JDK1.8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="一-ConcurrentHashMap源码分析—Jdk1-8"><a href="#一-ConcurrentHashMap源码分析—Jdk1-8" class="headerlink" title="一. ConcurrentHashMap源码分析—Jdk1.8"></a>一. ConcurrentHashMap源码分析—Jdk1.8</h1><h2 id="①-ConcurrentHashMap底层数据结构"><a href="#①-ConcurrentHashMap底层数据结构" class="headerlink" title="①. ConcurrentHashMap底层数据结构"></a>①. ConcurrentHashMap底层数据结构</h2><ul><li>ConcurrentHashMap相比HashMap而言，是多线程安全的，其底层数据与HashMap的数据结构相同</li></ul><blockquote><p><font color='red' size=4> 数组+链表+红黑树来实现的，使用了CAS的方式和Synchronized加锁来保证线程的安全。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210305212440663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="②-ConcurrentHashMap基本属性"><a href="#②-ConcurrentHashMap基本属性" class="headerlink" title="②. ConcurrentHashMap基本属性"></a>②. ConcurrentHashMap基本属性</h2><ul><li>对于ConcurrentHashMap而言，添加了Unsafe实例，主要用于反射获取对象相应的字段。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210516143800250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//版本号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7249069246763182397L</span>;</span><br><span class="line"><span class="comment">// node数组最大容量：2^30=1073741824</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 默认初始值，必须是2的幂数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="comment">//数组可能最大值，需要与toArray（）相关方法关联</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="comment">//并发级别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 链表转红黑树阀值,&gt; 8 链表转换为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="comment">//树转链表阀值，小于等于6（tranfer时，lc、hc=0两个计数器分别++记录原bin、新binTreeNode数量，&lt;=UNTREEIFY_THRESHOLD 则untreeify(lo)）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TRANSFER_STRIDE</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">RESIZE_STAMP_BITS</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 2^15-1，help resize的最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_RESIZERS</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 32-16=16，sizeCtl中记录size大小的偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESIZE_STAMP_SHIFT</span> <span class="operator">=</span> <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"><span class="comment">// forwarding nodes的hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOVED</span>     <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 树根节点的hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEBIN</span>   <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line"><span class="comment">// ReservationNode的hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESERVED</span>  <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"><span class="comment">// 可用处理器数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"><span class="comment">//存放node的数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">/*控制标识符，用来控制table的初始化和扩容的操作，不同的值有不同的含义</span></span><br><span class="line"><span class="comment"> *当为负数时：-1代表正在初始化，-N代表有N-1个线程正在 进行扩容</span></span><br><span class="line"><span class="comment"> *当为0时：代表当时的table还没有被初始化</span></span><br><span class="line"><span class="comment"> *当为正数时：表示初始化或者下一次进行扩容的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;</span><br></pre></td></tr></table></figure><h2 id="③-ConcurrentHashMap的Node节点"><a href="#③-ConcurrentHashMap的Node节点" class="headerlink" title="③. ConcurrentHashMap的Node节点"></a>③. ConcurrentHashMap的Node节点</h2><ul><li>Node是ConcurrentHashMap存储结构的基本单元，继承于HashMap中的Entry，用于存储数据</li><li>Node是最核心的内部类，它包装了key-value键值对，所有插入ConcurrentHashMap的数据都包装在这里面。它与HashMap中的定义很相似，但是但是有一些差别它对value和next属性设置了volatile同步锁，它不允许调用setValue方法直接改变Node的value域，它增加了find方法辅助map.get()方法。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210516144035183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">//链表的数据结构</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;    <span class="comment">//key的hash值</span></span><br><span class="line">    <span class="keyword">final</span> K key;       <span class="comment">//key</span></span><br><span class="line">    <span class="comment">//val和next都会在扩容时发生变化，所以加上volatile来保持可见性和禁止重排序</span></span><br><span class="line">    <span class="keyword">volatile</span> V val;   <span class="comment">//get操作全程不需要加锁是因为Node的成员val是用volatile修饰</span></span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;  <span class="comment">//表示链表中的下一个节点，数组用volatile修饰主要是保证在数组扩容的时候保证可见性</span></span><br><span class="line">    Node(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.hash = hash;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>       &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>     &#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>   &#123; <span class="keyword">return</span> key.hashCode() ^ val.hashCode(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + val; &#125;</span><br><span class="line">    <span class="comment">//不允许更新value </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V value)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        Object k, v, u; Map.Entry&lt;?,?&gt; e;</span><br><span class="line">        <span class="keyword">return</span> ((o <span class="keyword">instanceof</span> Map.Entry) &amp;&amp;</span><br><span class="line">                (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                (v = e.getValue()) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                (k == key || k.equals(key)) &amp;&amp;</span><br><span class="line">                (v == (u = val) || v.equals(u)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用于map中的get（）方法，子类重写</span></span><br><span class="line">    Node&lt;K,V&gt; <span class="title function_">find</span><span class="params">(<span class="type">int</span> h, Object k)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                K ek;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != <span class="literal">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="④-ConcurrentHashMap的红黑树TreeNode节点"><a href="#④-ConcurrentHashMap的红黑树TreeNode节点" class="headerlink" title="④.ConcurrentHashMap的红黑树TreeNode节点"></a>④.ConcurrentHashMap的红黑树TreeNode节点</h2><ul><li>TreeNode继承与Node，但是数据结构换成了二叉树结构，它是红黑树的数据的存储结构，用于红黑树中存储数据，当链表的节点数大于8时会转换成红黑树的结构，他就是通过TreeNode作为存储结构代替Node来转换成黑红树</li></ul><p><img src="https://img-blog.csdnimg.cn/20210516144153446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">//树形结构的属性定义</span></span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="type">boolean</span> red; <span class="comment">//标志红黑树的红节点</span></span><br><span class="line">    TreeNode(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next,</span><br><span class="line">             TreeNode&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, val, next);</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;K,V&gt; <span class="title function_">find</span><span class="params">(<span class="type">int</span> h, Object k)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findTreeNode(h, k, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据key查找 从根节点开始找出相应的TreeNode，</span></span><br><span class="line">    <span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">findTreeNode</span><span class="params">(<span class="type">int</span> h, Object k, Class&lt;?&gt; kc)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="literal">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">do</span>  &#123;</span><br><span class="line">                <span class="type">int</span> ph, dir; K pk; TreeNode&lt;K,V&gt; q;</span><br><span class="line">                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (pk != <span class="literal">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="literal">null</span>)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="literal">null</span>)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="literal">null</span> ||</span><br><span class="line">                          (kc = comparableClassFor(k)) != <span class="literal">null</span>) &amp;&amp;</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                    p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.findTreeNode(h, k, kc)) != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = pl;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑤-ConcurrentHashMap的TreeBin存储树形结构的容器"><a href="#⑤-ConcurrentHashMap的TreeBin存储树形结构的容器" class="headerlink" title="⑤. ConcurrentHashMap的TreeBin存储树形结构的容器"></a>⑤. ConcurrentHashMap的TreeBin存储树形结构的容器</h2><ul><li>TreeBin就是封装TreeNode的容器，它提供转换黑红树的一些条件和锁的控制</li></ul><p><img src="https://img-blog.csdnimg.cn/20210516144356109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeBin</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">//指向TreeNode列表和根节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root;</span><br><span class="line">    <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> lockState;</span><br><span class="line">    <span class="comment">// 读写锁状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WRITER</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 获取写锁的状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WAITER</span> <span class="operator">=</span> <span class="number">2</span>; <span class="comment">// 等待写锁的状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">READER</span> <span class="operator">=</span> <span class="number">4</span>; <span class="comment">// 增加数据时读锁的状态</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化红黑树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TreeBin(TreeNode&lt;K,V&gt; b) &#123;</span><br><span class="line">        <span class="built_in">super</span>(TREEBIN, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.first = b;</span><br><span class="line">        TreeNode&lt;K,V&gt; r = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = b, next; x != <span class="literal">null</span>; x = next) &#123;</span><br><span class="line">            next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">            x.left = x.right = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">                x.parent = <span class="literal">null</span>;</span><br><span class="line">                x.red = <span class="literal">false</span>;</span><br><span class="line">                r = x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> x.key;</span><br><span class="line">                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> x.hash;</span><br><span class="line">                Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = r;;) &#123;</span><br><span class="line">                    <span class="type">int</span> dir, ph;</span><br><span class="line">                    <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key;</span><br><span class="line">                    <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                        dir = -<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                        dir = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                              (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                             (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                        dir = tieBreakOrder(k, pk);</span><br><span class="line">                        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                    <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        x.parent = xp;</span><br><span class="line">                        <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                            xp.left = x;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            xp.right = x;</span><br><span class="line">                        r = balanceInsertion(r, x);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.root = r;</span><br><span class="line">        <span class="keyword">assert</span> <span class="title function_">checkInvariants</span><span class="params">(root)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑥-ConcurrentHashMap构造函数"><a href="#⑥-ConcurrentHashMap构造函数" class="headerlink" title="⑥. ConcurrentHashMap构造函数"></a>⑥. ConcurrentHashMap构造函数</h2><p><img src="https://img-blog.csdnimg.cn/20210516144801218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该构造函数用于创建一个带有默认初始容量 (16)、加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该构造函数用于创建一个带有指定初始容量、默认加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 参数的有效性检查</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="comment">//2.table初始化的长度(如果不指定默认情况下为16)。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该构造函数用于构造一个与给定映射具有相同映射关系的新映射</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该构造函数用于创建一个带有指定初始容量、加载因子和默认 concurrencyLevel (1) 的新的空映射。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该构造函数用于创建一个带有指定初始容量、加载因子和并发级别的新的空映射</span></span><br><span class="line"><span class="comment">// concurrencyLevel 表示能够同时更新ConccurentHashMap且不产生锁竞争的最大线程数。</span></span><br><span class="line"><span class="comment">// 默认值为16 即允许16个线程并发可能不会产生竞争</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,<span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="comment">//计算出容器的大小 初始化长度/加载因子+1</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">long</span>)(<span class="number">1.0</span> + (<span class="type">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> (size &gt;= (<span class="type">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="type">int</span>)size);</span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑦-ConcurrentHashMap的节点put流程"><a href="#⑦-ConcurrentHashMap的节点put流程" class="headerlink" title="⑦. ConcurrentHashMap的节点put流程"></a>⑦. ConcurrentHashMap的节点put流程</h2><h3 id="1-putVal-方法"><a href="#1-putVal-方法" class="headerlink" title="1. putVal()方法"></a>1. putVal()方法</h3><p><img src="https://img-blog.csdnimg.cn/2021051614500430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line"> <span class="comment">//K,V都不能为空，否则的话跑出异常</span></span><br><span class="line">       <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">//取得key的hash值</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());  </span><br><span class="line">    <span class="comment">//用来计算在这个节点总共有多少个元素，用来控制扩容或者转移为树  </span></span><br><span class="line">       <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;    </span><br><span class="line">       <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;    <span class="comment">//</span></span><br><span class="line">           Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">           <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)   </span><br><span class="line">    <span class="comment">//第一次put的时候table没有初始化，则初始化table </span></span><br><span class="line">               tab = initTable();    </span><br><span class="line">    <span class="comment">//否则通过哈希计算出一个表中的位置因为n是数组的长度，所以(n-1)&amp;hash肯定不会出现数组越界</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;  </span><br><span class="line">    <span class="comment">//如果这个位置没有元素的话，则通过cas的方式尝试添加，注意这个时候是没有加锁的  </span></span><br><span class="line">               <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,        </span><br><span class="line">               <span class="comment">//创建一个Node添加到数组中区，null表示的是下一个节点为空</span></span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))        </span><br><span class="line">                   <span class="keyword">break</span>;                   </span><br><span class="line">           &#125;</span><br><span class="line">    <span class="comment">//如果检测到某个节点的hash值是MOVED，则表示正在进行数组扩张的数据复制阶段，</span></span><br><span class="line">    <span class="comment">//则当前线程也会参与去复制，通过允许多线程复制的功能，一次来减少数组的复制所带来的性能损失</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)    </span><br><span class="line">               tab = helpTransfer(tab, f);</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * 如果在这个位置有元素的话，就采用synchronized的方式加锁，</span></span><br><span class="line"><span class="comment">                *     如果是链表的话(hash大于0)，就对这个链表的所有元素进行遍历，</span></span><br><span class="line"><span class="comment">                *         如果找到了key和key的hash值都一样的节点，则把它的值替换到</span></span><br><span class="line"><span class="comment">                *         如果没找到的话，则添加在链表的最后面</span></span><br><span class="line"><span class="comment">                *  否则，是树的话，则调用putTreeVal方法添加到树中去</span></span><br><span class="line"><span class="comment">                *  </span></span><br><span class="line"><span class="comment">                *  在添加完之后，会对该节点上关联的的数目进行判断，</span></span><br><span class="line"><span class="comment">                *  如果在8个以上的话，则会调用treeifyBin方法，来尝试转化为树，或者是扩容</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">               <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">               <span class="comment">//再次取出要存储的位置的元素，跟前面取出来的比较</span></span><br><span class="line">                   <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;      </span><br><span class="line">               <span class="comment">//取出来的元素的hash值大于0，当转换为树之后，hash值为-2  </span></span><br><span class="line">                       <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;                </span><br><span class="line">                           binCount = <span class="number">1</span>;            </span><br><span class="line">                      <span class="comment">//遍历这个链表</span></span><br><span class="line">                           <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;    </span><br><span class="line">                               K ek;</span><br><span class="line">                      <span class="comment">//要存的元素的hash，key跟要存储的位置的节点的相同的时候，替换掉该节点的value即可</span></span><br><span class="line">                               <span class="keyword">if</span> (e.hash == hash &amp;&amp;        </span><br><span class="line">                                   ((ek = e.key) == key ||</span><br><span class="line">                                    (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                   oldVal = e.val;</span><br><span class="line">                      <span class="comment">//当使用putIfAbsent的时候，只有在这个key没有设置值得时候才设置</span></span><br><span class="line">                                   <span class="keyword">if</span> (!onlyIfAbsent)        </span><br><span class="line">                                       e.val = value;</span><br><span class="line">                                   <span class="keyword">break</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                               Node&lt;K,V&gt; pred = e;</span><br><span class="line">                      <span class="comment">//如果不是同样的hash，同样的key的时候，则判断该节点的下一个节点是否为空，</span></span><br><span class="line">                               <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;    </span><br><span class="line">                      <span class="comment">//为空的话把这个要加入的节点设置为当前节点的下一个节点</span></span><br><span class="line">                                   pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,        </span><br><span class="line">                                                             value, <span class="literal">null</span>);</span><br><span class="line">                                   <span class="keyword">break</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">//表示已经转化成红黑树类型了</span></span><br><span class="line">                       <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;    </span><br><span class="line">                           Node&lt;K,V&gt; p;</span><br><span class="line">                           binCount = <span class="number">2</span>;</span><br><span class="line">                       <span class="comment">//调用putTreeVal方法，将该元素添加到树中去</span></span><br><span class="line">                           <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,    </span><br><span class="line">                                                          value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                               oldVal = p.val;</span><br><span class="line">                               <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                   p.val = value;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//当在同一个节点的数目达到8个的时候，则扩张数组或将给节点的数据转为tree</span></span><br><span class="line">                   <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)    </span><br><span class="line">                       treeifyBin(tab, i);    </span><br><span class="line">                   <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                       <span class="keyword">return</span> oldVal;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="comment">//计数</span></span><br><span class="line">       addCount(<span class="number">1L</span>, binCount);   </span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">（<span class="number">1</span>）如果桶数组未初始化，则初始化；</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）如果待插入的元素所在的桶为空，则尝试把此元素直接插入到桶的第一个位置；</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）如果正在扩容，则当前线程一起加入到扩容的过程中；</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）如果待插入的元素所在的桶不为空且不在迁移元素，则锁住这个桶（分段锁）；</span><br><span class="line"></span><br><span class="line">（<span class="number">5</span>）如果当前桶中元素以链表方式存储，则在链表中寻找该元素或者插入元素；</span><br><span class="line"></span><br><span class="line">（<span class="number">6</span>）如果当前桶中元素以红黑树方式存储，则在红黑树中寻找该元素或者插入元素；</span><br><span class="line"></span><br><span class="line">（<span class="number">7</span>）如果元素存在，则返回旧值；</span><br><span class="line"></span><br><span class="line">（<span class="number">8</span>）如果元素不存在，整个Map的元素个数加<span class="number">1</span>，并检查是否需要扩容；</span><br><span class="line"></span><br><span class="line">添加元素操作中使用的锁主要有（自旋锁 + CAS + <span class="keyword">synchronized</span> + 分段锁）。</span><br></pre></td></tr></table></figure><h3 id="2-initTable-方法初始化数组"><a href="#2-initTable-方法初始化数组" class="headerlink" title="2. initTable() 方法初始化数组"></a>2. initTable() 方法初始化数组</h3><ul><li>对于table的大小，会根据sizeCtl的值进行设置，如果没有设置szieCtl的值，那么默认生成的table大小为16，否则，会根据sizeCtl的大小设置table大小。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210516145130263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="comment">//空的table才能进入初始化操作</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//sizeCtl&lt;0表示其他线程已经在初始化了或者扩容了，挂起当前线程</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>) </span><br><span class="line">            Thread.yield(); </span><br><span class="line">    <span class="comment">//CAS操作SIZECTL为-1，表示初始化状态</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="comment">//初始化</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//记录下次扩容的大小</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-tabAt-方法"><a href="#3-tabAt-方法" class="headerlink" title="3. tabAt() 方法"></a>3. tabAt() 方法</h3><ul><li>此函数返回table数组中下标为i的结点，可以看到是通过Unsafe对象通过反射获取的，getObjectVolatile的第二项参数为下标为i的偏移地址。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210719165505101.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取索引i处Node</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="title function_">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-casTabAt-方法"><a href="#4-casTabAt-方法" class="headerlink" title="4. casTabAt() 方法"></a>4. casTabAt() 方法</h3><ul><li>此函数用于比较table数组下标为i的结点是否为c，若为c，则用v交换操作。否则，不进行交换操作。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210719165611956.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用CAS算法设置i位置上的Node节点（将c和table[i]比较，相同则插入v）。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i,</span></span><br><span class="line"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-helpTransfer-方法"><a href="#5-helpTransfer-方法" class="headerlink" title="5. helpTransfer() 方法"></a>5. helpTransfer() 方法</h3><ul><li><p>此函数用于在扩容时将table表中的结点转移到nextTable中。</p></li><li><p>如果取出来的节点的hash值是MOVED(-1)的话，则表示当前正在对这个数组进行扩容</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210516145242230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *帮助从旧的table的元素复制到新的table中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="literal">null</span>) &#123; </span><br><span class="line">        <span class="comment">//新的table nextTba已经存在前提下才能帮助扩容</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(tab.length);</span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">//调用扩容方法</span></span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-treeifyBin-方法-链表转红黑树"><a href="#6-treeifyBin-方法-链表转红黑树" class="headerlink" title="6. treeifyBin() 方法 链表转红黑树"></a>6. treeifyBin() 方法 链表转红黑树</h3><ul><li>此函数用于将桶中的数据结构转化为红黑树，其中，值得注意的是，当table的长度未达到阈值时，会进行一次扩容操作，该操作会使得触发treeifyBin操作的某个桶中的所有元素进行一次重新分配，这样可以避免某个桶中的结点数量太大。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表转红黑树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; b; <span class="type">int</span> n, sc;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//若length&lt;64,直接tryPresize,两倍table.length;不转树</span></span><br><span class="line">            <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">                <span class="comment">//扩容函数为：tryPresize</span></span><br><span class="line">                tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//只有当tab.length &gt;= 64, ConcurrentHashMap才会使用红黑树。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="literal">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (b) &#123; <span class="comment">// 对桶中第一个结点进行加锁</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;  <span class="comment">// 第一个结点没有变化</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">// 遍历桶中所有结点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="comment">// 新生一个TreeNode结点</span></span><br><span class="line">                            TreeNode&lt;K,V&gt; p =<span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;(e.hash, e.key, e.val,<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((p.prev = tl) == <span class="literal">null</span>)  <span class="comment">// 该结点前驱为空</span></span><br><span class="line">                                <span class="comment">// 设置p为头结点</span></span><br><span class="line">                                hd = p;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                <span class="comment">// 尾节点的next域赋值为p</span></span><br><span class="line">                                tl.next = p;</span><br><span class="line">                            <span class="comment">// 尾节点赋值为p</span></span><br><span class="line">                            tl = p;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 设置table表中下标为index的值为hd</span></span><br><span class="line">                        setTabAt(tab, index, <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hd));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-transfer-扩容方法"><a href="#7-transfer-扩容方法" class="headerlink" title="7. transfer() 扩容方法"></a>7. transfer() 扩容方法</h3><ul><li>ConcurrentHashMap扩容是允许多个线程并发进行扩容的，首先构造一个两倍于当前数据长度的数组，然后计算每个线程处理的槽的空间，然后通过死循环依次递减的方式对每个槽位进行判断知道有实际值的槽位，通过将槽位的每个节点分成2个链表将高位逻辑与计算为1的链表插入到i+n的位置，同时将旧的节点设置为占位符然后继续向前推进扩容操作。<br><img src="https://img-blog.csdnimg.cn/20210305220929894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><p><img src="https://img-blog.csdnimg.cn/20210516145342988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tab.length, stride;</span><br><span class="line">        <span class="comment">// 每核处理的量小于16，则强制赋值16</span></span><br><span class="line">        <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">            stride = MIN_TRANSFER_STRIDE; </span><br><span class="line">        <span class="keyword">if</span> (nextTab == <span class="literal">null</span>) &#123;            </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="comment">//构建一个nextTable对象，其容量为原来容量的两倍</span></span><br><span class="line">                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];        </span><br><span class="line">                nextTab = nt;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      </span><br><span class="line">                sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nextTable = nextTab;</span><br><span class="line">            transferIndex = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextn</span> <span class="operator">=</span> nextTab.length;</span><br><span class="line">        <span class="comment">// 连接点指针，用于标志位（fwd的hash值为-1，fwd.nextTable=nextTab）</span></span><br><span class="line">        ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);</span><br><span class="line">        <span class="comment">// 当advance == true时，表明该节点已经处理过了</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">advance</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">finishing</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="type">int</span> fh;</span><br><span class="line">            <span class="comment">// 控制 --i ,遍历原hash表中的节点</span></span><br><span class="line">            <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">                <span class="type">int</span> nextIndex, nextBound;</span><br><span class="line">                <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                    advance = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    i = -<span class="number">1</span>;</span><br><span class="line">                    advance = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 用CAS计算得到的transferIndex</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                        (<span class="built_in">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                                nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                        nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                    bound = nextBound;</span><br><span class="line">                    i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                    advance = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">                <span class="type">int</span> sc;</span><br><span class="line">                <span class="comment">// 已经完成所有节点复制了</span></span><br><span class="line">                <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                    nextTable = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">// table 指向nextTable</span></span><br><span class="line">                    table = nextTab;        </span><br><span class="line">                    <span class="comment">// sizeCtl阈值为原来的1.5倍</span></span><br><span class="line">                    sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);     </span><br><span class="line">                    <span class="keyword">return</span>;     <span class="comment">// 跳出死循环，</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// CAS 更扩容阈值，在这里面sizectl值减一，说明新加入一个线程参与到扩容操作</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    finishing = advance = <span class="literal">true</span>;</span><br><span class="line">                    i = n; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历的节点为null，则放入到ForwardingNode 指针节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="literal">null</span>)</span><br><span class="line">                advance = casTabAt(tab, i, <span class="literal">null</span>, fwd);</span><br><span class="line">            <span class="comment">// f.hash == -1 表示遍历到了ForwardingNode节点，意味着该节点已经处理过了</span></span><br><span class="line">            <span class="comment">// 这里是控制并发扩容的核心</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                advance = <span class="literal">true</span>; <span class="comment">// already processed</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 节点加锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="comment">// 节点复制工作</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                        <span class="comment">// fh &gt;= 0 ,表示为链表节点</span></span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 构造两个链表  一个是原链表  另一个是原链表的反序排列</span></span><br><span class="line">                            <span class="type">int</span> <span class="variable">runBit</span> <span class="operator">=</span> fh &amp; n;</span><br><span class="line">                            Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">                                <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> p.hash &amp; n;</span><br><span class="line">                                <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                    runBit = b;</span><br><span class="line">                                    lastRun = p;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                                ln = lastRun;</span><br><span class="line">                                hn = <span class="literal">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                hn = lastRun;</span><br><span class="line">                                ln = <span class="literal">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                                <span class="type">int</span> <span class="variable">ph</span> <span class="operator">=</span> p.hash; <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key; <span class="type">V</span> <span class="variable">pv</span> <span class="operator">=</span> p.val;</span><br><span class="line">                                <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                    ln = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hn = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 在nextTable i 位置处插上链表</span></span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            <span class="comment">// 在nextTable i + n 位置处插上链表</span></span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            <span class="comment">// 在table i 位置处插上ForwardingNode 表示该节点已经处理过了</span></span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            <span class="comment">// advance = true 可以执行--i动作，遍历节点</span></span><br><span class="line">                            advance = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果是TreeBin，则按照红黑树进行处理，处理逻辑与上面一致</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; lo = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                            TreeNode&lt;K,V&gt; hi = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> e.hash;</span><br><span class="line">                                TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;</span><br><span class="line">                                        (h, e.key, e.val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                                        lo = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        loTail.next = p;</span><br><span class="line">                                    loTail = p;</span><br><span class="line">                                    ++lc;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                                        hi = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        hiTail.next = p;</span><br><span class="line">                                    hiTail = p;</span><br><span class="line">                                    ++hc;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 扩容后树节点个数若&lt;=6，将树转链表</span></span><br><span class="line">                            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                                    (hc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;</span><br><span class="line">                            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                                    (lc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;</span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="8-addCount-方法-计算size"><a href="#8-addCount-方法-计算size" class="headerlink" title="8. addCount() 方法 计算size"></a>8. addCount() 方法 计算size</h3><ul><li>ConcurrentHashMap的size方法是读取baseCount和CounterCell数据的总数量，因为是并发的也不一定正确；</li><li>此函数主要完成binCount的值加1的操作。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210516145437727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addCount</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> check)</span> &#123;</span><br><span class="line">    CounterCell[] as; <span class="type">long</span> b, s;</span><br><span class="line">    <span class="comment">//更新baseCount，table的数量，counterCells表示元素个数的变化</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="literal">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="built_in">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="type">long</span> v; <span class="type">int</span> m;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//如果多个线程都在执行，则CAS失败，执行fullAddCount，全部加入count</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//check&gt;=0表示需要进行扩容操作</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="type">int</span> n, sc;</span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前线程发起库哦哦让操作，nextTable=null</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="literal">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="9-putVal-流程总结"><a href="#9-putVal-流程总结" class="headerlink" title="9. putVal() 流程总结"></a>9. putVal() 流程总结</h3><ul><li><p>① 判断存储的key、value是否为空，若为空，则抛出异常，否则，进入步骤②</p></li><li><p>② 计算key的hash值，随后进入无限循环，该无限循环可以确保成功插入数据，若table表为空或者长度为0，则初始化table表，否则，进入步骤③</p></li><li><p>③ 根据key的hash值取出table表中的结点元素，若取出的结点为空（该桶为空），则使用CAS将key、value、hash值生成的结点放入桶中。否则，进入步骤④</p></li><li><p>④ 若该结点的的hash值为MOVED，则对该桶中的结点进行转移，否则，进入步骤⑤</p></li><li><p>⑤ 对桶中的第一个结点（即table表中的结点）进行加锁，对该桶进行遍历，桶中的结点的hash值与key值与给定的hash值和key值相等，则根据标识选择是否进行更新操作（用给定的value值替换该结点的value值），若遍历完桶仍没有找到hash值与key值和指定的hash值与key值相等的结点，则直接新生一个结点并赋值为之前最后一个结点的下一个结点。进入步骤⑥</p></li><li><p>⑥ 若binCount值达到红黑树转化的阈值，则将桶中的结构转化为红黑树存储，最后，增加binCount的值。</p></li></ul><h2 id="⑧-ConcurrentHashMap的get-操作"><a href="#⑧-ConcurrentHashMap的get-操作" class="headerlink" title="⑧. ConcurrentHashMap的get()操作"></a>⑧. ConcurrentHashMap的get()操作</h2><ul><li>get函数根据key的hash值来计算在哪个桶中，再遍历桶，查找元素，若找到则返回该结点，否则，返回null。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210516150024421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*get支持并发操作，</span></span><br><span class="line"><span class="comment">    * 当key为null的时候回抛出NullPointerException的异常</span></span><br><span class="line"><span class="comment">    * get操作通过首先计算key的hash值来确定该元素放在数组的哪个位置</span></span><br><span class="line"><span class="comment">    * 然后遍历该位置的所有节点</span></span><br><span class="line"><span class="comment">    * 如果不存在的话返回null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//获取值get(key)</span></span><br><span class="line">   <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">       <span class="comment">//两次hash计算出hash值</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">       <span class="comment">//通过首先计算key的hash值来确定该元素放在tab[i]数组的哪个位置</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">           (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">//检查头结点 key相等hash值相等 直接返回</span></span><br><span class="line">           <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">               <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                   <span class="keyword">return</span> e.val;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//table[i]为一颗树</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">           <span class="comment">////链表,遍历寻找即可</span></span><br><span class="line">           <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                   ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                   <span class="keyword">return</span> e.val;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果不存在的话返回null</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="二-ConcurrentHashMap常见问题"><a href="#二-ConcurrentHashMap常见问题" class="headerlink" title="二. ConcurrentHashMap常见问题"></a>二. ConcurrentHashMap常见问题</h1><blockquote><p><font color='red'>ConcurrentHashMap迭代器是强一致性还是弱一致性？HashMap呢？</p></blockquote><ul><li><p>弱一致性，hashmap强一直性。</p></li><li><p>ConcurrentHashMap可以支持在迭代过程中，向map添加新元素，而HashMap则抛出了ConcurrentModificationException，</p></li><li><p>ConcurrentHashMap的弱一致性主要表现在他的一些视图和迭代器上，通过迭代器遍历元素的时候如果之前的元素发生修改是不会抛出fail-fast异常的，后面的元素如果修改了会体现在迭代器遍历的结果上。</p></li><li><p>因为HashMap包含一个修改计数器，当你调用他的next()方法来获取下一个元素时，迭代器将会用到这个计数器。</p></li></ul><blockquote><p><font color='red'> ConcurrentHashMap1.7和1.8的区别：</p></blockquote><ul><li><p>JDK1.8的实现降低锁的粒度，JDK1.7锁的粒度是基于Segment的，包含多个HashEntry，而JDK1.8锁的粒度就是Node</p></li><li><p>数据结构：JDK1.7 Segment+HashEntry；JDK1.8 数组+链表+红黑树+CAS+synchronized</p></li></ul><h1 id="三-图解扩容流程"><a href="#三-图解扩容流程" class="headerlink" title="三. 图解扩容流程"></a>三. 图解扩容流程</h1>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis-AOF</title>
      <link href="/2021/09/01/Redis%E6%8C%81%E4%B9%85%E5%8C%96-AOF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2021/09/01/Redis%E6%8C%81%E4%B9%85%E5%8C%96-AOF%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="一-AOF简介"><a href="#一-AOF简介" class="headerlink" title="一. AOF简介"></a>一. AOF简介</h1><ul><li>与内存快照保存当前内存中的数据所不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。即每执行一个命令，就会把该命令写到日志文件里。</li></ul><h1 id="二-AOF-配置"><a href="#二-AOF-配置" class="headerlink" title="二. AOF 配置"></a>二. AOF 配置</h1><h2 id="①-appendonly：默认值为no"><a href="#①-appendonly：默认值为no" class="headerlink" title="①. appendonly：默认值为no"></a>①. appendonly：默认值为no</h2><ul><li>也就是说redis 默认使用的是rdb方式持久化，如果想要开启 AOF 持久化方式，需要将 appendonly 修改为 yes。</li></ul><h2 id="②-appendfilename-：aof文件名"><a href="#②-appendfilename-：aof文件名" class="headerlink" title="②. appendfilename ：aof文件名"></a>②. appendfilename ：aof文件名</h2><ul><li>默认是”appendonly.aof”</li></ul><h2 id="③、appendfsync：aof持久化策略的配置"><a href="#③、appendfsync：aof持久化策略的配置" class="headerlink" title="③、appendfsync：aof持久化策略的配置"></a>③、appendfsync：aof持久化策略的配置</h2><ul><li><p><strong>no</strong> 表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快，但是不太安全；</p></li><li><p><strong>always</strong> 表示每次写入都执行fsync，以保证数据同步到磁盘，效率很低；</p></li><li><p><strong>everysec</strong> 表示每秒执行一次fsync，可能会导致丢失这1s数据。通常选择 everysec ，兼顾安全性和效率。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210709081426460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="④、no-appendfsync-on-rewrite：默认值为no。"><a href="#④、no-appendfsync-on-rewrite：默认值为no。" class="headerlink" title="④、no-appendfsync-on-rewrite：默认值为no。"></a>④、no-appendfsync-on-rewrite：默认值为no。</h2><ul><li>在aof重写或者写入rdb文件的时候，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync会造成阻塞过长时间，no-appendfsync-on-rewrite字段设置为默认设置为no。如果对延迟要求很高的应用，这个字段可以设置为yes，否则还是设置为no，这样对持久化特性来说这是更安全的选择。   设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yes。Linux的默认fsync策略是30秒。可能丢失30秒数据。</li></ul><h2 id="⑤、auto-aof-rewrite-percentage：默认值为100。"><a href="#⑤、auto-aof-rewrite-percentage：默认值为100。" class="headerlink" title="⑤、auto-aof-rewrite-percentage：默认值为100。"></a>⑤、auto-aof-rewrite-percentage：默认值为100。</h2><ul><li>aof自动重写配置，当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候，Redis能够调用bgrewriteaof对日志文件进行重写。当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程。</li></ul><h2 id="⑥、auto-aof-rewrite-min-size：64mb。"><a href="#⑥、auto-aof-rewrite-min-size：64mb。" class="headerlink" title="⑥、auto-aof-rewrite-min-size：64mb。"></a>⑥、auto-aof-rewrite-min-size：64mb。</h2><ul><li>设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写。</li></ul><h2 id="⑦、aof-load-truncated：默认值为-yes。"><a href="#⑦、aof-load-truncated：默认值为-yes。" class="headerlink" title="⑦、aof-load-truncated：默认值为 yes。"></a>⑦、aof-load-truncated：默认值为 yes。</h2><ul><li>aof文件可能在尾部是不完整的，当redis启动的时候，aof文件的数据被载入内存。重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data&#x3D;ordered选项，出现这种现象  redis宕机或者异常终止不会造成尾部不完整现象，可以选择让redis退出，或者导入尽可能多的数据。如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复AOF文件才可以。</li></ul><h1 id="三-AOF执行后写日志"><a href="#三-AOF执行后写日志" class="headerlink" title="三. AOF执行后写日志"></a>三. AOF执行后写日志</h1><p><img src="https://img-blog.csdnimg.cn/20210709081024340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>这样做的好处就是不会阻塞当前操作，也可以避免额外的检查开销，如果是在命令执行前进行写日志的操作，一旦命令语法是错误的，不进行检查的话就会导致写入到日志文件中的命令是错误的，在使用日志文件恢复数据的时候就会出错。而在命令执行后在进行日志的写入则不会有这个问题。</p></li><li><p>但是也存在两个问题，</p><ul><li><p>AOF 虽然避免了对当前命令的阻塞，但却可能会给下一个操作带来阻塞风险。因为，AOF 日志是在主进程中执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了</p></li><li><p>如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。如果此时 Redis 是用作缓存，还可以从后端数据库重新读入数据进行恢复，但是，如果 Redis 是直接用作数据库的话，此时，因为命令没有记入日志，所以就无法用日志进行恢复了。</p></li></ul></li></ul><h1 id="四-AOF-缓冲区"><a href="#四-AOF-缓冲区" class="headerlink" title="四. AOF 缓冲区"></a>四. AOF 缓冲区</h1><ul><li>Redis在执行完命令进行持久化的时候，并非直接写入磁盘日志文件，而是先写入AOF缓冲区内，之后再通过某种策略写到磁盘。</li></ul><p><img src="https://img-blog.csdnimg.cn/2021070908124280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="五-AOF-重写"><a href="#五-AOF-重写" class="headerlink" title="五.  AOF 重写"></a>五.  AOF 重写</h1><ul><li>由于AOF持久化是Redis不断将写命令记录到 AOF 文件中，随着Redis不断的进行，AOF 的文件会越来越大，文件越大，占用服务器内存越大以及 AOF 恢复要求时间越长。为了解决这个问题，Redis新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。可以使用命令 bgrewriteaof 来重写。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210709081625773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>如果不进行 AOF 文件重写，那么 AOF 文件将保存四条 SADD 命令，如果使用AOF 重写，那么AOF 文件中将只会保留下面一条命令：sadd animals “dog “ “tiger “ “panda “ “lion “ “cat “。</p></li><li><p><strong>也就是说 AOF 文件重写并不是对原文件进行重新整理，而是直接读取服务器现有的键值对，然后用一条命令去代替之前记录这个键值对的多条命令，生成一个新的文件后去替换原来的 AOF 文件。</strong></p></li><li><p>AOF 文件重写触发机制：通过 redis.conf 配置文件中的 auto-aof-rewrite-percentage：默认值为100，以及auto-aof-rewrite-min-size：64mb 配置，也就是说默认Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。</p></li><li><p>我们知道 Redis 是单线程工作，如果 重写 AOF 需要比较长的时间，那么在重写 AOF 期间，Redis将长时间无法处理其他的命令，这显然是不能忍受的。Redis为了克服这个问题，解决办法是将 AOF 重写程序放到子程序中进行，这样有两个好处：</p><ul><li>①、子进程进行 AOF 重写期间，服务器进程（父进程）可以继续处理其他命令。</li><li>②、子进程带有父进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</li></ul></li><li><p>为了解决这个数据状态不一致的问题，Redis 服务器设置了一个 <strong>AOF 重写缓冲区</strong>，这个缓冲区是在创建子进程后开始使用，当Redis服务器执行一个写命令之后，就会将这个写命令也发送到 AOF 重写缓冲区。当子进程完成 AOF 重写之后，就会给父进程发送一个信号，父进程接收此信号后，就会调用函数将 AOF 重写缓冲区的内容都写到新的 AOF 文件中。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210709082056784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>在子进程执行AOF重写期间。服务器进程需要执行以下3个动作：</p><ul><li>执行客户端命令</li><li>执行后追加到AOF缓冲区</li><li>执行后追加到AOF重写缓冲区</li></ul></li><li><p>子进程完成AOF重写后，它向父进程发送一个信号，父进程收到信号后会调用一个信号处理函数，该函数把AOF重写缓冲区的命令追加到新AOF文件中然后替换掉现有AOF文件。父进程处理完毕后可以继续接受客户端命令调用，可以看出在AOF后台重写过程中只有这个信号处理函数会阻塞服务器进程。</p></li></ul><h1 id="六-AOF文件恢复"><a href="#六-AOF文件恢复" class="headerlink" title="六. AOF文件恢复"></a>六. AOF文件恢复</h1><ul><li><p>在Redis 服务器重启后，会优先去载入AOF日志文件。因为AOF文件里面包含了重建数据库状态所需的所有写命令,所以服务器重新执行一遍AOF文件里面保存的写命令,就可以还原服务器关闭之前的数据库状态。</p></li><li><p>而由于Redis命令只能在客户端上下文中执行，Redis会创建一个没有网络连接的伪客户端来执行AOF文件中的内容。</p></li></ul><h1 id="七-AOF的优缺点"><a href="#七-AOF的优缺点" class="headerlink" title="七. AOF的优缺点"></a>七. AOF的优缺点</h1><blockquote><p><font color='red' size=4>优点：</p></blockquote><ul><li><p>①、AOF 持久化的方法提供了多种的同步频率，即使使用默认的同步频率每秒同步一次，Redis 最多也就丢失 1 秒的数据而已。</p></li><li><p>②、AOF 文件使用 Redis 命令追加的形式来构造，因此，即使 Redis 只能向 AOF 文件写入命令的片断，使用 redis-check-aof 工具也很容易修正 AOF 文件。</p></li><li><p>③、AOF 文件的格式可读性较强，这也为使用者提供了更灵活的处理方式。例如，如果我们不小心错用了 FLUSHALL 命令，在重写还没进行时，我们可以手工将最后的 FLUSHALL 命令去掉，然后再使用 AOF 来恢复数据。</p></li></ul><blockquote><p><font color='red' size=4>缺点：</p></blockquote><ul><li><p>①、对于具有相同数据的的 Redis，AOF 文件通常会比 RDB文件体积更大。</p></li><li><p>②、虽然 AOF 提供了多种同步的频率，默认情况下，每秒同步一次的频率也具有较高的性能。但在 Redis 的负载较高时，RDB 比 AOF 具好更好的性能保证。</p></li><li><p>③、RDB 使用快照的形式来持久化整个 Redis 数据，而 AOF 只是将每次执行的命令追加到 AOF 文件中，因此从理论上说，RDB 比 AOF 方式更健壮。官方文档也指出，AOF 的确也存在一些 BUG，这些 BUG 在 RDB 没有存在。</p></li></ul><blockquote><p><font color='red' size=4>那么对于 AOF 和 RDB 两种持久化方式，我们应该如何选择呢？</p></blockquote><ul><li>如果可以忍受一小段时间内数据的丢失，毫无疑问使用 RDB 是最好的，定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，而且使用 RDB 还可以避免 AOF 一些隐藏的 bug；否则就使用 AOF 重写。但是一般情况下建议不要单独使用某一种持久化机制，而是应该两种一起用，在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。Redis后期官方可能都有将两种持久化方式整合为一种持久化模型。</li></ul><h1 id="八-RDB-AOF混合持久化"><a href="#八-RDB-AOF混合持久化" class="headerlink" title="八. RDB-AOF混合持久化"></a>八. RDB-AOF混合持久化</h1><ul><li><p>在Redis4.0之后，新增了RDB-AOF混合持久化方式。这种方式结合了RDB和AOF的优点，既能快速加载又能避免丢失过多的数据。</p></li><li><p>具体配置为：aof-use-rdb-preamble: 设置为yes表示开启，设置为no表示禁用。</p></li><li><p>当开启混合持久化时，主进程先fork出子进程将现有内存副本全量以RDB方式写入aof文件中，然后将缓冲区中的增量命令以AOF方式写入aof文件中，写入完成后通知主进程更新相关信息，并将新的含有 RDB和AOF两种格式的aof文件替换旧的aof文件。</p></li><li><p>简单来说：混合持久化方式产生的文件一部分是RDB格式，一部分是AOF格式。</p></li><li><p>这种方式优点我们很好理解，缺点就是不能兼容Redis4.0之前版本的备份文件了</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis-RDB</title>
      <link href="/2021/09/01/Redis%E6%8C%81%E4%B9%85%E5%8C%96-RDB%20%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2021/09/01/Redis%E6%8C%81%E4%B9%85%E5%8C%96-RDB%20%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="一-RDB-简介"><a href="#一-RDB-简介" class="headerlink" title="一. RDB 简介"></a>一. RDB 简介</h1><ul><li>RDB是Redis用来进行持久化的一种方式，是把当前内存中的数据集快照写入磁盘，也就是 Snapshot 快照（数据库中所有键值对数据）。恢复时是将快照文件直接读到内存里。</li></ul><h1 id="二-触发方式"><a href="#二-触发方式" class="headerlink" title="二. 触发方式"></a>二. 触发方式</h1><h2 id="①-自动触发"><a href="#①-自动触发" class="headerlink" title="①. 自动触发"></a>①. 自动触发</h2><p><img src="https://img-blog.csdnimg.cn/20210707230116598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="1-save"><a href="#1-save" class="headerlink" title="1. save"></a>1. save</h3><ul><li><p>这里是用来配置触发 Redis的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave（这个命令下面会介绍，手动触发RDB持久化的命令）</p></li><li><p>默认如下配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span>：表示<span class="number">900</span> 秒内如果至少有 <span class="number">1</span> 个 key 的值变化，则保存</span><br><span class="line">save <span class="number">300</span> <span class="number">10</span>：表示<span class="number">300</span> 秒内如果至少有 <span class="number">10</span> 个 key 的值变化，则保存</span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span>：表示<span class="number">60</span> 秒内如果至少有 <span class="number">10000</span> 个 key 的值变化，则保存</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-stop-writes-on-bgsave-error"><a href="#2-stop-writes-on-bgsave-error" class="headerlink" title="2. stop-writes-on-bgsave-error"></a>2. stop-writes-on-bgsave-error</h3><ul><li>默认值为yes。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了</li></ul><h3 id="3-rdbcompression"><a href="#3-rdbcompression" class="headerlink" title="3. rdbcompression"></a>3. rdbcompression</h3><ul><li>默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能，但是存储在磁盘上的快照会比较大。</li></ul><h3 id="4-rdbchecksum"><a href="#4-rdbchecksum" class="headerlink" title="4. rdbchecksum"></a>4. rdbchecksum</h3><ul><li>默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</li></ul><h3 id="5-dbfilename"><a href="#5-dbfilename" class="headerlink" title="5. dbfilename"></a>5. dbfilename</h3><ul><li>设置快照的文件名，默认是 dump.rdb</li></ul><h3 id="6-dir"><a href="#6-dir" class="headerlink" title="6. dir"></a>6. dir</h3><ul><li>设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。默认是和当前配置文件保存在同一目录。</li></ul><p>　　也就是说通过在配置文件中配置的 save 方式，当实际操作满足该配置形式时就会进行 RDB 持久化，将当前的内存快照保存在 dir 配置的目录中，文件名由配置的 dbfilename 决定。</p><h2 id="②-手动触发"><a href="#②-手动触发" class="headerlink" title="②. 手动触发"></a>②. 手动触发</h2><ul><li>手动触发Redis进行RDB持久化的命令有两种：</li></ul><h3 id="1-save-1"><a href="#1-save-1" class="headerlink" title="1. save"></a>1. save</h3><ul><li><p>该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。</p></li><li><p>显然该命令对于内存比较大的实例会造成长时间阻塞，这是致命的缺陷，为了解决此问题，Redis提供了第二种方式。</p></li></ul><h3 id="2-bgsave"><a href="#2-bgsave" class="headerlink" title="2. bgsave"></a>2. bgsave</h3><ul><li>bgsave命令会派生出一个子进程(而不是线程)，由子进程进行RDB文件创建，而父进程继续处理命令。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210707230621955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>基本上 Redis 内部所有的RDB操作都是采用 bgsave 命令。</li></ul><h1 id="三-RDB文件的载入"><a href="#三-RDB文件的载入" class="headerlink" title="三. RDB文件的载入"></a>三. RDB文件的载入</h1><ul><li><p>在Redis启动的时候，只要检测到RDB文件的存在，就会自动加载RDB文件。需要注意的是</p><ul><li><p>因为AOF文件的更新频率通常比RDB文件的更新频率高,所以口如果服务器开启了AOF持久化功能,那么服务器会优先使用AOF文件来还原数据库状态。</p></li><li><p>只有在AOF持久化功能处于关闭状态时,服务器才会使用RDB文件来还原数据库状态。</p></li></ul></li><li><p>Redis 服务器在载入 RDB 文件期间，会一直处于阻塞状态，直到载入工作完成为止。</p></li></ul><h1 id="四-停止-RDB-持久化"><a href="#四-停止-RDB-持久化" class="headerlink" title="四. 停止 RDB 持久化"></a>四. 停止 RDB 持久化</h1><ul><li><p>有些情况下，我们只想利用Redis的缓存功能，并不像使用 Redis 的持久化功能，那么这时候我们最好停掉 RDB 持久化。可以通过上面讲的在配置文件 redis.conf 中，可以注释掉所有的 save 行来停用保存功能或者直接一个空字符串来实现停用：<strong>save “ “</strong></p></li><li><p>也可以通过命令： <strong>redis-cli config set save “ “</strong></p></li></ul><h1 id="五-RDB-自动保存的原理"><a href="#五-RDB-自动保存的原理" class="headerlink" title="五. RDB 自动保存的原理"></a>五. RDB 自动保存的原理</h1><ul><li>Redis有个服务器状态结构：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisService</span>&#123;</span></span><br><span class="line">     <span class="comment">//1、记录保存save条件的数组</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparams</span>;</span></span><br><span class="line">     <span class="comment">//2、修改计数器</span></span><br><span class="line">     <span class="type">long</span> <span class="type">long</span> dirty;</span><br><span class="line">     <span class="comment">//3、上一次执行保存的时间</span></span><br><span class="line">     <span class="type">time_t</span> lastsave;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="①-数组-saveparam"><a href="#①-数组-saveparam" class="headerlink" title="①. 数组 saveparam"></a>①. 数组 saveparam</h2><ul><li>记录保存save条件的数组 saveparam，里面每个元素都是一个 saveparams 结构：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span>&#123;</span></span><br><span class="line">     <span class="comment">//秒数</span></span><br><span class="line">     <span class="type">time_t</span> seconds;</span><br><span class="line">     <span class="comment">//修改数</span></span><br><span class="line">     <span class="type">int</span> changes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>前面我们在 redis.conf 配置文件中进行了关于save 的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span>：表示<span class="number">900</span> 秒内如果至少有 <span class="number">1</span> 个 key 的值变化，则保存</span><br><span class="line">save <span class="number">300</span> <span class="number">10</span>：表示<span class="number">300</span> 秒内如果至少有 <span class="number">10</span> 个 key 的值变化，则保存</span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span>：表示<span class="number">60</span> 秒内如果至少有 <span class="number">10000</span> 个 key 的值变化，则保存</span><br></pre></td></tr></table></figure></li><li><p>那么服务器状态中的saveparam 数组将会是如下的样子：<br><img src="https://img-blog.csdnimg.cn/20210707232052810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><h2 id="②-dirty-计数器和lastsave-属性"><a href="#②-dirty-计数器和lastsave-属性" class="headerlink" title="②. dirty 计数器和lastsave 属性"></a>②. dirty 计数器和lastsave 属性</h2><ul><li><p>dirty 计数器记录距离上一次成功执行 save 命令或者 bgsave 命令之后，Redis服务器进行了多少次修改（包括写入、删除、更新等操作）。</p></li><li><p>lastsave 属性是一个时间戳，记录上一次成功执行 save 命令或者 bgsave 命令的时间。</p></li><li><p>通过这两个命令，当服务器成功执行一次修改操作，那么dirty 计数器就会加 1，而lastsave 属性记录上一次执行save或bgsave的时间，Redis 服务器还有一个周期性操作函数 severCron ,默认每隔 100 毫秒就会执行一次，该函数会遍历并检查 saveparams 数组中的所有保存条件，只要有一个条件被满足，那么就会执行 bgsave 命令。</p></li><li><p>执行完成之后，dirty 计数器更新为 0 ，lastsave 也更新为执行命令的完成时间。</p></li></ul><h1 id="六-内存快照的问题"><a href="#六-内存快照的问题" class="headerlink" title="六. 内存快照的问题"></a>六. 内存快照的问题</h1><h2 id="①-快照的时候数据可以修改吗"><a href="#①-快照的时候数据可以修改吗" class="headerlink" title="①. 快照的时候数据可以修改吗?"></a>①. 快照的时候数据可以修改吗?</h2><ul><li>比如在t时刻,我们对内存进行快照，此时我们希望的是记录下来t时刻内存中所有的数据，假设我们的RDB操作需要10s的时间，而t+2s我们执行了一个修改操作把Key1的值由A修改成了B，而此时RDB操作却还没有把Key1的值写入磁盘。在t+5s的时候读取到key1的值写入磁盘。那么此次快照记录的Key1的值就是B，而不是t时刻的A。这样就破坏了RDB文件的正确性。</li></ul><blockquote><p><font color='red' size> Redis解决方案</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210707233010402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>Redis 借助了操作系统提供的<strong>写时复制技术（Copy-On-Write</strong>, COW），可以让在执行快照的同时，正常处理写操作。</li><li>简单来说，bgsave fork子进程的时候，并不会完全复制主进程的内存数据，而是只复制必要的虚拟数据结构，并不为其分配真实的物理空间，它与父进程共享同一个物理内存空间。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。</li><li>此时，如果主线程对这些数据也都是读操作，那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据，此时会给子进程分配一块物理内存空间，把要修改的数据复制一份，生成该数据的副本到子进程的物理内存空间。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。</li></ul><h2 id="②-可以频繁进行快照操作吗"><a href="#②-可以频繁进行快照操作吗" class="headerlink" title="②. 可以频繁进行快照操作吗?"></a>②. 可以频繁进行快照操作吗?</h2><ul><li>一方面，持久化是一个写入磁盘的过程，频繁将全量数据写入磁盘，会给磁盘带来很大压力，频繁执行快照也容易导致前一个快照还没有执行完，后一个又开始了，这样多个快照竞争有限的磁盘带宽，容易造成恶性循环。</li></ul><ol><li><p>增量快照要求记住哪些数据上一次快照之后产生的。这就需要额外的元数据来记录这些信息，会引入额外的空间消耗。这对于内存资源宝贵的 Redis 来说，并不是一个很好的方案。</p></li><li><p>Redis 还提供了另外一种持久化方式——AOF(append to file)日志。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>G1垃圾回收器</title>
      <link href="/2021/08/29/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
      <url>/2021/08/29/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一-G1垃圾回收器介绍"><a href="#一-G1垃圾回收器介绍" class="headerlink" title="一. G1垃圾回收器介绍"></a>一. G1垃圾回收器介绍</h1><ul><li>Garbage First 简称 G1，是继 CMS 垃圾回收器之后，又一款并发的垃圾回收器。</li><li>在 JDK7 中被去掉 Experimental 标识，开始可以被正式使用</li><li>在 JDK9 中被 JVM 设置为默认的垃圾回收器。G1 是垃圾收集器发展史上的一个新的里程碑</li><li>它采用分区算法，基于 Region 的内存布局方式，对整个堆内存进行局部回收，既能回收新生代，也能回收老年代。</li><li>G1 垃圾回收器的目标是在期望的停顿时间内，尽可能地提高系统的吞吐量。</li></ul><h1 id="二-G1的使用"><a href="#二-G1的使用" class="headerlink" title="二. G1的使用"></a>二. G1的使用</h1><blockquote><p><font color='red' size=3;>-XX:+UseG1GC  -Xmx32g    -XX:MaxGCPauseMillis&#x3D;200</p></blockquote><ol><li>-XX:+UseG1GC为开启G1垃圾收集器</li><li>-Xmx32g 设计堆内存的最大内存为32G</li><li>-XX:MaxGCPauseMillis&#x3D;200设置GC的最大暂停时间为200ms。</li></ol><h1 id="三-G1的特点"><a href="#三-G1的特点" class="headerlink" title="三. G1的特点"></a>三. G1的特点</h1><h2 id="①-Region-分区产生"><a href="#①-Region-分区产生" class="headerlink" title="①. Region 分区产生"></a>①. Region 分区产生</h2><ul><li>G1将新生代，老年代的物理空间划分取消了，取而代之的是，G1算法将堆划分为若干个区域（Region），它仍然属于分代收集器。</li><li>虽然 G1 仍然遵循分代收集理论，但是 G1 不再坚持固定大小、固定数量的分代区域划分，而是将整个内存区域划分为若干个大小相等的独立小区域（Region），每个 Region 都能扮演 Eden、Survivor、Old 区。新生代和老年代的内存在物理上不再是连续的，而是逻辑上处于连续。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210427125826696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="③-对象分配策略"><a href="#③-对象分配策略" class="headerlink" title="③. 对象分配策略"></a>③. 对象分配策略</h2><pre><code>  1. TLAB(Thread Local Allocation Buffer)线程本地分配缓冲区  2. Eden区中分配  3. Humongous区分配</code></pre><blockquote><p><font color='red' size=3;>TLAB-(Thread Local Allocation Buffer, 线程本地分配缓存)</p></blockquote><ul><li>TLAB: TLAB是一个线程专用的内存分配区域, 虚拟机为线程分配空间, 针对于体积不大的对象, 会优先使用TLAB, 这个可以加速对象的分配, TLAB是默认开启的。</li><li>在Eden空间中，每一个线程都有一个固定的分区用于分配对象，即一个TLAB。分配对象时，线程之间不再需要进行任何的同步。</li><li>对TLAB空间中无法分配的对象，JVM会尝试在Eden空间中进行分配。如果Eden空间无法容纳该对象，就只能在老年代中进行分配空间。</li></ul><h2 id="④-Humongous巨型对象产生"><a href="#④-Humongous巨型对象产生" class="headerlink" title="④. Humongous巨型对象产生"></a>④. Humongous巨型对象产生</h2><ul><li><p>在 G1 中，新增了一个 H(Humongous) 区的概念，如果一个对象的大小超过了一个 Region 的 50%，那么该对象就会被直接存放进 H 区。如果一个 Region 无法存放下对象，那么就会采用连续的多个 Region 来存放该超大对象。</p></li><li><p>每个 Region 的大小可以通过参数 「-XX:G1HeapRegionSize」 设置，取值范围为 1MB~32MB，且为 2 的整数次幂。通常情况下，G1 会将堆内存划分为 2048 个 Region，如果我们指定堆内存的大小为 4G ，那么每个 Region 的大小为 2MB。</p></li></ul><h2 id="⑤-并发执行"><a href="#⑤-并发执行" class="headerlink" title="⑤. 并发执行"></a>⑤. 并发执行</h2><ul><li>在并发标记阶段，G1 的垃圾回收线程和用户线程，是并发执行的，那么 G1 是如何保证垃圾回收线程与用户线程互不干扰的呢？在 CMS 中，采用的是增量收集算法，而在 G1 中采用的原始快照算法（SATB）。</li></ul><h2 id="⑥-执行的流程"><a href="#⑥-执行的流程" class="headerlink" title="⑥. 执行的流程"></a>⑥. 执行的流程</h2><p><img src="https://img-blog.csdnimg.cn/20210427114847592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="1-初始标记-stop-the-word"><a href="#1-初始标记-stop-the-word" class="headerlink" title="1. 初始标记 (stop the word)"></a>1. 初始标记 (stop the word)</h3><ul><li>仅仅只是标记出 GC Roots 直接关联的对象（此时当前 Region 中的记忆集也会被当做是 GC Roots），并且还会修改 TAMS 指针，让下一阶段用户线程并发执行时，能够正确的在可用的 Region 中分配新对象。这一步会造成 STW，但是由于只标记和 GC Roots 直接相连的对象，所以暂停时间很短，具体暂停多长时间，和 GC Roots 的数量有关。另外由于该阶段是借用进行 Minor GC 时同步完成的，因此不会额外造成停顿。</li></ul><h3 id="2-并发标记"><a href="#2-并发标记" class="headerlink" title="2. 并发标记"></a>2. 并发标记</h3><ul><li>从上一步标记出的对象出发，遍历整个对象图，这一步耗时较长，但是由于是和用户线程并发执行，因此不会造成 STW。</li></ul><h3 id="3-最终标记-stop-the-word"><a href="#3-最终标记-stop-the-word" class="headerlink" title="3. 最终标记 (stop the word)"></a>3. 最终标记 (stop the word)</h3><ul><li>由于在并发标记阶段，垃圾回收线程和用户线程并发执行，因此在这一过程中，可能会由于用户线程改变了对象的引用关系，造成对象”消失“，因此还需要重新处理 SATB（原始快照）记录下在并发阶段有引用关系改动的对象，这一过程就是在最终标记阶段完成的，会造成 STW，否则如果用户线程还一直进行，就会不停地造成对象引用关系的改变，我们就得不停的处理 SATB 记录。虽然会造成 STW，但毕竟 SATB 记录的引用改变的对象不会特别多，因此耗时比并发标记阶段的耗时会少很多。在这一步中，如果发现当前 Region 中的所有对象都是垃圾对象，那么就会立即对当前 Region 进行回收</li></ul><h3 id="4-筛选回收-stop-the-word"><a href="#4-筛选回收-stop-the-word" class="headerlink" title="4. 筛选回收 (stop the word)"></a>4. 筛选回收 (stop the word)</h3><ul><li>负责更新 Region 的统计数据，根据每个 Region 的回收价值和成本进行排序，然后根据用户期望停顿的时间内来指定回收计划，可以选择多个 Region 构成回收集，然后采用复制算法，将 Region 中存活的对象复制到空闲的 Region 中，从而回收 Region。</li></ul><blockquote><p><font color='red' size=3;>G1 垃圾回收的 4 个阶段，只有并发标记阶段不会造成 STW，其他阶段都会产生 STW</p></blockquote><h1 id="四-三色标记算法"><a href="#四-三色标记算法" class="headerlink" title="四. 三色标记算法"></a>四. 三色标记算法</h1><ul><li>它是描述追踪式回收器的一种有用的方法，利用它可以推演回收器的正确性</li></ul><h2 id="①-对象分成三种类型"><a href="#①-对象分成三种类型" class="headerlink" title="①. 对象分成三种类型"></a>①. 对象分成三种类型</h2><ul><li>黑色: 根对象，或者该对象与它的子对象都被扫描</li><li>灰色: 对象本身被扫描,但还没扫描完该对象中的子对象</li><li>白色: 未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象</li></ul><h2 id="②-执行的流程"><a href="#②-执行的流程" class="headerlink" title="②. 执行的流程"></a>②. 执行的流程</h2><blockquote><p><font color='red' size=3;>1. 根对象被置为黑色，子对象被置为灰色。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/2021042712102050.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=3;>2. 继续由灰色遍历,将已扫描了子对象的对象置为黑色。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210427121105952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=3;>3. 遍历了所有可达的对象后，所有可达的对象都变成了黑色。不可达的对象即为白色，需要被清理。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210427121146481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="③-对象丢失问题解决方式"><a href="#③-对象丢失问题解决方式" class="headerlink" title="③. 对象丢失问题解决方式"></a>③. 对象丢失问题解决方式</h2><p><img src="https://img-blog.csdnimg.cn/20210427125501706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210427125519793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=3;>对象消失理论，只有同时满足才会发生对象消失</p></blockquote><ol><li>赋值器插入了一条或多条从黑色对象到白色对象的新引用；</li><li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用；</li></ol><blockquote><p><font color='red' size=3;>CMS——增量更新(Incremental Update)</p></blockquote><ul><li>采用IncrementalUpdate（增量更新）算法，在并发标记阶段时如果一个白色对象被一个黑色对象引用时，会将黑色对象重新标记为灰色，让垃圾收集器在重新标记阶段重新扫描。</li></ul><blockquote><p><font color='red' size=3;>G1——起始快照算法_STAB（snapshot-at-the-beginning）</p></blockquote><ul><li>原始快照要破坏的是第二个条件，采用SATB(snapshot-at-the-beginning)，在初始标记时做一个快照，当B和C之间的引用消失时要把这个引用推到GC的堆栈，保证C还能被GC扫描到，在最终标记阶段扫描STAB记录。</li></ul><h1 id="五-新生代-YGC"><a href="#五-新生代-YGC" class="headerlink" title="五. 新生代 YGC"></a>五. 新生代 YGC</h1><blockquote><p><font color='red' size=3;> 什么时候触发新生代 GC</p></blockquote><ul><li><p>Young GC主要是对Eden区进行GC，它在Eden空间耗尽时会被触发。在这种情况下，Eden空间的数据移动到Survivor空间中，如果Survivor空间不够，Eden空间的部分数据会直接晋升到年老代空间。Survivor区的数据移动到新的Survivor区中，也有部分数据晋升到老年代空间中。最终Eden空间的数据为空，GC停止工作，应用线程继续执行。</p></li><li><p>在 G1 中，Eden、Survivor、老年代的大小是在动态变化的。在初始时，新生代占整个堆内存的 5%，可以通过参数「G1NewSizePercent」设置，默认值为 5。</p></li><li><p>在 G1 中，虽然进行了 Region 分区，但是新生代依旧可以被分为 Eden 区和 Survivor 区，参数 SurvivorRatio 依旧表示 Eden&#x2F;Survivor 的比值。</p></li><li><p>随着系统的运行，Eden 区的对象越来越多，当达到 Eden 区的最大大小时，就会触发 Minor GC。新生代的最大大小默认为整个堆内存的 60%，可以通过参数「G1MaxNewSizePercent」控制，默认值为 60。</p></li></ul><blockquote><p><font color='red' size=3;> Young GC的回收过程如下：</p></blockquote><ol><li><p>根扫描,跟CMS类似，Stop the world，扫描GC Roots对象。</p></li><li><p>处理Dirty card,更新RSet.</p></li><li><p>扫描RSet,扫描RSet中所有old区对扫描到的young区或者survivor去的引用。</p></li><li><p>拷贝扫描出的存活的对象到survivor2&#x2F;old区</p></li><li><p>处理引用队列，软引用，弱引用，虚引用</p></li></ol><h1 id="六-混合回收（Mixed-GC）"><a href="#六-混合回收（Mixed-GC）" class="headerlink" title="六. 混合回收（Mixed GC）"></a>六. 混合回收（Mixed GC）</h1><blockquote><p><font color='red' size=3;> 什么时候触发混合 GC</p></blockquote><ul><li><p>在 G1 中，不存在单独回收老年代的行为，而是当要发生老年代的回收时，同时也会对新生代以及大对象进行回收，因此这个阶段称之为混合回收（Mixed GC）。</p></li><li><p>当老年代对堆内存的占比达到 45%时，就会触发混合回收。可以通过参数「InitiatingHeapOccupancyPercent」来设置当堆内存达到多少时，触发混合 GC，该参数的默认值为 45。</p></li><li><p>当触发混合 GC 时，会依次执行初始标记（在 Minor GC 时完成）、并发标记、最终标记、筛选回收这四个过程。最终会根据设置的最大停顿时间，来计算对哪些 Region 区域进行回收带来的收益最大。</p></li><li><p>在混合回收的过程中，由于使用的是复制算法，因此当一个 Region 中存活的对象过多的话，复制这个 Region 所耗费的时间就会较多，因此 G1 提供了一个参数，用来控制当存活对象占当前 Region 的比例超过多少后，就不会对该 Region 进行回收。该参数为「G1MixedGCLiveThresholdPercent」，默认值为 85%。</p></li></ul><h1 id="七-触发-Full-GC"><a href="#七-触发-Full-GC" class="headerlink" title="七.  触发 Full GC"></a>七.  触发 Full GC</h1><ul><li>在进行混合回收时，使用的是复制算法，如果当发现空闲的 Region 大小无法放得下存活对象的内存大小，那么这个时候使用复制算法就会失败，因此此时系统就不得不暂停应用程序，进行一次 Full GC。进行 Full GC 时采用的是单线程进行标记、清理和整理内存，这个过程是非常漫长的，因此应该尽量避免 Full GC 的触发。</li></ul><h1 id="八-G1的优缺点"><a href="#八-G1的优缺点" class="headerlink" title="八. G1的优缺点"></a>八. G1的优缺点</h1><blockquote><p><font color='red' size=3;>优点</p></blockquote><ul><li>G1 中可以指定最大停顿时间、对内存进行 Region 分区、按照收益动态进行垃圾回收。</li><li>使用分区算法, 不要求eden, 年轻代或老年代的空间都连续 </li><li>空间整理: 回收过程中, 会进行适当对象移动, 减少空间碎片 。</li><li>可预见性: G1可选取部分区域进行回收, 可以缩小回收范围, 减少全局停顿 </li><li>并行性: 回收期间, 可由多个线程同时工作, 有效利用多核cpu资源 </li><li>并发性: 与应用程序可交替执行, 部分工作可以和应用程序同时执行</li><li>CMS 则是采用的是标记-清除算法，会带来内存碎片，当连续内存不足以分配一个对象时，会产生 Full GC。</li></ul><blockquote><p><font color='red' size=3;>缺点</p></blockquote><ul><li>G1 的内存占用相对而言，比较大。</li><li>G1 对系统造成的负载较高</li></ul><blockquote><p><font color='red' size=3;>G1 并不能在任何场景下取代 CMS，「G1 更适合在大内存的机器中使用，CMS 更适合在小内存机器中使用</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMS垃圾回收器</title>
      <link href="/2021/08/19/CMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
      <url>/2021/08/19/CMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一-CMS介绍"><a href="#一-CMS介绍" class="headerlink" title="一. CMS介绍"></a>一. CMS介绍</h1><ol><li>JDK9 中，CMS 被标记为「Deprecated」，开始逐渐的淡出人们的视野，在目前最新的 JDK14 中，CMS 则是完全被移除了，成为了第一款被彻底遗弃的垃圾回收器。</li><li>CMS(Concurrent Mark-Sweep)是以牺牲吞吐量为代价来获得<strong>最短回收停顿时间</strong>的垃圾回收器。</li><li>在启动JVM参数加上-XX:+UseConcMarkSweepGC ，这个参数表示对于<strong>老年代</strong>的回收采用CMS。</li><li>CMS采用的基础算法是：标记—清除。</li></ol><h1 id="二-实现机制"><a href="#二-实现机制" class="headerlink" title="二. 实现机制"></a>二. 实现机制</h1><ul><li>根据GC的触发机制分为：周期性Old GC（被动）和主动Old GC</li></ul><h1 id="三-周期性Old-GC-CMS执行过程"><a href="#三-周期性Old-GC-CMS执行过程" class="headerlink" title="三. 周期性Old GC_CMS执行过程"></a>三. 周期性Old GC_CMS执行过程</h1><ul><li>周期性Old GC，执行的逻辑也叫Background Collect，对老年代进行回收，在GC日志中比较常见，由后台线程ConcurrentMarkSweepThread循环判断（默认2s）是否需要触发。</li></ul><blockquote><p><font color='red' size=3> 触发的条件</p></blockquote><ol><li>如果没有设置-XX:+UseCMSInitiatingOccupancyOnly，虚拟机会根据收集的数据决定是否触发。</li><li>老年代使用率达到阈值 CMSInitiatingOccupancyFraction，默认92%。</li><li>永久代的使用率达到阈值 CMSInitiatingPermOccupancyFraction，默认92%，前提是开启 CMSClassUnloadingEnabled。</li><li>新生代的晋升担保失败。老年代是否有足够的空间来容纳全部的新生代对象或历史平均晋升到老年代的对象，如果不够的话，就提早进行一次老年代的回收，防止下次进行YGC(对新生代堆进行gc)的时候发生晋升失败。</li></ol><p><img src="https://img-blog.csdnimg.cn/64aa740652d54acd9af3b424eacc82e9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pCs56CW5pCs56CW5pCs56CW5pCs56CW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=3>CMS执行的六个过程</p><p><img src="https://img-blog.csdnimg.cn/20210426171736480.png" alt="在这里插入图片描述"></p></blockquote><pre><code>  1.  初始标记(STW initial mark)   2.  并发标记(Concurrent marking)   3.  并发预清理(Concurrent precleaning)   4.  重新标记(STW remark)   5.  并发清理(Concurrent sweeping)   6.  并发重置(Concurrent reset)</code></pre><h2 id="①-初始标记"><a href="#①-初始标记" class="headerlink" title="①.初始标记"></a><font color='red' size=4>①.初始标记</h2><ul><li>在这个阶段，需要虚拟机停顿正在执行的任务，官方的叫法STW(Stop The Word)。</li><li>该阶段进行可达性分析，标记GC ROOT能直接关联到的对象，只扫描到能够和”根对象”直接关联的对象，并作标记。</li><li>这个过程虽然暂停了整个JVM，但是很快就完成了。</li></ul><h2 id="②-并发标记"><a href="#②-并发标记" class="headerlink" title="②.并发标记"></a><font color='red' size=4>②.并发标记</h2><ul><li>这个阶段紧随初始标记阶段，在初始标记的基础上继续向下追溯标记。</li><li>并发标记阶段，应用程序的线程和并发标记的线程并发执行，所以用户不会感受到停顿。</li><li>该阶段进行GC ROOT TRACING，在第一个阶段被暂停的线程重新开始运行。</li><li>并发标记阶段是和用户线程并发执行的过程。</li></ul><h2 id="③-并发预清理"><a href="#③-并发预清理" class="headerlink" title="③.并发预清理"></a><font color='red' size=4>③.并发预清理</h2><ul><li>在这个阶段，虚拟机查找在执行并发标记阶段新进入老年代的对象(可能会有一些对象从新生代晋升到老年代， 或者有一些对象被分配到老年代)。</li><li>通过重新扫描，减少下一个阶段”重新标记”的工作，因此重标记的工作尽可能多的在并发阶段完成来减少STW的时间。</li></ul><h2 id="④-重新标记"><a href="#④-重新标记" class="headerlink" title="④.重新标记"></a><font color='red' size=4>④.重新标记</h2><ul><li>这个阶段会暂停虚拟机，收集器线程扫描在CMS堆中剩余的对象。扫描从”跟对象”开始向下追溯，并处理对象关联。</li></ul><h2 id="⑤-并发清理"><a href="#⑤-并发清理" class="headerlink" title="⑤.并发清理"></a><font color='red' size=4>⑤.并发清理</h2><ul><li>清理垃圾对象，这个阶段收集器线程和应用程序线程并发执行。</li><li>用户线程被重新激活，同时清理那些无效的对象。</li></ul><h2 id="⑥-并发重置"><a href="#⑥-并发重置" class="headerlink" title="⑥.并发重置"></a><font color='red' size=4>⑥.并发重置</h2><ul><li>这个阶段，重置CMS收集器的数据结构，CMS清除内部状态，等待下一次垃圾回收。</li></ul><h1 id="三-CMS缺点"><a href="#三-CMS缺点" class="headerlink" title="三. CMS缺点"></a>三. CMS缺点</h1><ol><li><p>CMS不会整理、压缩堆空间。经过CMS收集的堆会产生空间碎片。 </p></li><li><p>CMS回收器减少了回收的停顿时间，但是降低了堆空间的利用率。</p></li><li><p>GC线程与用户线程抢占CPU。这可能会造成用户线程执行效率下降， 需要更多的CPU资源。</p></li></ol><p><img src="https://img-blog.csdnimg.cn/88cbd60b4f4d4f2291024a1c8b6ec058.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pCs56CW5pCs56CW5pCs56CW5pCs56CW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1 id="四-使用的场景"><a href="#四-使用的场景" class="headerlink" title="四. 使用的场景"></a>四. 使用的场景</h1><ul><li><strong>GC过程短暂停，适合对时延要求较高的服务，用户线程不允许长时间的停顿。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-Explain分析执行计划</title>
      <link href="/2021/08/16/MySQL-Explain%E5%88%86%E6%9E%90%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
      <url>/2021/08/16/MySQL-Explain%E5%88%86%E6%9E%90%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="一-查看SQL执行频率"><a href="#一-查看SQL执行频率" class="headerlink" title="一. 查看SQL执行频率"></a>一. 查看SQL执行频率</h1><ul><li>MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。show [session|global] status 可以根据需要加上参数“session”或者“global”来显示 session 级（当前连接）的计结果和 global 级（自数据库上次启动至今）的统计结果。如果不写，默认使用参数是“session”。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">GLOBAL</span> status <span class="keyword">like</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Innodb_rows_%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> goods_innodb;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/071daa487f3945357ac1d5e010a2f4c9.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/217eab2e42b01b36da5ff2db9db8bf57.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/eadf72196137ed0fde36dae1f243f25c.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/45806c4362bb1a261b19169b80c9c733.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/3b0d5cc5d9b566450e559b3f7b46b9fd.png" alt="在这里插入图片描述"></p><ul><li><p>Com_***      :  这些参数对于所有存储引擎的表操作都会进行累计。</p></li><li><p>Innodb_*** :  这几个参数只是针对InnoDB 存储引擎的，累加的算法也略有不同。</p></li></ul><h1 id="二-定位低效率执行SQL"><a href="#二-定位低效率执行SQL" class="headerlink" title="二. 定位低效率执行SQL"></a>二. 定位低效率执行SQL</h1><h2 id="①-慢查询日志"><a href="#①-慢查询日志" class="headerlink" title="①. 慢查询日志"></a>①. 慢查询日志</h2><ul><li>慢查询日志 : 通过慢查询日志定位那些执行效率较低的 SQL 语句，用–log-slow-queries[&#x3D;file_name]选项启动时，mysqld 写一个包含所有执行时间超过 long_query_time 秒的 SQL 语句的日志文件。</li></ul><h2 id="②-show-processlist"><a href="#②-show-processlist" class="headerlink" title="②.  show processlist"></a>②.  show processlist</h2><ul><li>show processlist  : 慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用show processlist命令查看当前MySQL在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/e6ce8126b1f0c87d6809d766cfc0caa2.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/42bde32e55180deb5842172e9eea79c9.png" alt="在这里插入图片描述"></p><h1 id="三-explain分析执行计划"><a href="#三-explain分析执行计划" class="headerlink" title="三.  explain分析执行计划"></a>三.  explain分析执行计划</h1><ul><li>通过以上步骤查询到效率低的 SQL 语句后，可以通过 EXPLAIN或者 DESC命令获取 MySQL如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</li></ul><h2 id="①-创建万级数据"><a href="#①-创建万级数据" class="headerlink" title="①. 创建万级数据"></a>①. 创建万级数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `user_test`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `user_test` (</span><br><span class="line">id <span class="type">BIGINT</span>(<span class="number">20</span>) UNSIGNED  <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键id&#x27;</span>,</span><br><span class="line">`user_name`  <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>  COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">`pass_word`  <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>  COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> COMMENT<span class="operator">=</span> <span class="string">&#x27;用户信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_test (user_name, pass_word) </span><br><span class="line"><span class="keyword">SELECT</span> MD5(RAND()),RAND(<span class="number">10000</span>) <span class="keyword">FROM</span> user_test;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/70c9c2e847e31c53003d7c11618fac53.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/26e1492ec811ac70ac72d567459bb42e.png" alt="在这里插入图片描述"></p><h2 id="②-查询SQL语句的执行计划"><a href="#②-查询SQL语句的执行计划" class="headerlink" title="②. 查询SQL语句的执行计划"></a>②. 查询SQL语句的执行计划</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/0ccd9e3565c488092c91ccd631d143da.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/7e3ad1f4359ddaff80dc211177dda4aa.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/82322ea509cfc75d0aad6940abb322af.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> explain 分析每个字段</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/39a1f9c65dd52bbb6b047b24a84f2bc0.png" alt="在这里插入图片描述"></p><h2 id="③-explain-分析每个字段环境准备"><a href="#③-explain-分析每个字段环境准备" class="headerlink" title="③.  explain 分析每个字段环境准备"></a>③.  explain 分析每个字段环境准备</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/e32b11fb62bd05f3d47f10277f7ab28b.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/c2dfbf450e9b3a910c42254456081b0d.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_role` (</span><br><span class="line">  `id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `role_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `role_code` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `description` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `unique_role_name` (`role_name`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_user` (</span><br><span class="line">  `id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">96</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `unique_user_username` (`username`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `user_role` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> auto_increment ,</span><br><span class="line">  `user_id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `role_id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `fk_ur_user_id` (`user_id`),</span><br><span class="line">  KEY `fk_ur_role_id` (`role_id`),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `fk_ur_role_id` <span class="keyword">FOREIGN</span> KEY (`role_id`) <span class="keyword">REFERENCES</span> `t_role` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> ACTION <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">NO</span> ACTION,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `fk_ur_user_id` <span class="keyword">FOREIGN</span> KEY (`user_id`) <span class="keyword">REFERENCES</span> `t_user` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> ACTION <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">NO</span> ACTION</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;super&#x27;</span>,<span class="string">&#x27;$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#x27;</span>,<span class="string">&#x27;超级管理员&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#x27;</span>,<span class="string">&#x27;系统管理员&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;itcast&#x27;</span>,<span class="string">&#x27;$2a$10$8qmaHgUFUAmPR5pOuWhYWOr291WJYjHelUlYn07k5ELF8ZCrW0Cui&#x27;</span>,<span class="string">&#x27;test02&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;stu1&#x27;</span>,<span class="string">&#x27;$2a$10$pLtt2KDAFpwTWLjNsmTEi.oU1yOZyIn9XkziK/y/spH5rftCpUMZa&#x27;</span>,<span class="string">&#x27;学生1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;stu2&#x27;</span>,<span class="string">&#x27;$2a$10$nxPKkYSez7uz2YQYUnwhR.z57km3yqKn3Hr/p1FR6ZKgc18u.Tvqm&#x27;</span>,<span class="string">&#x27;学生2&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;t1&#x27;</span>,<span class="string">&#x27;$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#x27;</span>,<span class="string">&#x27;老师1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="keyword">VALUES</span>(<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;学生&#x27;</span>,<span class="string">&#x27;student&#x27;</span>,<span class="string">&#x27;学生&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="keyword">VALUES</span>(<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;老师&#x27;</span>,<span class="string">&#x27;teacher&#x27;</span>,<span class="string">&#x27;老师&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="keyword">VALUES</span>(<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;教学管理员&#x27;</span>,<span class="string">&#x27;teachmanager&#x27;</span>,<span class="string">&#x27;教学管理员&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="keyword">VALUES</span>(<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;管理员&#x27;</span>,<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;管理员&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="keyword">VALUES</span>(<span class="string">&#x27;10&#x27;</span>,<span class="string">&#x27;超级管理员&#x27;</span>,<span class="string">&#x27;super&#x27;</span>,<span class="string">&#x27;超级管理员&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_role(id,user_id,role_id) <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;5&#x27;</span>),(<span class="keyword">NULL</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;7&#x27;</span>),(<span class="keyword">NULL</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;8&#x27;</span>),(<span class="keyword">NULL</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;9&#x27;</span>),(<span class="keyword">NULL</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;8&#x27;</span>),(<span class="keyword">NULL</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;10&#x27;</span>) ;</span><br></pre></td></tr></table></figure><h2 id="④-explain-之-id"><a href="#④-explain-之-id" class="headerlink" title="④. explain 之 id"></a>④. explain 之 id</h2><ul><li>id 字段是 select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。</li></ul><h3 id="1-id-相同表示加载表的顺序是从上到下"><a href="#1-id-相同表示加载表的顺序是从上到下" class="headerlink" title="1. id 相同表示加载表的顺序是从上到下"></a>1. id 相同表示加载表的顺序是从上到下</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_role r, t_user u, user_role ur <span class="keyword">where</span> r.id <span class="operator">=</span> ur.role_id <span class="keyword">and</span> u.id <span class="operator">=</span> ur.user_id ;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/f1b805a37f6517de4dbff25db6aa995a.png" alt="在这里插入图片描述"></p><h3 id="2-id-不同id值越大，优先级越高，越先被执行"><a href="#2-id-不同id值越大，优先级越高，越先被执行" class="headerlink" title="2.  id 不同id值越大，优先级越高，越先被执行"></a>2.  id 不同id值越大，优先级越高，越先被执行</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_role <span class="keyword">WHERE</span> id <span class="operator">=</span> (<span class="keyword">SELECT</span> role_id <span class="keyword">FROM</span> user_role <span class="keyword">WHERE</span> user_id <span class="operator">=</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;stu1&#x27;</span>))</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/1fc8808869fbbadba7d388a2c72881fc.png" alt="在这里插入图片描述"></p><h3 id="3-id-有相同，也有不同，同时存在"><a href="#3-id-有相同，也有不同，同时存在" class="headerlink" title="3.  id 有相同，也有不同，同时存在"></a>3.  id 有相同，也有不同，同时存在</h3><ul><li>id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_role r , (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_role ur <span class="keyword">WHERE</span> ur.`user_id` <span class="operator">=</span> <span class="string">&#x27;2&#x27;</span>) a <span class="keyword">WHERE</span> r.id <span class="operator">=</span> a.role_id ; </span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/ce0e0a6d9abff26ce22ef0b97dbdffa7.png" alt="在这里插入图片描述"></p><h2 id="⑤-explain-之-select-type"><a href="#⑤-explain-之-select-type" class="headerlink" title="⑤. explain 之 select_type"></a>⑤. explain 之 select_type</h2><ul><li>表示 SELECT 的类型，常见的取值，如下表所示：<br>  <img src="https://img-blog.csdnimg.cn/img_convert/1bf113004997595cf343061c3bba371d.png" alt="在这里插入图片描述"><blockquote><p><font color='red' size=4> SIMPLE</p></blockquote></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/ab0d7732a3b6fcfbc49ee2a490dacdac.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> PRIMARY和SUBQUEY</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> user_ role <span class="keyword">where</span> role_ id <span class="operator">=</span> <span class="string">&#x27;9&#x27;</span>) ;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/0e06f5d8e2d0d1a2e77b4c3ddaf89e13.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> PRIMARY和DERIVED</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/c13fbc069d5d45a376dfc6206628a5a7.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27;2&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=4> UNION和UNION RESULT<br><img src="https://img-blog.csdnimg.cn/img_convert/800bdb1e162297fbaa1d871781ce4127.png" alt="在这里插入图片描述"></p></blockquote><h2 id="⑥-explain-之-table"><a href="#⑥-explain-之-table" class="headerlink" title="⑥. explain 之 table"></a>⑥. explain 之 table</h2><ul><li>展示这一行的数据是关于哪一张表的</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/7a445a2b7e5c56f103ad10cf96bfbb97.png" alt="在这里插入图片描述"></p><h2 id="⑦-explain-之-type"><a href="#⑦-explain-之-type" class="headerlink" title="⑦. explain 之 type"></a>⑦. explain 之 type</h2><ul><li>type 显示的是访问类型，是较为重要的一个指标，可取值为：</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/874a275d07dd14434a6385b47ac5a9a0.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4>  system</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/27282289e7281bd75305814f16930f32.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> const</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 根据索引</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user  <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;admin&#x27;</span>;</span><br><span class="line"># 根据主键</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user  <span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/b9563f6f33dfb1f0038eb97f8fa04764.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4>  eq_ref<br><img src="https://img-blog.csdnimg.cn/img_convert/bcb3043ecccb731178858fe55ac30954.png" alt="在这里插入图片描述"></p></blockquote><blockquote><p><font color='red' size=4>  ref</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/6a56661dc3b240313f716b179a4e6404.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/c2ccedd57b53f6bb866b49594c9f0d02.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> ALL</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/af0871981a51a106ead62a9b7fdc651f.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> 结果值从最好到最坏以此是：</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/ec1b81adc90acf6dfcbf2e44401b63bb.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">NULL</span> <span class="operator">&gt;</span> <span class="keyword">system</span> <span class="operator">&gt;</span> const <span class="operator">&gt;</span> eq_ref <span class="operator">&gt;</span> <span class="keyword">ref</span> <span class="operator">&gt;</span> fulltext <span class="operator">&gt;</span> ref_or_null </span><br><span class="line"><span class="operator">&gt;</span> index_merge <span class="operator">&gt;</span> unique_subquery <span class="operator">&gt;</span> index_subquery <span class="operator">&gt;</span> <span class="keyword">range</span> <span class="operator">&gt;</span> index <span class="operator">&gt;</span> <span class="keyword">ALL</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">system</span> <span class="operator">&gt;</span> const <span class="operator">&gt;</span> eq_ref <span class="operator">&gt;</span> <span class="keyword">ref</span> <span class="operator">&gt;</span> <span class="keyword">range</span> <span class="operator">&gt;</span> index <span class="operator">&gt;</span> <span class="keyword">ALL</span></span><br></pre></td></tr></table></figure><ul><li>一般来说， 我们需要保证查询至少达到 range 级别， 最好达到ref 。</li></ul><h2 id="⑧-explain-之-key"><a href="#⑧-explain-之-key" class="headerlink" title="⑧.   explain 之  key"></a>⑧.   explain 之  key</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/ba0b31616f9e6d277b663f94da52e914.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/7c55f41ad2b09fbb335c0c06bdf4cd02.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">possible_keys : 显示可能应用在这张表的索引， 一个或多个。 </span><br><span class="line"></span><br><span class="line">key ： 实际使用的索引， 如果为<span class="keyword">NULL</span>， 则没有使用索引。</span><br><span class="line"></span><br><span class="line">key_len : 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。</span><br></pre></td></tr></table></figure><h2 id="⑨-explain-之-rows"><a href="#⑨-explain-之-rows" class="headerlink" title="⑨. explain 之 rows"></a>⑨. explain 之 rows</h2><ul><li>扫描行的数量。<br><img src="https://img-blog.csdnimg.cn/img_convert/e4e7564fad99d162aace2cb5c5291c7e.png" alt="在这里插入图片描述"></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/b7c69e16a57285f1df689eb0a41e0879.png" alt="在这里插入图片描述"></p><h2 id="⑩-explain-之-extra"><a href="#⑩-explain-之-extra" class="headerlink" title="⑩.  explain 之 extra"></a>⑩.  explain 之 extra</h2><ul><li>其他的额外的执行计划信息，在该列展示 。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/3731b7cfb17c4eaeb9a0c828bb295e46.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4>  Using filesort</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/75d34d81e98ccd6263b47f202b6f7872.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/89647f837acc3e1c603b92569134eb8c.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4>  Using index</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/f2cfb097a230b1c3fe25065dea2fab36.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/22f0db8a9fd68e9be5fe1717fd68145e.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4>  Using temporary ，Using filesort</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/40f3ee95fc6110a1ee1418c6bbdc9796.png" alt="在这里插入图片描述"></p><h1 id="四-show-profile分析SQL"><a href="#四-show-profile分析SQL" class="headerlink" title="四. show profile分析SQL"></a>四. show profile分析SQL</h1><ul><li>Mysql从5.0.37版本开始增加了对 show profiles 和 show profile 语句的支持。show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。</li><li>通过 have_profiling 参数，能够看到当前MySQL是否支持profile：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@have</span>_profiling</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/9220cd3b3fa5923e43a961869d7bb03f.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@profiling</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/7e3e3a8bd2216561f9f8eb967890094c.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling<span class="operator">=</span><span class="number">1</span>; <span class="operator">/</span><span class="operator">/</span>开启profiling 开关；</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/6bad39bb906dff5e1e6f2b75dcb2d6b3.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> 通过profile，我们能够更清楚地了解SQL执行的过程。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/0a5e34532c4105114b135241e1cb7ca2.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/04e11660618259b5120d662c8ca8a976.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> 通过show profile for query query_id 语句可以查看到该SQL执行过程中每个线程的状态和消耗的时间</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> profile <span class="keyword">all</span> <span class="keyword">for</span> query <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/839d3cf89f2ff3a8c00fe02456bd4a68.png" alt="在这里插入图片描述"></p><ul><li>在获取到最消耗时间的线程状态后，MySQL支持进一步选择all、cpu、block io 、context switch、page faults等明细类型类查看MySQL在使用什么资源上耗费了过高的时间。例如，选择查看CPU的耗费时间  ：</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/3eea00868cbaf7680681fe4aabcb1e8d.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/417139788a3eba8a73124a781737c196.png" alt="在这里插入图片描述"></p><h1 id="五-trace分析优化器执行计划"><a href="#五-trace分析优化器执行计划" class="headerlink" title="五. trace分析优化器执行计划"></a>五. trace分析优化器执行计划</h1><ul><li><p>MySQL5.6提供了对SQL的跟踪trace, 通过trace文件能够进一步了解为什么优化器选择A计划, 而不是选择B计划。</p></li><li><p>打开trace ， 设置格式为 JSON，并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span>&quot;enabled=on&quot;,end_markers_in_json<span class="operator">=</span><span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">set</span> optimizer_trace_max_mem_size<span class="operator">=</span><span class="number">1000000</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/8a6cf5bcaf7db08e21b06d66d69e4f5e.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> 执行SQL语句</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_test <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/bbb361d0a785bc10711d3767ae892b10.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4>  检查information_schema.optimizer_trace就可以知道MySQL是如何执行SQL的 </p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/062c0f678940e35e5d577e45f9fc3254.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal源码分析</title>
      <link href="/2021/08/12/ThreadLocal/"/>
      <url>/2021/08/12/ThreadLocal/</url>
      
        <content type="html"><![CDATA[<h1 id="一-ThreadLocal源码分析"><a href="#一-ThreadLocal源码分析" class="headerlink" title="一. ThreadLocal源码分析"></a>一. ThreadLocal源码分析</h1><p><img src="https://img-blog.csdnimg.cn/762e9cc66f6447999c97d423e7afba18.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pCs56CW5pCs56CW5pCs56CW5pCs56CW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="①-核心属性"><a href="#①-核心属性" class="headerlink" title="①. 核心属性"></a>①. 核心属性</h2><p><img src="https://img-blog.csdnimg.cn/20210429162248291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义了一个AtomicInteger类型,每次获取当前值并加上HASH_INCREMENT</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadLocalHashCode</span> <span class="operator">=</span> nextHashCode();</span><br><span class="line"><span class="comment">//获取下一个hashCode值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">nextHashCode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"><span class="comment">//Hash值增长值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_INCREMENT</span> <span class="operator">=</span> <span class="number">0x61c88647</span>;</span><br></pre></td></tr></table></figure><h2 id="②-get-方法"><a href="#②-get-方法" class="headerlink" title="②. get()方法"></a>②. get()方法</h2><p><img src="https://img-blog.csdnimg.cn/20210429162540338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前线程本地变量的值</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取当前线程的map</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">//判断当前线程的map是否存在，不为空</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果存在，就获取当前对象的Entry键值对</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//判断这个键值对是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果不是空，就返回对应的value值</span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此处是当前线程的map不存在，返回setInitialValue，进程初始化</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=3>执行流程get()方法</p></blockquote><ol><li><p>首先获取当前线程</p></li><li><p>根据当前线程获取一个Map</p></li><li><p>如果获取的Map不为空，则在Map中以ThreadLocal的引用作为key来在Map中获取对应的value e，否则转到E</p></li><li><p>如果e不为null，则返回e.value，否则转到E</p></li><li><p>Map为空或者e为空，则通过initialValue函数获取初始值value，然后用ThreadLocal的引用和value作为firstKey和firstValue创建一个新的Map</p></li></ol><h2 id="③-setInitialValue"><a href="#③-setInitialValue" class="headerlink" title="③. setInitialValue()"></a>③. setInitialValue()</h2><p><img src="https://img-blog.csdnimg.cn/20210429163921402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set的变样实现，用于初始化值initialValue</span></span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//调用initialValue方法，此方法是初始化ThreadLocal的方法，</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">    <span class="comment">//获取当前线程对象</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">//如果此map存在</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 存在则调用map.set设置此实体entry</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 1）当前线程Thread 不存在ThreadLocalMap对象</span></span><br><span class="line">        <span class="comment">// 2）则调用createMap进行ThreadLocalMap对象的初始化</span></span><br><span class="line">        <span class="comment">// 3）并将此实体entry作为第一个值存放至ThreadLocalMap中</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="comment">// 返回设置的值value</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="④-createMap-和getMap-方法"><a href="#④-createMap-和getMap-方法" class="headerlink" title="④. createMap() 和getMap()方法"></a>④. createMap() 和getMap()方法</h2><blockquote><p><font color='red' size=4>createMap 创建当前线程Thread对应维护的ThreadLocalMap</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210429165651190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建当前线程Thread对应维护的ThreadLocalMap</span></span><br><span class="line"><span class="comment">//firstValue 存放到map中第一个entry的值</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    <span class="comment">//这里的this是调用此方法的threadLocal</span></span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=4>getMap(Thread t) 获取当前线程的map</p></blockquote><p><img src="https://img-blog.csdnimg.cn/2021042916275481.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> t.threadLocals;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=4>Thread类中的属性 threadLocals </p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210429162821514.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个Thread线程内部都有一个Map (ThreadLocalMap)</span></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h2 id="⑤-set-方法"><a href="#⑤-set-方法" class="headerlink" title="⑤. set()方法"></a>⑤. set()方法</h2><p><img src="https://img-blog.csdnimg.cn/20210429165319855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//在ThreadLocal 中，以t来获取当前线程的一个ThreadLocalMap</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">//如果ThreadLocal中有这个map，就把当前类和对应的值传进去</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 存在则调用map.set设置此实体entry</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 1）当前线程Thread 不存在ThreadLocalMap对象</span></span><br><span class="line">        <span class="comment">// 2）则调用createMap进行ThreadLocalMap对象的初始化</span></span><br><span class="line">        <span class="comment">// 3）并将此实体entry作为第一个值存放至ThreadLocalMap中</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=3>执行流程get()方法</p></blockquote><ol><li><p>首先获取当前线程，并根据当前线程获取一个Map</p></li><li><p>如果获取的Map不为空，则将参数设置到Map中（当前ThreadLocal的引用作为key）</p></li><li><p>如果Map为空，则给该线程创建 Map，并设置初始值</p></li></ol><h2 id="⑥-remove-方法"><a href="#⑥-remove-方法" class="headerlink" title="⑥. remove() 方法"></a>⑥. remove() 方法</h2><p><img src="https://img-blog.csdnimg.cn/20210429165521816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除当前线程中保存的ThreadLocal对应的实体entry</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">// 获取当前线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">     <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">     <span class="comment">// 如果此map存在</span></span><br><span class="line">     <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">         <span class="comment">// 存在则调用map.remove</span></span><br><span class="line">         <span class="comment">// 以当前ThreadLocal为key删除对应的实体entry</span></span><br><span class="line">         m.remove(<span class="built_in">this</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="二-ThreadLocalMap源码分析"><a href="#二-ThreadLocalMap源码分析" class="headerlink" title="二. ThreadLocalMap源码分析"></a>二. ThreadLocalMap源码分析</h1><blockquote><p><font color='red' size=3>ThreadLocalMap是ThreadLocal里面的一个静态内部类</p></blockquote><h2 id="①-Entry内部类"><a href="#①-Entry内部类" class="headerlink" title="①. Entry内部类"></a>①. Entry内部类</h2><p><img src="https://img-blog.csdnimg.cn/20210429170443658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadLocalMap 是ThreadLocal里面的一个内部类，相当于Map，是个双列集合</span></span><br><span class="line"><span class="comment">//由于ThreadLocalMap使用线性探测法来解决散列冲突，所以实际上Entry[]数组在程序逻辑上是作为一个环形存在的</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在ThreadLocalMap中，也是用Entry来保存K-V结构数据的。但是Entry中key只能是ThreadLocal对象，这点被Entry的构造方法已经限定死了</span></span><br><span class="line">    <span class="comment">// 另外，Entry继承WeakReference,使用弱引用，可以将ThreadLocal对象的生命周期和线程生命周期解绑</span></span><br><span class="line">    <span class="comment">// 持有对ThreadLocal的弱引用，可以使得ThreadLocal在没有其他强引用的时候被回收掉，这样可以避免因为线程得不到销毁导致ThreadLocal对象无法被回收</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        <span class="comment">//定义了一个类型为Object的value，用于存放塞到ThreadLocal里的值。</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="built_in">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="②-核心属性"><a href="#②-核心属性" class="headerlink" title="②. 核心属性"></a>②. 核心属性</h2><p><img src="https://img-blog.csdnimg.cn/20210429170606897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始容量，必须为2的幂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="comment">//Entry表，大小必须为2的幂</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"><span class="comment">//数组里面entrys的个数,可以用于判断table当前使用量是否超过负因子。</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//进行扩容的阈值,表使用量大于它的时候进行扩容,默认为0</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//阈值设置为长度的2/3</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setThreshold</span><span class="params">(<span class="type">int</span> len)</span> &#123;</span><br><span class="line">    threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取环形数组的下一个索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取环形数组的上一个索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">prevIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="③-ThreadLocalMap构造函数"><a href="#③-ThreadLocalMap构造函数" class="headerlink" title="③. ThreadLocalMap构造函数"></a>③. ThreadLocalMap构造函数</h2><p><img src="https://img-blog.csdnimg.cn/20210429170659196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造一个包含firstKey和firstValue的map。</span></span><br><span class="line"><span class="comment">//ThreadLocalMap是懒加载，所以只有当至少要往里面放一个元素的时候才会构建它。</span></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    <span class="comment">// 初始化table数组</span></span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">    <span class="comment">// 用firstKey的threadLocalHashCode与初始大小16取模得到哈希值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 初始化该节点</span></span><br><span class="line">    table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">    <span class="comment">// 设置节点表大小为1</span></span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设定扩容阈值</span></span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="④-getEntry-方法-获取Entry"><a href="#④-getEntry-方法-获取Entry" class="headerlink" title="④. getEntry()方法 获取Entry"></a>④. getEntry()方法 获取Entry</h2><p><img src="https://img-blog.csdnimg.cn/20210429170818327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取ThreadLocal的索引位置，通过下标索引获取内容</span></span><br><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据key这个ThreadLocal的ID来获取索引，也即哈希值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">    <span class="comment">// 对应的entry存在且未失效且弱引用指向的ThreadLocal就是key，则命中返回</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//如果第一次找的不对，因为用的是线性探测，所以往后找还是有可能能够找到目标Entry的</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑤-getEntryAfterMiss"><a href="#⑤-getEntryAfterMiss" class="headerlink" title="⑤. getEntryAfterMiss()"></a>⑤. getEntryAfterMiss()</h2><p><img src="https://img-blog.csdnimg.cn/20210429171031147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用getEntry未直接命中的时候调用此方法</span></span><br><span class="line"> <span class="keyword">private</span> Entry <span class="title function_">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="type">int</span> i, Entry e)</span> &#123;</span><br><span class="line">     Entry[] tab = table;</span><br><span class="line">     <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">     <span class="comment">// 循环向后遍历 基于线性探测法不断向后探测直到遇到空entry。</span></span><br><span class="line">     <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 获取节点对应的k</span></span><br><span class="line">         ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">         <span class="comment">// 相等则返回</span></span><br><span class="line">         <span class="keyword">if</span> (k == key)</span><br><span class="line">             <span class="keyword">return</span> e;</span><br><span class="line">         <span class="comment">// 如果为null，触发一次连续段清理</span></span><br><span class="line">         <span class="keyword">if</span> (k == <span class="literal">null</span>)</span><br><span class="line">             <span class="comment">// 该entry对应的ThreadLocal已经被回收，调用expungeStaleEntry来清理无效的entry</span></span><br><span class="line">             expungeStaleEntry(i);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             <span class="comment">// 获取下一个下标接着进行判断</span></span><br><span class="line">             i = nextIndex(i, len);</span><br><span class="line">         e = tab[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=3>getEntry() 流程</p></blockquote><ol><li><p>首先根据key的hashcode &amp; table.length - 1来确定在table当中的下标</p></li><li><p>如果获取到直接返回，没获取到的话，就接着往后遍历看是否能获取到（因为用的是线性探测法，往后遍历有可能获取到结果）</p></li><li><p>进入了getEntryAfterMiss方法进行线性探测，如果获取到则直接返回；获取的key为null，则触发一次连续段清理expungeStaleEntry（实际上在很多方法当中都会触发该方法，经常会进行连续段清理，这是ThreadLocal核心的清理方法）。</p></li></ol><h2 id="⑥-expungeStaleEntry-方法核心清理函数"><a href="#⑥-expungeStaleEntry-方法核心清理函数" class="headerlink" title="⑥. expungeStaleEntry()方法核心清理函数"></a>⑥. expungeStaleEntry()方法核心清理函数</h2><p><img src="https://img-blog.csdnimg.cn/20210429171353452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个函数是ThreadLocal中核心清理函数</span></span><br><span class="line">       <span class="comment">//  1、从staleSlot开始，向后遍历将ThreadLocal对象被回收所在Entry节点的value和Entry节点本身设置null，方便GC，并且size自减1</span></span><br><span class="line">       <span class="comment">//  2、并且会对非null的Entry节点进行rehash，只要不是在当前位置，就会将Entry挪到下一个为null的位置上</span></span><br><span class="line">       <span class="comment">// 所以实际上是对从staleSlot开始做一个连续段的清理和rehash操作</span></span><br><span class="line">       <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expungeStaleEntry</span><span class="params">(<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">           <span class="comment">// 新的引用指向table</span></span><br><span class="line">           Entry[] tab = table;</span><br><span class="line">           <span class="comment">// 获取长度</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">           <span class="comment">// 因为entry对应的ThreadLocal已经被回收，value设为null，显式断开强引用</span></span><br><span class="line">           tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">           <span class="comment">// 显式设置该entry为null，以便垃圾回收</span></span><br><span class="line">           tab[staleSlot] = <span class="literal">null</span>;</span><br><span class="line">           <span class="comment">// table的size-1</span></span><br><span class="line">           size--;</span><br><span class="line">           Entry e;</span><br><span class="line">           <span class="type">int</span> i;</span><br><span class="line">           <span class="comment">// 遍历删除指定节点所有后续节点当中，ThreadLocal被回收的节点</span></span><br><span class="line">           <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">                (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">                i = nextIndex(i, len)) &#123;</span><br><span class="line">               <span class="comment">// 获取entry当中的key</span></span><br><span class="line">               ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">               <span class="comment">// 如果ThreadLocal为null，则将value以及数组下标所在位置设置null，方便GC</span></span><br><span class="line">               <span class="comment">// 并且size-1</span></span><br><span class="line">               <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">                   e.value = <span class="literal">null</span>;</span><br><span class="line">                   tab[i] = <span class="literal">null</span>;</span><br><span class="line">                   size--;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 对于还没有被回收的情况，需要做一次rehash。</span></span><br><span class="line">                   <span class="comment">// 如果对应的ThreadLocal的ID对len取模出来的索引h不为当前位置i，</span></span><br><span class="line">                   <span class="comment">// 则从h向后线性探测到第一个空的slot，把当前的entry给挪过去。</span></span><br><span class="line">                   <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                   <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                       tab[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">while</span> (tab[h] != <span class="literal">null</span>)</span><br><span class="line">                           h = nextIndex(h, len);</span><br><span class="line">                       tab[h] = e;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 返回staleSlot之后第一个空的slot索引</span></span><br><span class="line">           <span class="keyword">return</span> i;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h2 id="⑦-set-方法"><a href="#⑦-set-方法" class="headerlink" title="⑦. set()方法"></a>⑦. set()方法</h2><p><img src="https://img-blog.csdnimg.cn/20210429171706815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  ThreadLocalMap的set方法，这个方法还是挺关键的</span></span><br><span class="line">       <span class="comment">//  通过这个方法，我们可以看出该哈希表是用线性探测法来解决冲突的</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">           <span class="comment">// 新开一个引用指向table</span></span><br><span class="line">           Entry[] tab = table;</span><br><span class="line">           <span class="comment">// 获取table的长度</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">           <span class="comment">//计算索引 &amp; (INITIAL_CAPACITY - 1),这是取模的一种方式，对于2的幂作为模数取模，用此代替%(2^n)</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">           <span class="comment">//根据获取到的索引进行循环，如果当前索引上的table[i]不为空，在没有return的情况下</span></span><br><span class="line">           <span class="comment">//就使用nextIndex()获取下一个(线性探测法)</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">                e != <span class="literal">null</span>;</span><br><span class="line">                e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">               ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">               <span class="comment">// table[i]上key不为空，并且和当前key相同，更新value</span></span><br><span class="line">               <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                   e.value = value;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// table[i]上的key为空，说明被回收了</span></span><br><span class="line">               <span class="comment">// 这个时候说明改table[i]可以重新使用，用新的key-value将其替换,并删除其他无效的entry</span></span><br><span class="line">               <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">                   replaceStaleEntry(key, value, i);</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 找到空的位置，创建Entry对象并插入</span></span><br><span class="line">           tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">           <span class="comment">// table内元素size自增</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">           <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">               rehash();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h2 id="⑧-replaceStaleEntry"><a href="#⑧-replaceStaleEntry" class="headerlink" title="⑧. replaceStaleEntry()"></a>⑧. replaceStaleEntry()</h2><p><img src="https://img-blog.csdnimg.cn/20210429171855156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    <span class="comment">// 新开一个引用指向table</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="comment">// 获取table的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="comment">// 记录当前失效的节点下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">slotToExpunge</span> <span class="operator">=</span> staleSlot;</span><br><span class="line">    <span class="comment">// 通过这个for循环的prevIndex(staleSlot, len)可以看出</span></span><br><span class="line">    <span class="comment">// 这是由staleSlot下标开始向前扫描</span></span><br><span class="line">    <span class="comment">// 查找并记录最前位置value为null的下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="literal">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    <span class="comment">// 通过for循环nextIndex(staleSlot, len)可以看出</span></span><br><span class="line">    <span class="comment">// 这是由staleSlot下标开始向后扫描</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        <span class="comment">// 获取Entry节点对应的ThreadLocal对象</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 找到了key，将其与无效的slot交换</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            <span class="comment">// 更新对应slot的value值</span></span><br><span class="line">            e.value = value;</span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过注释看出,i之前的节点里,没有value为null的情况</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            <span class="comment">// 从slotToExpunge开始做一次连续段的清理，再做一次启发式清理</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前的slot已经无效，并且向前扫描过程中没有无效slot，则更新slotToExpunge为当前位置</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果key在table中不存在，则在原地放一个即可</span></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="comment">//  在调用cleanSomeSlots进行启发式清理之前</span></span><br><span class="line">    <span class="comment">//  会先调用expungeStaleEntry方法从slotToExpunge到table下标所在为null的连续段进行一次清理</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑨-cleanSomeSlots-启发式地清理slot"><a href="#⑨-cleanSomeSlots-启发式地清理slot" class="headerlink" title="⑨. cleanSomeSlots()启发式地清理slot"></a>⑨. cleanSomeSlots()启发式地清理slot</h2><p><img src="https://img-blog.csdnimg.cn/20210429172013372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启发式地清理slot</span></span><br><span class="line">      <span class="comment">// i对应的Entry是非无效的，有可能是失效被回收了，也有可能是null</span></span><br><span class="line">      <span class="comment">// 会有两个地方调用到这个方法</span></span><br><span class="line">      <span class="comment">// 1、set方法，在判断是否需要resize之前，会清理并rehash一遍</span></span><br><span class="line">      <span class="comment">// 2、替换失效的节点时候，也会进行一次清理</span></span><br><span class="line">      <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">cleanSomeSlots</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">          <span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">          Entry[] tab = table;</span><br><span class="line">          <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">              <span class="comment">// i在任何情况下自己都不会是一个无效slot，所以从下一个开始判断</span></span><br><span class="line">              i = nextIndex(i, len);</span><br><span class="line">              <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">              <span class="comment">// Entry对象不为空，但是ThreadLocal这个key已经为null</span></span><br><span class="line">              <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// 扩大扫描控制因子</span></span><br><span class="line">                  n = len;</span><br><span class="line">                  removed = <span class="literal">true</span>;</span><br><span class="line">                  <span class="comment">// 清理一个连续段</span></span><br><span class="line">                  i = expungeStaleEntry(i);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">return</span> removed;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h2 id="⑩-rehash-方法和resize-方法"><a href="#⑩-rehash-方法和resize-方法" class="headerlink" title="⑩. rehash()方法和resize() 方法"></a>⑩. rehash()方法和resize() 方法</h2><blockquote><p><font color='red' size=4>rehash()</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210429173008133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 做一次全量清理</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    <span class="comment">//   因为做了一次清理，所以size很可能会变小。</span></span><br><span class="line">    <span class="comment">//   ThreadLocalMap这里的实现是调低阈值来判断是否需要扩容，</span></span><br><span class="line">    <span class="comment">//   threshold默认为len*2/3，所以这里的threshold - threshold / 4相当于len/2</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=4>resize()</p><p><img src="https://img-blog.csdnimg.cn/20210429172529729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扩容，因为需要保证table的容量len为2的幂，所以扩容即扩大2倍</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="comment">// 获取旧table的长度，并且创建一个长度为旧长度2倍的Entry数组</span></span><br><span class="line">          Entry[] oldTab = table;</span><br><span class="line">          <span class="type">int</span> <span class="variable">oldLen</span> <span class="operator">=</span> oldTab.length;</span><br><span class="line">          <span class="type">int</span> <span class="variable">newLen</span> <span class="operator">=</span> oldLen * <span class="number">2</span>;</span><br><span class="line">          Entry[] newTab = <span class="keyword">new</span> <span class="title class_">Entry</span>[newLen];</span><br><span class="line">          <span class="comment">// 记录插入的有效Entry节点数</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//  从下标0开始，逐个向后遍历插入到新的table当中</span></span><br><span class="line">          <span class="comment">//  1、如遇到key已经为null，则value设置null，方便GC回收</span></span><br><span class="line">          <span class="comment">//  2、通过hashcode &amp; len - 1计算下标，如果该位置已经有Entry数组，则通过线性探测向后探测插入</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">              <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> oldTab[j];</span><br><span class="line">              <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                  ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                  <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">                      e.value = <span class="literal">null</span>;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="comment">// 线性探测来存放Entry</span></span><br><span class="line">                      <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                      <span class="keyword">while</span> (newTab[h] != <span class="literal">null</span>)</span><br><span class="line">                          h = nextIndex(h, newLen);</span><br><span class="line">                      newTab[h] = e;</span><br><span class="line">                      count++;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 重新设置扩容的阈值</span></span><br><span class="line">          setThreshold(newLen);</span><br><span class="line">          <span class="comment">// 更新size</span></span><br><span class="line">          size = count;</span><br><span class="line">          <span class="comment">// 指向新的Entry数组</span></span><br><span class="line">          table = newTab;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=3> set() 流程</p></blockquote><ol><li>先通过hashcode &amp; (len - 1)来定位该ThreadLocal在table当中的下标</li><li>for循环向后遍历</li><li>如果获取Entry节点的key与我们需要操作的ThreadLocal相等，则直接替换value</li><li>如果遍历的时候拿到了key为null的情况，则调用replaceStaleEntry方法进行与之替换。</li><li>如果上述两个情况都是，则直接在计算的出来的下标当中new一个Entry阶段插入。</li><li>进行一次启发式地清理并且如果插入节点后的size大于扩容的阈值，则调用resize方法进行扩容。</li></ol><h2 id="⑩-remove-方法"><a href="#⑩-remove-方法" class="headerlink" title="⑩. remove() 方法"></a>⑩. remove() 方法</h2><p><img src="https://img-blog.csdnimg.cn/20210429172339217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将ThreadLocal对象对应的Entry节点从table当中删除</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">      Entry[] tab = table;</span><br><span class="line">      <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">           e != <span class="literal">null</span>;</span><br><span class="line">           e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">          <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">              <span class="comment">// // 将引用设置null，方便GC</span></span><br><span class="line">              e.clear();</span><br><span class="line">              <span class="comment">// 从该位置开始进行一次连续段清理</span></span><br><span class="line">              expungeStaleEntry(i);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="三-线程泄露"><a href="#三-线程泄露" class="headerlink" title="三. 线程泄露"></a>三. 线程泄露</h1><blockquote><p><font color='red' size=3> 线程泄露原因</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210429173834913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li>每次操作set、get、remove操作时，会相应调用 ThreadLocalMap 的三个方法，ThreadLocalMap的三个方法在每次被调用时 都会直接或间接调用一个 expungeStaleEntry() 方法，这个方法会将key为null的 Entry 删除，从而避免内存泄漏。</li><li>将一个大对象放入LocalThreadMap后便不再调用set、get、remove方法仍然有可能key的弱引用被回收后，Value强引用没有被回收，此时该仍然可能会导致内存泄漏，这个需要程序员在完成ThreadLocal的使用后要养成手动调用**remove()**的习惯，从而避免内存泄漏。</li></ol><blockquote><p><font color='red' size=3> 附总的数据结构流程图</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210429175257950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="&gt; &lt;font color=&#39;red&#39; size=3&gt; 解决办法"></p>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS底层原理---JDK1.8源码分析</title>
      <link href="/2021/08/07/CAS/"/>
      <url>/2021/08/07/CAS/</url>
      
        <content type="html"><![CDATA[<h1 id="一-CAS介绍"><a href="#一-CAS介绍" class="headerlink" title="一. CAS介绍"></a>一. CAS介绍</h1><ul><li><p>CAS的全称是Compare-And-Swap，它是CPU并发原语。</p></li><li><p>它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。</p></li><li><p>CAS并发原语体现在Java语言中就是sun.misc.Unsafe类的各个方法。调用UnSafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令，这是一种完全依赖于硬件的功能，通过它实现了原子操作，再次强调，由于CAS是一种系统原语，原语属于操作系统用于范畴，是由若干条指令组成，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致的问题，也就是说CAS是线程安全的。</p></li></ul><h1 id="二-CAS代码实现"><a href="#二-CAS代码实现" class="headerlink" title="二. CAS代码实现"></a>二. CAS代码实现</h1><p><img src="https://img-blog.csdnimg.cn/2021070919545723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xizi.cas;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CASDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个原子类</span></span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 一个是期望值，一个是更新值，但期望值和原来的值相同时，才能够更改</span></span><br><span class="line"><span class="comment">         * 假设三秒前，我拿的是5，也就是expect为5，然后我需要更新成 2019</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">2019</span>) + <span class="string">&quot;\t current data: &quot;</span> + atomicInteger.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">1024</span>) + <span class="string">&quot;\t current data: &quot;</span> + atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这是因为我们执行第一个的时候，期望值和原本值是满足的，因此修改成功，但是第二次后，主内存的值已经修改成了2019，不满足期望值，因此返回了false，本次写入失败。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210709195516516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="三-CAS底层原理"><a href="#三-CAS底层原理" class="headerlink" title="三. CAS底层原理"></a>三. CAS底层原理</h1><blockquote><p><font color='red' size=4> 首先我们先看看 atomicInteger.getAndIncrement()方法的源码</p></blockquote><ul><li>从这里能够看到，底层又调用了一个unsafe类的getAndAddInt方法</li></ul><p><img src="https://img-blog.csdnimg.cn/20210709195706542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="①-Unsafe类"><a href="#①-Unsafe类" class="headerlink" title="①.  Unsafe类"></a>①.  Unsafe类</h2><blockquote><p><font color='red' size=4> Unsafe类</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210709200109504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>Unsafe是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（Native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定的内存数据。Unsafe类存在sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中的CAS操作的执行依赖于Unsafe类的方法。</p></li><li><p>注意Unsafe类的所有方法都是native修饰的，也就是说unsafe类中的方法都直接调用操作系统底层资源执行相应的任务</p></li><li><p>为什么Atomic修饰的包装类，能够保证原子性，依靠的就是底层的unsafe类</p></li></ul><h2 id="②-变量valueOffset"><a href="#②-变量valueOffset" class="headerlink" title="②. 变量valueOffset"></a>②. 变量valueOffset</h2><ul><li>从这里我们能够看到，通过valueOffset，直接通过内存地址，获取到值，然后进行加1的操作</li><li><img src="https://img-blog.csdnimg.cn/20210709195706542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="③-变量value用volatile修饰"><a href="#③-变量value用volatile修饰" class="headerlink" title="③. 变量value用volatile修饰"></a>③. 变量value用volatile修饰</h2><ul><li>保证了多线程之间的内存可见性<br><img src="https://img-blog.csdnimg.cn/20210709200402154.png" alt="在这里插入图片描述"></li></ul><h2 id="④-getAndAddInt-源码分析"><a href="#④-getAndAddInt-源码分析" class="headerlink" title="④. getAndAddInt() 源码分析"></a>④. getAndAddInt() 源码分析</h2><p><img src="https://img-blog.csdnimg.cn/20210709200531561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>var5：就是我们从主内存中拷贝到工作内存中的值(每次都要从主内存拿到最新的值到自己的本地内存，然后执行compareAndSwapInt()在再和主内存的值进行比较。因为线程不可以直接越过高速缓存，直接操作主内存，所以执行上述方法需要比较一次，在执行加1操作)</p></li><li><p>那么操作的时候，需要比较工作内存中的值，和主内存中的值进行比较</p></li></ul><blockquote><p><font color='red' size=4> 假设执行 compareAndSwapInt返回false，那么就一直执行 while方法，直到期望的值和真实值一样</p></blockquote><ul><li>val1：AtomicInteger对象本身</li><li>var2：该对象值得引用地址</li><li>var4：需要变动的数量</li><li>var5：用var1和var2找到的内存中的真实值</li><li>用该对象当前的值与var5比较<ul><li>如果相同，更新var5 + var4 并返回true<br>- 如果不同，继续取值然后再比较，直到更新完成</li></ul></li></ul><p>这里没有用synchronized，而用CAS，这样提高了并发性，也能够实现一致性，是因为每个线程进来后，进入的do while循环，然后不断的获取内存中的值，判断是否为最新，然后在进行更新操作。</p><blockquote><p><font color='red' size=4> 假设线程A和线程B同时执行getAndInt操作（分别跑在不同的CPU上）</p></blockquote><ol><li>AtomicInteger里面的value原始值为3，即主内存中AtomicInteger的 value 为3，根据JMM模型，线程A和线程B各自持有一份价值为3的副本，分别存储在各自的工作内存</li><li>线程A通过getIntVolatile(var1 , var2) 拿到value值3，这是线程A被挂起（该线程失去CPU执行权）</li><li>线程B也通过getIntVolatile(var1, var2)方法获取到value值也是3，此时刚好线程B没有被挂起，并执行了compareAndSwapInt方法，比较内存的值也是3，成功修改内存值为4，线程B打完收工，一切OK</li><li>这是线程A恢复，执行CAS方法，比较发现自己手里的数字3和主内存中的数字4不一致，说明该值已经被其它线程抢先一步修改过了，那么A线程本次修改失败，只能够重新读取后在来一遍了，也就是在执行do while</li><li>线程A重新获取value值，因为变量value被volatile修饰，所以其它线程对它的修改，线程A总能够看到，线程A继续执行compareAndSwapInt进行比较替换，直到成功。</li></ol><blockquote><p><font color='red' size=4>Unsafe类 + CAS思想： 也就是自旋，自我旋转</p></blockquote><h2 id="⑤-底层汇编"><a href="#⑤-底层汇编" class="headerlink" title="⑤. 底层汇编"></a>⑤. 底层汇编</h2><ul><li><p>Unsafe类中的compareAndSwapInt是一个本地方法，该方法的实现位于unsafe.cpp中</p><ul><li>先想办法拿到变量value在内存中的地址<ul><li>通过Atomic::cmpxchg实现比较替换，其中参数X是即将更新的值，参数e是原内存的值</li></ul></li></ul></li></ul><h2 id="⑥-原子引用"><a href="#⑥-原子引用" class="headerlink" title="⑥. 原子引用"></a>⑥. 原子引用</h2><ul><li>原子引用其实和原子包装类是差不多的概念，就是将一个java类，用原子引用类进行包装起来，那么这个类就具备了原子性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xizi.cas;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    String userName;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">z3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;z3&quot;</span>, <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">l4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;l4&quot;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建原子引用包装类</span></span><br><span class="line">        AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在主物理内存的共享变量，为z3</span></span><br><span class="line">        atomicReference.set(z3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较并交换，如果现在主物理内存的值为z3，那么交换成l4</span></span><br><span class="line">        System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="string">&quot;\t &quot;</span> + atomicReference.get().toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较并交换，现在主物理内存的值是l4了，但是预期为z3，因此交换失败</span></span><br><span class="line">        System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="string">&quot;\t &quot;</span> + atomicReference.get().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四-CAS缺点"><a href="#四-CAS缺点" class="headerlink" title="四. CAS缺点"></a>四. CAS缺点</h1><blockquote><p><font color='red' size=4> CAS不加锁，保证一次性，但是需要多次比较</p></blockquote><ul><li>循环时间长，开销大（因为执行的是do while，如果比较不成功一直在循环，最差的情况，就是某个线程一直取到的值和预期值都不一样，这样就会无限循环）</li><li>只能保证一个共享变量的原子操作</li><li>当对一个共享变量执行操作时，我们可以通过循环CAS的方式来保证原子操作</li><li>但是对于多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候只能用锁来保证原子性</li><li>引出来ABA问题？</li></ul><h1 id="五-解决ABA问题"><a href="#五-解决ABA问题" class="headerlink" title="五. 解决ABA问题"></a>五. 解决ABA问题</h1><h2 id="①-ABA问题介绍"><a href="#①-ABA问题介绍" class="headerlink" title="①. ABA问题介绍"></a>①. ABA问题介绍</h2><ul><li>CAS只管开头和结尾，也就是头和尾是一样，那就修改成功，中间的这个过程，可能会被人修改过。</li><li>ABA问题的根本在于CAS在修改变量的时候，无法记录变量的状态，比如修改的次数，否修改过这个变量。这样就很容易在一个线程将A修改成B时，另一个线程又会把B修改成A,造成CAS多次执行的问题。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210709201348581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="②-ABA问题解决方法"><a href="#②-ABA问题解决方法" class="headerlink" title="②. ABA问题解决方法"></a>②. ABA问题解决方法</h2><ul><li>时间戳原子引用，来这里应用于版本号的更新，也就是每次更新的时候，需要比较期望值和当前值，以及期望版本号和当前版本号</li></ul><p><img src="https://img-blog.csdnimg.cn/20210709201558202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xizi.cas;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ABADemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传递两个值，一个是初始值，一个是初始版本号</span></span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;============以下是ABA问题的解决==========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 获取版本号</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第一次版本号&quot;</span> + stamp);</span><br><span class="line">            <span class="comment">// 暂停t3一秒钟</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 传入4个值，期望值，更新值，期望版本号，更新版本号</span></span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第二次版本号&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第三次版本号&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line">        &#125;, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 获取版本号</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第一次版本号&quot;</span> + stamp);</span><br><span class="line">            <span class="comment">// 暂停t4 3秒钟，保证t3线程也进行一次ABA问题</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>, stamp, stamp+<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 修改成功否：&quot;</span> + result + <span class="string">&quot;\t 当前最新实际版本号：&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 当前实际最新值&quot;</span> + atomicStampedReference.getReference());</span><br><span class="line">        &#125;, <span class="string">&quot;t4&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> Java集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Synchronized---JDK1.8源码分析</title>
      <link href="/2021/08/07/Synchronized/"/>
      <url>/2021/08/07/Synchronized/</url>
      
        <content type="html"><![CDATA[<h1 id="一-Synchronized的特性"><a href="#一-Synchronized的特性" class="headerlink" title="一. Synchronized的特性"></a>一. Synchronized的特性</h1><h2 id="①-原子性"><a href="#①-原子性" class="headerlink" title="①.  原子性"></a>①.  原子性</h2><ul><li>所谓原子性就是指一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</li><li>被synchronized修饰的类或对象的所有操作都是原子的，因为在执行操作之前必须先获得类或对象的锁，直到执行完才能释放，这中间的过程无法被中断（除了已经废弃的stop()方法），即保证了原子性。</li></ul><h2 id="②-可见性"><a href="#②-可见性" class="headerlink" title="②. 可见性"></a>②. 可见性</h2><ul><li>可见性是指多个线程访问一个资源时，该资源的状态、值信息等对于其他线程都是可见的。</li><li>synchronized和volatile都具有可见性，其中synchronized对一个类或对象加锁时，一个线程如果要访问该类或对象必须先获得它的锁，而这个锁的状态对于其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到主存当中，保证资源变量的可见性，如果某个线程占用了该锁，其他线程就必须在锁池中等待锁的释放。</li></ul><h2 id="③-有序性"><a href="#③-有序性" class="headerlink" title="③. 有序性"></a>③. 有序性</h2><ul><li>有序性值程序执行的顺序按照代码先后执行。</li><li>有效解决重排序问题，即 一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作；</li><li>synchronized和volatile都具有有序性，Java允许编译器和处理器对指令进行重排，但是指令重排并不会影响单线程的顺序，它影响的是多线程并发执行的顺序性。synchronized保证了每个时刻都只有一个线程访问同步代码块，也就确定了线程执行同步代码块是分先后顺序的，保证了有序性。</li></ul><h2 id="④-可重入性"><a href="#④-可重入性" class="headerlink" title="④. 可重入性"></a>④. 可重入性</h2><ul><li>Synchronized和ReentrantLock都是可重入锁。</li><li>当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁。通俗一点讲就是说一个线程拥有了锁仍然还可以重复申请锁。</li></ul><h1 id="二-Synchronized的使用"><a href="#二-Synchronized的使用" class="headerlink" title="二. Synchronized的使用"></a>二. Synchronized的使用</h1><h2 id="①-修饰普通方法"><a href="#①-修饰普通方法" class="headerlink" title="①. 修饰普通方法"></a>①. 修饰普通方法</h2><p><img src="https://img-blog.csdnimg.cn/20210517212325180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xizi.SynchronizedTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//共享资源(临界资源)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没有synchronized关键字，输出小于20000</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10000</span>;j++)&#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread1 t=<span class="keyword">new</span> <span class="title class_">Thread1</span>();</span><br><span class="line">        Thread t1=<span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();<span class="comment">//主线程等待t1执行完毕</span></span><br><span class="line">        t2.join();<span class="comment">//主线程等待t2执行完毕</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出结果:</span></span><br><span class="line"><span class="comment">     * 20000</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="②-修饰代码块"><a href="#②-修饰代码块" class="headerlink" title="②. 修饰代码块"></a>②. 修饰代码块</h2><p><img src="https://img-blog.csdnimg.cn/20210517212700604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xizi.SynchronizedTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//共享资源(临界资源)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10000</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Thread1.class)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread1 t=<span class="keyword">new</span> <span class="title class_">Thread1</span>();</span><br><span class="line">        Thread t1=<span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出结果:</span></span><br><span class="line"><span class="comment">     * 20000</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="③-修饰静态方法"><a href="#③-修饰静态方法" class="headerlink" title="③. 修饰静态方法"></a>③. 修饰静态方法</h2><p><img src="https://img-blog.csdnimg.cn/20210517212934684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xizi.SynchronizedTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread1</span> &#123;</span><br><span class="line">    <span class="comment">//共享资源(临界资源)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果没有synchronized关键字，输出小于20000</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    increase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    increase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();<span class="comment">//主线程等待t1执行完毕</span></span><br><span class="line">        t2.join();<span class="comment">//主线程等待t2执行完毕</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出结果:</span></span><br><span class="line"><span class="comment">     * 20000</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>synchronized修饰的实例方法，多线程并发访问时，只能有一个线程进入，获得对象内置锁，其他线程阻塞等待，但在此期间线程仍然可以访问其他方法。</li><li>synchronized修饰的静态方法，多线程并发访问时，只能有一个线程进入，获得类锁，其他线程阻塞等待，但在此期间线程仍然可以访问其他方法。</li><li>synchronized修饰的代码块，多线程并发访问时，只能有一个线程进入，根据括号中的对象或者是类，获得相应的对象内置锁或者是类锁</li></ol><h1 id="三-Synchronized锁原理——反编译分析"><a href="#三-Synchronized锁原理——反编译分析" class="headerlink" title="三. Synchronized锁原理——反编译分析"></a>三. Synchronized锁原理——反编译分析</h1><h2 id="①-同步方法"><a href="#①-同步方法" class="headerlink" title="①. 同步方法"></a>①. 同步方法</h2><h3 id="1-进行javap反编译"><a href="#1-进行javap反编译" class="headerlink" title="1. 进行javap反编译"></a>1. 进行javap反编译</h3><p><img src="https://img-blog.csdnimg.cn/20210517204613365.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;synchronized 方法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size> 进行javap反编译</p></blockquote><p><img src="https://img-blog.csdnimg.cn/2021051720455746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2-ACC-SYNCHRONIZED标志位"><a href="#2-ACC-SYNCHRONIZED标志位" class="headerlink" title="2. ACC_SYNCHRONIZED标志位"></a>2. ACC_SYNCHRONIZED标志位</h3><ul><li>从反编译的结果来看，方法的同步并没有通过指令monitorenter和monitorexit来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。</li><li>JVM就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。 其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。</li></ul><h2 id="②-同步代码块"><a href="#②-同步代码块" class="headerlink" title="②. 同步代码块"></a>②. 同步代码块</h2><p><img src="https://img-blog.csdnimg.cn/20210517204158140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//同步代码块</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized 代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-进行javap反编译-1"><a href="#1-进行javap反编译-1" class="headerlink" title="1. 进行javap反编译"></a>1. 进行javap反编译</h3><blockquote><p><font color='red' size> 进行javap反编译</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210517204124457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70"></p><h3 id="2-monitorenter进入指令"><a href="#2-monitorenter进入指令" class="headerlink" title="2. monitorenter进入指令"></a>2. monitorenter进入指令</h3><blockquote><p><font color='red' size=4><strong>monitorenter</strong>：每个对象都是一个监视器锁（monitor）。</p></blockquote><ul><li>当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</li></ul><ol><li>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；</li><li>如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1；</li><li>如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权；</li></ol><h3 id="3-monitorexit退出指令"><a href="#3-monitorexit退出指令" class="headerlink" title="3. monitorexit退出指令"></a>3. monitorexit退出指令</h3><blockquote><p><font color='red' size=4><strong>monitorexit</strong></p></blockquote><ul><li><p>monitorexit：执行monitorexit的线程必须是objectref所对应的monitor的所有者。</p></li><li><p>指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。</p></li><li><p>上面monitorexit指令出现了两次，第1次为同步正常退出释放锁；第2次为发生异步退出释放锁；</p></li></ul><h1 id="四-JVM对Synchronized的优化"><a href="#四-JVM对Synchronized的优化" class="headerlink" title="四. JVM对Synchronized的优化"></a>四. JVM对Synchronized的优化</h1><h2 id="①-对象头存储布局"><a href="#①-对象头存储布局" class="headerlink" title="①. 对象头存储布局"></a>①. 对象头存储布局</h2><blockquote><p><font color='red' size=3> 在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据、对其填充。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210517211008740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>实例数据：存放类的属性数据信息，包括父类的属性信息；</li><li>对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐；</li><li>对象头：Java对象头一般占有2个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit，在64位虚拟机中，1个机器码是8个字节，也就是64bit），但是 如果对象是数组类型，则需要3个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。</li></ul><blockquote><p><font color='red' size=4> Java对象头具体结构描述</p></blockquote><ul><li>Synchronized用的锁就是存在Java对象头里的，对象头主要包括两部分数据：Mark Word（标记字段）、Class Pointer（类型指针）。其中 Class Pointer是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，Mark Word用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/d49dc0285cbd2c365f862133230d14ab.png" alt="在这里插入图片描述"></p><h2 id="②-Java对象头结构组成"><a href="#②-Java对象头结构组成" class="headerlink" title="②. Java对象头结构组成"></a>②. Java对象头结构组成</h2><blockquote><p><font color='red' size=4> Java对象头结构组成</p></blockquote><ul><li>Mark Word用于存储对象自身的运行时数据，如：哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。</li><li>下图是Java对象头 无锁状态下Mark Word部分的存储结构（32位虚拟机）：<br><img src="https://img-blog.csdnimg.cn/img_convert/beb4a8024a5d2dbebe65a91a38b5860d.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/img_convert/2f9d7ad8d0767709d79ae633ef74e69c.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/7e72b7eb11911fcee2b21a51c66e4a3f.png" alt="在这里插入图片描述"></li></ul><h2 id="③-对象头中Mark-Word与线程中Lock-Record"><a href="#③-对象头中Mark-Word与线程中Lock-Record" class="headerlink" title="③. 对象头中Mark Word与线程中Lock Record"></a>③. 对象头中Mark Word与线程中Lock Record</h2><ul><li>Lock Record是线程私有的数据结构，每一个线程都有一个可用Lock Record列表，同时还有一个全局的可用列表。</li><li>每一个被锁住的对象Mark Word都会和一个Lock Record关联（对象头的MarkWord中的Lock Word指向Lock Record的起始地址），同时Lock Record中有一个Owner字段存放拥有该锁的线程的唯一标识（或者object mark word），表示该锁被这个线程占用。</li></ul><blockquote><p><font color='red' size=4> Lock Record的内部结构：</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/325aa8a8bb1ccbba15fb5260d43e1f79.png" alt="在这里插入图片描述"></p><h2 id="④-监视器（Monitor）"><a href="#④-监视器（Monitor）" class="headerlink" title="④. 监视器（Monitor）"></a>④. 监视器（Monitor）</h2><ul><li><p>任何一个对象都有一个Monitor与之关联，当且一个Monitor被持有后，它将处于锁定状态。Synchronized在JVM里的实现都是 基于进入和退出Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。</p></li><li><p>MonitorEnter指令：插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁；</p></li><li><p>MonitorExit指令：插入在方法结束处和异常处，JVM保证每个MonitorEnter必须有对应的MonitorExit；</p></li></ul><h2 id="⑤-锁优化"><a href="#⑤-锁优化" class="headerlink" title="⑤. 锁优化"></a>⑤. 锁优化</h2><ul><li>JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</li><li>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁。但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。</li><li>在 JDK 1.6 中默认是开启偏向锁和轻量级锁的，可以通过-XX:-UseBiasedLocking来禁用偏向锁。</li></ul><h3 id="1-自旋锁"><a href="#1-自旋锁" class="headerlink" title="1. 自旋锁"></a>1. 自旋锁</h3><ul><li><p>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。</p></li><li><p>所以引入自旋锁，何谓自旋锁？ </p></li><li><p>所谓自旋锁，就是指当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检测锁是否被释放，而不是进入线程挂起或睡眠状态。</p></li><li><p>自旋锁适用于锁保护的临界区很小的情况，临界区很小的话，锁占用的时间就很短。自旋等待不能替代阻塞，虽然它可以避免线程切换带来的开销，但是它占用了CPU处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。</p></li><li><p>自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用-XX:+UseSpinning开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整。</p></li><li><p>如果通过参数-XX:PreBlockSpin来调整自旋锁的自旋次数，会带来诸多不便。假如将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如多自旋一两次就可以获取锁），是不是很尴尬。于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明。</p></li></ul><h3 id="2-适应性自旋锁"><a href="#2-适应性自旋锁" class="headerlink" title="2. 适应性自旋锁"></a>2. 适应性自旋锁</h3><ul><li>JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。那它如何进行适应性自旋呢？ </li><li>线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</li></ul><h3 id="3-锁消除"><a href="#3-锁消除" class="headerlink" title="3. 锁消除"></a>3. 锁消除</h3><ul><li>为了保证数据的完整性，在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。</li><li>如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于程序员来说这还不清楚么？在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？虽然没有显示使用锁，但是在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作。比如StringBuffer的append()方法，Vector的add()方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">vectorTest</span><span class="params">()</span>&#123;</span><br><span class="line">    Vector&lt;String&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">        vector.add(i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(vector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在运行这段代码时，JVM可以明显检测到变量vector没有逃逸出方法vectorTest()之外，所以JVM可以大胆地将vector内部的加锁操作消除。</li></ul><h3 id="4-锁粗化"><a href="#4-锁粗化" class="headerlink" title="4. 锁粗化"></a>4. 锁粗化</h3><ul><li>如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。</li><li>锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。</li><li>vector每次add的时候都需要加锁操作，JVM检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外。</li></ul><h3 id="5-偏向锁"><a href="#5-偏向锁" class="headerlink" title="5. 偏向锁"></a>5. 偏向锁</h3><ul><li>偏向锁是JDK6中的重要引进，因为HotSpot作者经过研究实践发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，引进了偏向锁。</li></ul><blockquote><p><font color='red' >偏向锁是在单线程执行代码块时使用的机制，如果在多线程并发的环境下（即线程A尚未执行完同步代码块，线程B发起了申请锁的申请），则一定会转化为轻量级锁或者重量级锁。</p></blockquote><ul><li>在JDK5中偏向锁默认是关闭的，而到了JDK6中偏向锁已经默认开启。如果并发数较大同时同步代码块执行时间较长，则被多个线程同时访问的概率就很大，就可以使用参数-XX:-UseBiasedLocking来禁止偏向锁(但这是个JVM参数，不能针对某个对象锁来单独设置)。</li><li>引入偏向锁主要目的是：为了在没有多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。因为轻量级锁的加锁解锁操作是需要依赖多次CAS原子指令的，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗也必须小于节省下来的CAS原子指令的性能消耗）。</li></ul><blockquote><p><font color='red' > 轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</p></blockquote><blockquote><p><font color='red'  size=4>偏向锁的获取 处理流程如下：</p></blockquote><ul><li>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程进入和退出同步块时不需要花费CAS操作来争夺锁资源，只需要检查是否为偏向锁、锁标识为以及ThreadID即可</li></ul><ol><li>检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；</li><li>若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）；</li><li>如果测试线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）；</li><li>通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；</li><li>执行同步代码块；</li></ol><blockquote><p><font color='red'  size=4>偏向锁的释放 处理流程如下：</p></blockquote><ul><li>偏向锁的释放采用了 一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要 等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：</li></ul><ol><li>暂停拥有偏向锁的线程；</li><li>判断锁对象是否还处于被锁定状态，否，则恢复到无锁状态（01），以允许其余线程竞争。是，则挂起持有锁的当前线程，并将指向当前线程的锁记录地址的指针放入对象头Mark Word，升级为轻量级锁状态（00），然后恢复持有锁的当前线程，进入轻量级锁的竞争模式；</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/8dce1a573822afd1065c26f56ecf9720.png" alt="在这里插入图片描述"></p><h3 id="6-轻量级锁"><a href="#6-轻量级锁" class="headerlink" title="6. 轻量级锁"></a>6. 轻量级锁</h3><blockquote><p><font color='red'  size=4> 轻量级锁获取过程</p></blockquote><ul><li>引入轻量级锁的主要目的是 在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步骤如下：</li></ul><ol><li><p>在线程进入同步块时，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。此时线程堆栈与对象头的状态如下图所示：<br>  <img src="https://img-blog.csdnimg.cn/img_convert/e08e370085acbafed55262daffa78247.png" alt="在这里插入图片描述"></p></li><li><p>拷贝对象头中的Mark Word复制到锁记录（Lock Record）中；</p></li><li><p>拷贝成功后，虚拟机将使用CAS操作尝试将对象Mark Word中的Lock Word更新为指向当前线程Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤（4），否则执行步骤（5）；</p></li><li><p>如果这个更新动作成功了，那么当前线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态，此时线程堆栈与对象头的状态如下图所示</p></li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/bfed138d4e519a2c510c942ee3274237.png" alt="在这里插入图片描述"><br>5. 如果这个更新操作失败了，虚拟机首先会检查对象Mark Word中的Lock Word是否指向当前线程的栈帧，如果是，就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，进入自旋执行（3），若自旋结束时仍未获得锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，当前线程以及后面等待锁的线程也要进入阻塞状态。</p><blockquote><p><font color='red'  size=4> 轻量级锁释放过程 </p></blockquote><ul><li>轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：</li></ul><ol><li>通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word；</li><li>如果替换成功，整个同步过程就完成了，恢复到无锁状态（01）；</li><li>如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），那就要在释放锁的同时，唤醒被挂起的线程。</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/63790cf7b52954cbe7b50738ca78c1ea.png" alt="在这里插入图片描述"></p><ul><li>此处，如何理解“轻量级”？“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。</li></ul><blockquote><p><font color='red' > 轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，必然就会导致轻量级锁膨胀为重量级锁。</p></blockquote><h3 id="7-重量级锁"><a href="#7-重量级锁" class="headerlink" title="7. 重量级锁"></a>7. 重量级锁</h3><ul><li><font color='red' >Synchronized是通过对象内部的一个叫做 监视器锁（Monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为 “重量级锁”。</li></ul><h3 id="8-重量级锁、轻量级锁和偏向锁之间转换"><a href="#8-重量级锁、轻量级锁和偏向锁之间转换" class="headerlink" title="8. 重量级锁、轻量级锁和偏向锁之间转换"></a>8. 重量级锁、轻量级锁和偏向锁之间转换</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/7e6896eee12083c647782c16e0d04d67.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/2c180a58045ee0b2c28c369a0918a952.png" alt="在这里插入图片描述"></p><h3 id="9-锁的优劣"><a href="#9-锁的优劣" class="headerlink" title="9. 锁的优劣"></a>9. 锁的优劣</h3><ul><li>各种锁并不是相互代替的，而是在不同场景下的不同选择，绝对不是说重量级锁就是不合适的。每种锁是只能升级，不能降级，即由偏向锁-&gt;轻量级锁-&gt;重量级锁，而这个过程就是开销逐渐加大的过程。<br><img src="https://img-blog.csdnimg.cn/img_convert/67e2d2988878d0033b1377dfda36774e.png" alt="在这里插入图片描述"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayBlockingQueue-JDK1.8源码分析</title>
      <link href="/2021/08/07/ArrayBlockingQueue/"/>
      <url>/2021/08/07/ArrayBlockingQueue/</url>
      
        <content type="html"><![CDATA[<h1 id="一-ArrayBlockingQueue介绍"><a href="#一-ArrayBlockingQueue介绍" class="headerlink" title="一. ArrayBlockingQueue介绍"></a>一. ArrayBlockingQueue介绍</h1><ul><li>ArrayBlockingQueue是一个基于用数组实现的有界阻塞队列。此队列按照先进先出的原则对元素进行排序</li></ul><h1 id="二-ArrayBlockingQueue数据结构"><a href="#二-ArrayBlockingQueue数据结构" class="headerlink" title="二. ArrayBlockingQueue数据结构"></a>二. ArrayBlockingQueue数据结构</h1><ul><li>ArrayBlockingQueue的底层数据结构是数组，数据结构如下:</li></ul><p><img src="https://img-blog.csdnimg.cn/20210719211605423.png" alt="在这里插入图片描述"></p><ul><li>ArrayBlockingQueue底层采用数据才存放数据，对数组的访问添加了锁的机制，使其能够支持多线程并发。</li></ul><h1 id="三-ArrayBlockingQueue源码分析"><a href="#三-ArrayBlockingQueue源码分析" class="headerlink" title="三. ArrayBlockingQueue源码分析"></a>三. ArrayBlockingQueue源码分析</h1><h2 id="①-类的继承关系"><a href="#①-类的继承关系" class="headerlink" title="①. 类的继承关系"></a>①. 类的继承关系</h2><p><img src="https://img-blog.csdnimg.cn/20210719212210360.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayBlockingQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>ArrayBlockingQueue继承了AbstractQueue抽象类，AbstractQueue定义了对队列的基本操作；同时实现了BlockingQueue接口，BlockingQueue表示阻塞型的队列，其对队列的操作可能会抛出异常；同时也实现了Searializable接口，表示可以被序列化。</li></ul><h2 id="②-类的属性"><a href="#②-类的属性" class="headerlink" title="②. 类的属性"></a>②. 类的属性</h2><ul><li>从类的属性中可以清楚的看到其底层的结构是Object类型的数组，取元素和存元素有不同的索引，有一个可重入锁ReentrantLock，两个条件Condition。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210719212646370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">817911632652898426L</span>;</span><br><span class="line">    <span class="comment">// 存放实际元素的数组</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items;</span><br><span class="line">    <span class="comment">// 取元素索引</span></span><br><span class="line">    <span class="type">int</span> takeIndex;</span><br><span class="line">    <span class="comment">// 获取元素索引</span></span><br><span class="line">    <span class="type">int</span> putIndex;</span><br><span class="line">    <span class="comment">// 队列中的项</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">    <span class="comment">// 等待获取条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">    <span class="comment">// 等待存放条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">Itrs</span> <span class="variable">itrs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h2 id="③-类的构造函数"><a href="#③-类的构造函数" class="headerlink" title="③. 类的构造函数"></a>③. 类的构造函数</h2><p><img src="https://img-blog.csdnimg.cn/20210719212757411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用两个参数的构造函数</span></span><br><span class="line">    <span class="built_in">this</span>(capacity, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始容量必须大于0</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="comment">// 初始化数组</span></span><br><span class="line">    <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">    <span class="comment">// 初始化可重入锁</span></span><br><span class="line">    lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(fair);</span><br><span class="line">    <span class="comment">// 初始化等待条件</span></span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用两个参数的构造函数</span></span><br><span class="line">    <span class="built_in">this</span>(capacity, fair);</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 上锁</span></span><br><span class="line">    lock.lock(); <span class="comment">// Lock only for visibility, not mutual exclusion</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (E e : c) &#123; <span class="comment">// 遍历集合</span></span><br><span class="line">                <span class="comment">// 检查元素是否为空</span></span><br><span class="line">                checkNotNull(e);</span><br><span class="line">                <span class="comment">// 存入ArrayBlockingQueue中</span></span><br><span class="line">                items[i++] = e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当初始化容量小于传入集合的大小时，会抛出异常</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 元素数量</span></span><br><span class="line">        count = i;</span><br><span class="line">        <span class="comment">// 初始化存元素的索引</span></span><br><span class="line">        putIndex = (i == capacity) ? <span class="number">0</span> : i;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="④-put-方法"><a href="#④-put-方法" class="headerlink" title="④. put()方法"></a>④. put()方法</h2><ul><li><ul><li>put函数用于存放元素，在当前线程被中断时会抛出异常，并且当队列已经满时，会阻塞一直等待。其中，put会调用enqueue函数<br><img src="https://img-blog.csdnimg.cn/20210719213145808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">// 获取可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 如果当前线程未被中断，则获取锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)<span class="comment">// 判断元素是否已满</span></span><br><span class="line">            <span class="comment">// 若满，则等待</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        <span class="comment">// 入队列</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="④-enqueue-方法"><a href="#④-enqueue-方法" class="headerlink" title="④. enqueue() 方法"></a>④. enqueue() 方法</h2><ul><li>enqueue函数用于将元素存入底层Object数组中，并且会唤醒等待notEmpty条件的线程。<br><img src="https://img-blog.csdnimg.cn/20210719213400920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(E x)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取数组</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">    <span class="comment">// 将元素放入</span></span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)<span class="comment">// 放入后存元素的索引等于数组长度（表示已满）</span></span><br><span class="line">        <span class="comment">// 重置存索引为0</span></span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 元素数量加1</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">// 唤醒在notEmpty条件上等待的线程</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑤-offer-方法"><a href="#⑤-offer-方法" class="headerlink" title="⑤. offer()方法"></a>⑤. offer()方法</h2><ul><li>offer函数也用于存放元素，在调用ArrayBlockingQueue的add方法时，会间接的调用到offer函数，offer函数添加元素不会抛出异常，当底层Object数组已满时，则返回false，否则，会调用enqueue函数，将元素存入底层Object数组。并唤醒等待notEmpty条件的线程。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查元素不能为空</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == items.length) <span class="comment">// 元素个数等于数组长度，则返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 添加进数组</span></span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放数组</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20210719213642567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="⑥-add-方法"><a href="#⑥-add-方法" class="headerlink" title="⑥. add()方法"></a>⑥. add()方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.add(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210719213804456.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (offer(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210719213901242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="⑦-poll-方法"><a href="#⑦-poll-方法" class="headerlink" title="⑦. poll()方法"></a>⑦. poll()方法</h2><ul><li>poll函数用于获取元素，其与offer函数相对应，不会抛出异常，当元素个数为0是，返回null，否则，调用dequeue函数，并唤醒等待notFull条件的线程。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210719214048513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 重入锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 若元素个数为0则返回null，否则，调用dequeue，出队列</span></span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="literal">null</span> : dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑦-dequeue-方法"><a href="#⑦-dequeue-方法" class="headerlink" title="⑦. dequeue() 方法"></a>⑦. dequeue() 方法</h2><ul><li>dequeue函数用于将取元素，并且会唤醒等待notFull条件的线程</li></ul><p><img src="https://img-blog.csdnimg.cn/20210719214123600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">     <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">     <span class="comment">// 取元素</span></span><br><span class="line">     <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> (E) items[takeIndex];</span><br><span class="line">     <span class="comment">// 该索引的值赋值为null</span></span><br><span class="line">     items[takeIndex] = <span class="literal">null</span>;</span><br><span class="line">     <span class="comment">// 取值索引等于数组长度</span></span><br><span class="line">     <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">         <span class="comment">// 重新赋值取值索引</span></span><br><span class="line">         takeIndex = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">// 元素个数减1</span></span><br><span class="line">     count--;</span><br><span class="line">     <span class="keyword">if</span> (itrs != <span class="literal">null</span>)</span><br><span class="line">         itrs.elementDequeued();</span><br><span class="line">     <span class="comment">// 唤醒在notFull条件上等待的线程</span></span><br><span class="line">     notFull.signal();</span><br><span class="line">     <span class="keyword">return</span> x;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="⑧-take-方法"><a href="#⑧-take-方法" class="headerlink" title="⑧. take()方法"></a>⑧. take()方法</h2><ul><li>take函数用于从ArrayBlockingQueue中获取一个元素，其与put函数相对应，在当前线程被中断时会抛出异常，并且当队列为空时，会阻塞一直等待。其中，take会调用dequeue函数</li></ul><p><img src="https://img-blog.csdnimg.cn/20210719214310223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 如果当前线程未被中断，则获取锁，中断会抛出异常</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)<span class="comment">// 元素数量为0，即Object数组为空</span></span><br><span class="line">            <span class="comment">// 则等待notEmpty条件</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="comment">// 出队列</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑨-remove-方法"><a href="#⑨-remove-方法" class="headerlink" title="⑨. remove()方法"></a>⑨. remove()方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> poll();</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210719214001184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="⑩-clear-方法"><a href="#⑩-clear-方法" class="headerlink" title="⑩. clear() 方法"></a>⑩. clear() 方法</h2><ul><li>clear函数用于清空ArrayBlockingQueue，并且会释放所有等待notFull条件的线程（存放元素的线程）</li></ul><p><img src="https://img-blog.csdnimg.cn/20210719214720952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 数组</span></span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">        <span class="comment">// 可重入锁</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 保存元素个数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> count;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span>) &#123; <span class="comment">// 元素个数大于0</span></span><br><span class="line">                <span class="comment">// 存数元素索引</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">putIndex</span> <span class="operator">=</span> <span class="built_in">this</span>.putIndex;</span><br><span class="line">                <span class="comment">// 取元素索引</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> takeIndex;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">// 赋值为null</span></span><br><span class="line">                    items[i] = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (++i == items.length) <span class="comment">// 重新赋值i</span></span><br><span class="line">                        i = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">while</span> (i != putIndex);</span><br><span class="line">                <span class="comment">// 重新赋值取元素索引</span></span><br><span class="line">                takeIndex = putIndex;</span><br><span class="line">                <span class="comment">// 元素个数为0</span></span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (itrs != <span class="literal">null</span>)</span><br><span class="line">                    itrs.queueIsEmpty();</span><br><span class="line">                <span class="keyword">for</span> (; k &gt; <span class="number">0</span> &amp;&amp; lock.hasWaiters(notFull); k--) <span class="comment">// 若有等待notFull条件的线程，则逐一唤醒</span></span><br><span class="line">                    notFull.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="四-ArrayBlockingQueue方法总结"><a href="#四-ArrayBlockingQueue方法总结" class="headerlink" title="四. ArrayBlockingQueue方法总结"></a>四. ArrayBlockingQueue方法总结</h1><p><img src="https://img-blog.csdnimg.cn/20210719212323833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>抛出异常：当队列满时，再向队列中插入元素，则会抛出IllegalStateException异常。当队列空时，再向队列中获取元素，则会抛出NoSuchElementException异常。</li><li>返回特殊值：当队列满时，向队列中添加元素，则返回false，否则返回true。当队列为空时，向队列中获取元素，则返回null，否则返回元素。</li><li>一直阻塞：当阻塞队列满时，如果生产者向队列中插入元素，则队列会一直阻塞当前线程，直到队列可用或响应中断退出。当阻塞队列为空时，如果消费者线程向阻塞队列中获取数据，则队列会一直阻塞当前线程，直到队列空闲或响应中断退出。</li><li>超时退出：当队列满时，如果生产线程向队列中添加元素，则队列会阻塞生产线程一段时间，超过指定的时间则退出返回false。当队列为空时，消费线程从队列中移除元素，则队列会阻塞一段时间，如果超过指定时间退出返回null。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList---JDK1.8源码分析</title>
      <link href="/2021/04/17/ArrayList/"/>
      <url>/2021/04/17/ArrayList/</url>
      
        <content type="html"><![CDATA[<h1 id="一-ArrayList的数据结构"><a href="#一-ArrayList的数据结构" class="headerlink" title="一. ArrayList的数据结构"></a>一. ArrayList的数据结构</h1><p><img src="https://img-blog.csdnimg.cn/20210426200605207.png" alt="在这里插入图片描述"></p><ul><li>底层的数据结构就是数组，数组元素类型为Object类型，即可以存放所有类型数据。我们对ArrayList类的实例的所有的操作底层都是基于数组的。</li></ul><h1 id="二-ArrayList源码分析"><a href="#二-ArrayList源码分析" class="headerlink" title="二. ArrayList源码分析"></a>二. ArrayList源码分析</h1><h2 id="①-继承关系"><a href="#①-继承关系" class="headerlink" title="①. 继承关系"></a>①. 继承关系</h2><p><img src="https://img-blog.csdnimg.cn/20210426212049673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li>RandomAccess接口：这个是一个标记性接口，通过查看api文档，它的作用就是用来快速随机存取</li><li>Serializable接口：实现该序列化接口，表明该类可以被序列化就是能够从类变成字节流传输，然后还能从字节流变成原来的类。</li><li>Cloneable接口：实现了该接口，就可以使用Object.Clone()方法了。</li><li>ArrayList就继承这个AbstractList类，继承一些通用的方法，然后自己在实现一些自己特有的方法</li></ol><h2 id="②-类中的属性"><a href="#②-类中的属性" class="headerlink" title="②. 类中的属性"></a>②. 类中的属性</h2><p><img src="https://img-blog.csdnimg.cn/20210426212321844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列号</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//默认初始容量  10</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//一个空数组，当用户指定ArrayList容量为0时，用户指定容量为 0 时返回返回该数组</span></span><br><span class="line"> <span class="comment">//ArrayList list1 = new ArrayList(0);</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//ArrayList list = new ArrayList();</span></span><br><span class="line">  <span class="comment">//1. 当用户没有指定 ArrayList() 的容量时(即调用无参构造函数)，返回的是该数组==&gt;刚创建一个 ArrayList 时，其内数据量为 0。</span></span><br><span class="line">  <span class="comment">//2. 当用户第一次添加元素时，该数组将会扩容，变成默认容量为 10(DEFAULT_CAPACITY) 的一个数组===&gt;通过  ensureCapacityInternal() 实现</span></span><br><span class="line">  <span class="comment">//3. 它与 EMPTY_ELEMENTDATA 的区别就是：该数组是默认返回的，而后者是在用户指定容量为 0 时返回</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//1. 当前数据对象存放地方，当前对象不参与序列化</span></span><br><span class="line"> <span class="comment">//2. 这个关键字最主要的作用就是当序列化时，被transient修饰的内容将不会被序列化</span></span><br><span class="line"> <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//ArrayList实际存储的数据数量</span></span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//继承于AbstractList</span></span><br><span class="line"> <span class="comment">//集合数组修改次数的标识</span></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="③-构造方法"><a href="#③-构造方法" class="headerlink" title="③. 构造方法"></a>③. 构造方法</h2><blockquote><p><font color='red' size=3>无参构造方法_(DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210426212123879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 无参构造函数：没有进行传参 当前元素数组直接返回默认 容量空元素数据 DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"> <span class="comment">//2. 创建一个 空的 ArrayList，此时其内数组缓冲区 elementData = &#123;&#125;, 长度为 0</span></span><br><span class="line"> <span class="comment">//3. 当元素第一次被加入时，扩容至默认容量 10</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=3>有参构造方法1，若参数为0_EMPTY_(ELEMENTDATA)<br><img src="https://img-blog.csdnimg.cn/20210426212150883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity  初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 当初试容量值非法(小于0)时抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//创建一个初试容量的、空的ArrayList arraylist并不是懒加载机制</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当出现这个情况 ArrayList list = new ArrayList(0);和直接不传是不一样的</span></span><br><span class="line">        <span class="comment">//传0 是直接赋值 EMPTY_ELEMENTDATA</span></span><br><span class="line">        <span class="comment">//不传 是直接赋值 DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line">        <span class="comment">//初始化容量为0 的时候 直接返回 EMPTY_ELEMENTDATA 空元素数据</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=3>有参构造方法2_集合添加</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210426212219495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 要放入 ArrayList 中的集合，其内元素将会全部添加到新建的 ArrayList 实例中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 当参数 c 为 null 时抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//创建一个包含collection的ArrayList</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="comment">//把集合传化成Object[]数组</span></span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="comment">//转化后的数组长度赋给当前ArrayList的size,并判断是否为0</span></span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            <span class="comment">// 若c.toArray() 返回的数组类型不是 Object[]，则利用 Arrays.copyOf(); 来构造一个大小为 size 的 Object[] 数组</span></span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 数组长度为0 直接使用空数组</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="④-核心方法"><a href="#④-核心方法" class="headerlink" title="④. 核心方法"></a>④. 核心方法</h2><h3 id="1-add-E-e-有四个方法，我仔细分析一个"><a href="#1-add-E-e-有四个方法，我仔细分析一个" class="headerlink" title="1. add(E e)__有四个方法，我仔细分析一个"></a>1. add(E e)__有四个方法，我仔细分析一个</h3><p><img src="https://img-blog.csdnimg.cn/20210426202153250.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210426202552968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=3>1. add(E e) 默认直接在末尾添加元素</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加指定的元素到ArrayList的最后位置</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">      <span class="comment">//确定ArrayList的容量大小  size是当前集合元素的个数</span></span><br><span class="line">      <span class="comment">// 若第一次 size肯定是0 minCapacity=1  +1是未来判断新加进来的元素是否有位置可以存下来</span></span><br><span class="line">      ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">//确保容量充足 进行元素添加</span></span><br><span class="line">      elementData[size++] = e;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="2-ensureCapacityInternal-size-1-确定内部容量的方法"><a href="#2-ensureCapacityInternal-size-1-确定内部容量的方法" class="headerlink" title="2. ensureCapacityInternal(size + 1) 确定内部容量的方法"></a>2. ensureCapacityInternal(size + 1) 确定内部容量的方法</h3><blockquote><p><font color='red' size=3>2. ensureCapacityInternal(size + 1) 确定内部容量的方法　　　</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210426202503847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//确保内部容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//calculateCapacity()判断是否走的是空参构造函数 DEFAULTCAPACITY_EMPTY_ELEMENTDATA  将容量初始为10</span></span><br><span class="line">    <span class="comment">//ensureExplicitCapacity判断容量是否要进行扩容 并且modCount++</span></span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-calculateCapacity-主要看list是不是初始的时候是空参构造函数"><a href="#3-calculateCapacity-主要看list是不是初始的时候是空参构造函数" class="headerlink" title="3. calculateCapacity() 主要看list是不是初始的时候是空参构造函数"></a>3. calculateCapacity() 主要看list是不是初始的时候是空参构造函数</h3><blockquote><p><font color='red' size=3>3. calculateCapacity()判断是否走的是空参构造函数，走空参将容量初始为10</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210426202647227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DEFAULTCAPACITY_EMPTY_ELEMENTDATA 主要是这个 默认容量空元素数据</span></span><br><span class="line"><span class="comment">//这个返回主要是看list是不是初始的时候是调用的空参构造函数 ====&gt;ArrayList list = new ArrayList(); DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//如果没有指定初始化容量，第一次调用add()方法，会初始化容量为10</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">//直接返回minCapacity默认容量10 和传入的最小容量取最大值</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若不是第一次添加直接返回minCapacity 也就是数组的大小+1</span></span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-还是确保明确的容量-ensureExplicitCapacity-int-minCapacity"><a href="#4-还是确保明确的容量-ensureExplicitCapacity-int-minCapacity" class="headerlink" title="4. 还是确保明确的容量 ensureExplicitCapacity(int minCapacity)"></a>4. 还是确保明确的容量 ensureExplicitCapacity(int minCapacity)</h3><blockquote><p><font color='red' size=3>4.还是确保明确的容量 ensureExplicitCapacity(int minCapacity)</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210426203004545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//还是确保明确的容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 将“修改统计数”+1，该变量主要是用来实现fail-fast机制的</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 防止溢出代码：确保指定的最小容量 &gt; 数组缓冲区当前的长度</span></span><br><span class="line">    <span class="comment">//若当前集合的最小容量超过数据的长度 需要进行扩容</span></span><br><span class="line">    <span class="comment">//比如第一次添加&amp;&amp;elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA ==&gt; minCapacity=10</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-grow-int-minCapacity-扩容机制——重点-看我的注释"><a href="#5-grow-int-minCapacity-扩容机制——重点-看我的注释" class="headerlink" title="5. grow(int minCapacity) 扩容机制——重点(看我的注释)"></a>5. grow(int minCapacity) 扩容机制——重点(看我的注释)</h3><blockquote><p><font color='red' size=3>5. grow(int minCapacity) 扩容机制——重点</p><p><img src="https://img-blog.csdnimg.cn/20210426203243701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扩容,以确保 ArrayList 至少能存储 minCapacity 个元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算出老的数组的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">//扩充当前容量为老的数组容量1.5倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 若扩充后newCapacity 还是小于 添加元素时候传进来的容量 minCapacity</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//直接将minCapacity直接赋值新的容量 newCapacity</span></span><br><span class="line">        <span class="comment">//若是第一次 newCapacity = minCapacity=10</span></span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 若扩充后的newCapacity 大于最大存储容量，则进行大容量分配</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">//将数组元素进行copy 长度为 newCapacity</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-hugeCapacity-大容量分配，最大分配-Integer-MAX-VALUE"><a href="#6-hugeCapacity-大容量分配，最大分配-Integer-MAX-VALUE" class="headerlink" title="6.hugeCapacity()大容量分配，最大分配 Integer.MAX_VALUE"></a>6.hugeCapacity()大容量分配，最大分配 Integer.MAX_VALUE</h3><blockquote><p><font color='red' size=3>6.hugeCapacity()大容量分配，最大分配 Integer.MAX_VALUE</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210426203738898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组缓冲区最大存储容量</span></span><br><span class="line"><span class="comment"> * - 一些 VM 会在一个数组中存储某些数据---&gt;为什么要减去 8 的原因</span></span><br><span class="line"><span class="comment"> * - 尝试分配这个最大存储容量，可能会导致 OutOfMemoryError(当该值 &gt; VM 的限制时)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大容量分配，最大分配 Integer.MAX_VALUE</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//越界直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="comment">//Integer.MAX_VALUE - 8;</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-分析一波ArrayList构造函数不传容量的情况"><a href="#7-分析一波ArrayList构造函数不传容量的情况" class="headerlink" title="7.分析一波ArrayList构造函数不传容量的情况"></a>7.分析一波ArrayList构造函数不传容量的情况</h3><blockquote><p><font color='red' size=3>7.分析一波ArrayList构造函数不传容量的情况</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 不传容量参数,直接走空参构造方法</span></span><br><span class="line">　List&lt;Integer&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">　　lists.add(<span class="number">8</span>);</span><br><span class="line">　　</span><br><span class="line">　　<span class="comment">//2. 走空参构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">//3. 添加元素的时候 进行判断==&gt;空参直接使用默认容量10</span></span><br><span class="line">  <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           <span class="comment">//直接返回minCapacity默认容量10 和传入的最小容量取最大值</span></span><br><span class="line">           <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210426204502796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>在add方法之前elementData &#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA。调用add方法时进行判断初始化默认容量为10，之后再返回到add函数，把8放在elementData[0]中</li></ul><h3 id="8-分析一波ArrayList构造函数传一个容量的情况或者传0情况"><a href="#8-分析一波ArrayList构造函数传一个容量的情况或者传0情况" class="headerlink" title="8.分析一波ArrayList构造函数传一个容量的情况或者传0情况"></a>8.分析一波ArrayList构造函数传一个容量的情况或者传0情况</h3><blockquote><p><font color='red' size=3>8.分析一波ArrayList构造函数传一个容量的情况或者传0情况</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 传一个初始化容量参数6</span></span><br><span class="line">　List&lt;Integer&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(<span class="number">6</span>);</span><br><span class="line">　　lists.add(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//2. 创建一个初试容量的、空的ArrayList arraylist并不是懒加载机制</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//大于0 直接创建一个对象数组</span></span><br><span class="line">          <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">           <span class="comment">//传0 是直接赋值 EMPTY_ELEMENTDATA</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 当出现这个情况 ArrayList list = new ArrayList(0);和直接不传是不一样的</span></span><br><span class="line">          <span class="comment">//传0 是直接赋值 EMPTY_ELEMENTDATA</span></span><br><span class="line">          <span class="comment">//不传 是直接赋值 DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line">          <span class="comment">//初始化容量为0 的时候 直接返回 EMPTY_ELEMENTDATA 空元素数据</span></span><br><span class="line">          <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                             initialCapacity);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210426205321270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>我们可以知道，在调用add方法之前，elementData的大小已经为6，之后再进行传递，不会进行扩容处理。</li><li>正常情况下会扩容1.5倍，特殊情况下（新扩展数组大小已经达到了最大值）则只取最大值。</li></ul><h3 id="9-remove-删除方法"><a href="#9-remove-删除方法" class="headerlink" title="9. remove() 删除方法"></a>9. remove() 删除方法</h3><blockquote><p><font color='red' size=3>9.remove(int index)    移除指定位置下标的元素</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210426205756457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除指定位置下标的元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 判断索引是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">//2. 增加修改的次数</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//3. 保存要删除的元素为oldValue</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    <span class="comment">//4. 将指定位置index+1往后的元素都向前移动一位，覆盖需要删除的元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 再进行数组copy</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 将最后一个元素置空</span></span><br><span class="line">    elementData[--size] = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 返回删除的元素</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-remove-Object-o-移除list中指定的第一个元素"><a href="#10-remove-Object-o-移除list中指定的第一个元素" class="headerlink" title="10.remove(Object o)  移除list中指定的第一个元素"></a>10.remove(Object o)  移除list中指定的第一个元素</h3><blockquote><p><font color='red' size=3>10.remove(Object o)  移除list中指定的第一个元素</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210426210028571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除list中指定的第一个元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果包含null这个元素，index 之后的所有元素依次左移一位</span></span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="comment">//通过元素 计算出下标</span></span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                <span class="comment">//如果包含这个元素，index 之后的所有元素依次左移一位</span></span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-fastRemove-int-index-传入下标进行删除当前index下标位置的元素"><a href="#11-fastRemove-int-index-传入下标进行删除当前index下标位置的元素" class="headerlink" title="11.fastRemove(int index) 传入下标进行删除当前index下标位置的元素"></a>11.fastRemove(int index) 传入下标进行删除当前index下标位置的元素</h3><blockquote><p><font color='red' size=3>11.fastRemove(int index) 传入下标进行删除当前index下标位置的元素</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210426210705515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入下标进行删除当前index下标位置的元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//移动的个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//将index后面的元素移动前面来 index位置的元素就是在最后一个位置</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">//将最后一个元素删除</span></span><br><span class="line">    elementData[--size] = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-get-int-index-直接获取下标的位置的值"><a href="#12-get-int-index-直接获取下标的位置的值" class="headerlink" title="12.get(int index) 直接获取下标的位置的值"></a>12.get(int index) 直接获取下标的位置的值</h3><blockquote><p><font color='red' size=3>12.get(int index) 直接获取下标的位置的值</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210426210254433.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接获取下标的位置的值</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line"><span class="comment">//检查范围</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">//直接返回</span></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-clear-将elementData中每个元素都赋值为null，等待垃圾回收将这个给回收掉"><a href="#13-clear-将elementData中每个元素都赋值为null，等待垃圾回收将这个给回收掉" class="headerlink" title="13.clear 将elementData中每个元素都赋值为null，等待垃圾回收将这个给回收掉"></a>13.clear 将elementData中每个元素都赋值为null，等待垃圾回收将这个给回收掉</h3><blockquote><p><font color='red' size=3>13.clear 将elementData中每个元素都赋值为null，等待垃圾回收将这个给回收掉</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210426210435838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除list中的所有元素，这个list表将在调用之后置空</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="literal">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h1><ol><li>arrayList可以存放null</li><li>arrayList本质上就是一个elementData数组。</li><li>arrayList区别于数组的地方在于能够自动扩展大小，其中关键的方法就是gorw()方法。</li><li>arrayList中removeAll(collection c)和clear()的区别就是removeAll可以删除批量指定的元素，而clear是全是删除集合中的元素。</li><li>arrayList由于本质是数组，所以它在数据的查询方面会很快，而在插入删除这些方面，性能下降很多，有移动很多数据才能达到应有的效果</li><li>arrayList实现了RandomAccess，所以在遍历它的时候推荐使用for循环。</li><li>主要是分析构造参数是否进行了传参，这里要判断是否要使用默认的容量10</li></ol><blockquote><p><font color='red' size=4> 补充一个添加元素add整个的流程</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210426211715505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> 补充一个删除元素remove整个的流程</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210426211837389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> Java集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap----JDK1.8源码分析</title>
      <link href="/2021/04/16/HashMap/"/>
      <url>/2021/04/16/HashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="一-HashMap数据结构"><a href="#一-HashMap数据结构" class="headerlink" title="一. HashMap数据结构"></a>一. HashMap数据结构</h1><ul><li>hashMap的数据结构由<code>数组+链表+红黑树</code>构成，当链表的长度大于等于8，并且数组长度大于64，转换成红黑树，红黑树节点转换链表节点是6个节点作为临界值。</li><li>使用这个是数据结构了提升在 hash 冲突严重时（链表过长）的查找性能，使用链表的查找性能是 O(n)，而使用红黑树是 O(logn)。</li><li>对于插入，默认情况下是使用链表节点。当同一个索引位置的节点在新增后达到9个（阈值8）：如果此时数组长度大于等于 64，则会触发链表节点转红黑树节点（treeifyBin）；而如果数组长度小于64，则不会触发链表转红黑树，而是会进行扩容，因为此时的数据量还比较小。</li><li>对于移除，当同一个索引位置的节点在移除后达到 6 个，并且该索引位置的节点为红黑树节点，会触发红黑树节点转链表节点（untreeify）。<br><img src="https://img-blog.csdnimg.cn/20210228165601974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h1 id="二-HashMap的基本属性"><a href="#二-HashMap的基本属性" class="headerlink" title="二. HashMap的基本属性"></a>二. HashMap的基本属性</h1><p><img src="https://img-blog.csdnimg.cn/20210720102608807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">//序列号,序列化的时候使用。</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br><span class="line"> <span class="comment">//默认容量16</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"> <span class="comment">//最大容量,2的30次方。</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"> <span class="comment">//默认负载因子0.75 用于扩容使用。</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"> <span class="comment">//链表节点转为红黑树节点的阈值 8个节点转</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"> <span class="comment">//红黑树节点转换链表节点的阈值 6个节点转</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"> <span class="comment">// 转红黑树时 table 的最小长度</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"> <span class="comment">//存储元素的数组，transient关键字表示该属性不能被序列化</span></span><br><span class="line"> <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"> <span class="comment">//将数据转换成set的另一种存储形式，这个变量主要用于迭代功能。</span></span><br><span class="line"> <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"> <span class="comment">//hashmap中元素数量</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"> <span class="comment">//统计该map修改的次数</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"><span class="comment">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class="line"> <span class="type">int</span> threshold;</span><br><span class="line"> <span class="comment">//填充因子</span></span><br><span class="line"> <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h1 id="三-HashMap构造函数"><a href="#三-HashMap构造函数" class="headerlink" title="三. HashMap构造函数"></a>三. HashMap构造函数</h1><p><img src="https://img-blog.csdnimg.cn/20210720103330104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始容量+加载因子构造函数 hashmap构造函数懒加载 只有put元素的时候 才会去创建数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="comment">//判断初始容量是否越界</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="comment">//将加载因子进行全局变量赋值</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//tableSizeFor(initialCapacity)返回大于等于initialCapacity的最小的二次幂数值。</span></span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置初始容量,使用默认的加载因子0.75</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap实行了懒加载, 新建HashMap时不会对table进行赋值, 而是到第一次插入时, 进行resize时构建table;</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//0.75</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数是一个Map</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="comment">//使用默认的加载因子0.75</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四-tableSizeFor-initialCapacity"><a href="#四-tableSizeFor-initialCapacity" class="headerlink" title="四. tableSizeFor(initialCapacity)"></a>四. tableSizeFor(initialCapacity)</h1><ul><li>返回大于等于initialCapacity的最小的二次幂数值。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210720103523199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找出和cap最近的2的幂的数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五-HashMap里的put-方法存储键值对"><a href="#五-HashMap里的put-方法存储键值对" class="headerlink" title="五. HashMap里的put()方法存储键值对"></a>五. HashMap里的put()方法存储键值对</h1><p><img src="https://img-blog.csdnimg.cn/2021072010565983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4>HashMap的数据存储实现原理</p></blockquote><ul><li><p>根据key计算得到key.hash &#x3D; (h &#x3D; k.hashCode()) ^ (h &gt;&gt;&gt; 16)；</p></li><li><p>根据key.hash计算得到桶数组的索引index &#x3D; key.hash &amp; (table.length - 1)，这样就找到该key的存放位置了：</p><ul><li><p>① 如果该位置没有数据，用该数据新生成一个节点保存新数据，返回null；</p></li><li><p>② 如果该位置有数据是一个红黑树，那么执行相应的插入 &#x2F; 更新操作；</p></li><li><p>③ 如果该位置有数据是一个链表，分两种情况一是该链表没有这个节点，另一个是该链表上有这个节点，注意这里判断的依据是key.hash是否一样：</p><ul><li>如果该链表没有这个节点，那么采用尾插法新增节点保存新数据，返回null；如果该链表已经有这个节点了，那么找到该节点并更新新数据，返回老数据。</li></ul></li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20210720103613698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//put() 存储键值对  linkedHashMap也是调用这个方法</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">//直接调putVal() 传入hash(key)以后的值 使用hash(key) 作为table的下标值 i = (n - 1) &amp; hash</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="①-HashMap里的putVal-方法存储键值对"><a href="#①-HashMap里的putVal-方法存储键值对" class="headerlink" title="①.   HashMap里的putVal()方法存储键值对"></a>①.   HashMap里的putVal()方法存储键值对</h2><p><img src="https://img-blog.csdnimg.cn/2021072010373591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//数组+链表+红黑树</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 1. 校验table是否为空或者length等于0，如果是则调用resize方法进行初始化table</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//resize()方法 扩容之后返回一个新的Node[]数组</span></span><br><span class="line">        <span class="comment">//n为数组tab的长度</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 2. 通过hash值计算索引位置，将该索引位置的头节点赋值给p，如果p为空则直接在该索引位置新增一个节点即可</span></span><br><span class="line">    <span class="comment">//  差不多就是计算hash%n</span></span><br><span class="line">    <span class="comment">//若计算出的下标i table[i]为空 直接newNode()</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//newNode()方法 链表的头结点</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//否则进行hash key 的对比</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3.table表该索引位置不为空，则进行查找 p是头结点</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 4.判断p节点是否为TreeNode, 如果是则调用红黑树的putTreeVal方法查找目标节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">//将键值对存入红黑树中 putTreeVal()</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 5.走到这代表p节点为普通链表节点，则调用普通的链表方法进行查找，使用binCount统计链表的节点数</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//当遍历到链表为空的时候</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 1. hashmap中在链表的末尾创建新的节点</span></span><br><span class="line">                    <span class="comment">// 2. linkedhashMap重写了newNode节点 转为双向链表</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 7.校验节点数是否超过8个，如果超过则调用treeifyBin方法将链表节点转为红黑树节点，</span></span><br><span class="line">                    <span class="comment">// 减一是因为循环是从p节点的下一个节点开始的</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// 8-1</span></span><br><span class="line">                        <span class="comment">//链表转红黑树treeifyBin()</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 8.如果e节点存在hash值和key值都与传入的相同，则e节点即为目标节点，跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 将p指向下一个节点</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 9.如果e节点不为空，则代表目标节点存在，使用传入的value覆盖该节点的value，并返回oldValue</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 用于LinkedHashMap</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 10.如果插入节点后节点数超过阈值，则调用resize方法进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        <span class="comment">//resize()扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 用于LinkedHashMap</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="②-HashMap里的putTreeVal-方法红黑树存储键值对"><a href="#②-HashMap里的putTreeVal-方法红黑树存储键值对" class="headerlink" title="②. HashMap里的putTreeVal()方法红黑树存储键值对"></a>②. HashMap里的putTreeVal()方法红黑树存储键值对</h2><p><img src="https://img-blog.csdnimg.cn/20210720103932845.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210720104149767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红黑树的put操作，红黑树插入会同时维护原来的链表属性, 即原来的next属性</span></span><br><span class="line">        <span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="type">int</span> h, K k, V v)</span> &#123;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">searched</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 1.查找根节点, 索引位置的头节点并不一定为红黑树的根节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; root = (parent != <span class="literal">null</span>) ? root() : <span class="built_in">this</span>;</span><br><span class="line">            <span class="comment">// 2.将根节点赋值给p节点，开始进行查找</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="type">int</span> dir, ph; K pk;</span><br><span class="line">                <span class="comment">// 3.如果传入的hash值小于p节点的hash值，将dir赋值为-1，代表向p的左边查找树</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 4.如果传入的hash值大于p节点的hash值， 将dir赋值为1，代表向p的右边查找树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 5.如果传入的hash值和key值等于p节点的hash值和key值, 则p节点即为目标节点, 返回p节点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="literal">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="comment">// 6.如果k所属的类没有实现Comparable接口 或者 k和p节点的key相等</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 6.1 第一次符合条件, 从p节点的左节点和右节点分别调用find方法进行查找, 如果查找到目标节点则返回</span></span><br><span class="line">                    <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (((ch = p.left) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="literal">null</span>) ||</span><br><span class="line">                            ((ch = p.right) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="literal">null</span>))</span><br><span class="line">                            <span class="keyword">return</span> q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 6.2 否则使用定义的一套规则来比较k和p节点的key的大小, 用来决定向左还是向右查找</span></span><br><span class="line">                    dir = tieBreakOrder(k, pk);<span class="comment">// dir&lt;0则代表k&lt;pk，则向p左边查找；反之亦然</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// xp赋值为x的父节点,中间变量,用于下面给x的父节点赋值</span></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="comment">// 7.dir&lt;=0则向p左边查找,否则向p右边查找,如果为null,则代表该位置即为x的目标位置</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 走进来代表已经找到x的位置，只需将x放到该位置即可</span></span><br><span class="line">                    Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                    <span class="comment">// 8.创建新的节点, 其中x的next节点为xpn, 即将x节点插入xp与xpn之间</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                    <span class="comment">// 9.调整x、xp、xpn之间的属性关系</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)<span class="comment">// 如果时dir &lt;= 0, 则代表x节点为xp的左节点</span></span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span>         <span class="comment">// 如果时dir &gt; 0, 则代表x节点为xp的右节点</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    <span class="comment">// 将xp的next节点设置为x</span></span><br><span class="line">                    xp.next = x;</span><br><span class="line">                    x.parent = x.prev = xp;</span><br><span class="line">                    <span class="comment">// 如果xpn不为空,则将xpn的prev节点设置为x节点,与上文的x节点的next节点对应</span></span><br><span class="line">                    <span class="keyword">if</span> (xpn != <span class="literal">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                    <span class="comment">// 10.进行红黑树的插入平衡调整</span></span><br><span class="line">                    moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="③-HashMap里红黑树中的tieBreakOrder-方法"><a href="#③-HashMap里红黑树中的tieBreakOrder-方法" class="headerlink" title="③.  HashMap里红黑树中的tieBreakOrder()方法"></a>③.  HashMap里红黑树中的tieBreakOrder()方法</h2><p><img src="https://img-blog.csdnimg.cn/20210720104103990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于不可比较或者hashCode相同时进行比较的方法, 只是一个一致的插入规则，用来维护重定位的等价性。</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">tieBreakOrder</span><span class="params">(Object a, Object b)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span> ||</span><br><span class="line">        (d = a.getClass().getName().</span><br><span class="line">         compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">        d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">             -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="④-HashMap里的treeifyBin-方法链表转红黑树"><a href="#④-HashMap里的treeifyBin-方法链表转红黑树" class="headerlink" title="④. HashMap里的treeifyBin()方法链表转红黑树"></a>④. HashMap里的treeifyBin()方法链表转红黑树</h2><p><img src="https://img-blog.csdnimg.cn/20210720104322489.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210720104333532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将链表节点转为红黑树节点</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">       <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">       <span class="comment">// 1.如果table为空或者table的长度小于64, 调用resize方法进行扩容</span></span><br><span class="line">       <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) <span class="comment">//转红黑树时 table 的最小长度64</span></span><br><span class="line">           resize();</span><br><span class="line">       <span class="comment">// 2.根据hash值计算索引值，将该索引位置的节点赋值给e，从e开始遍历该索引位置的链表</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">           TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 3.将链表节点转红黑树节点</span></span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               <span class="comment">//将Node节点转为TreeNode节点</span></span><br><span class="line">               TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">               <span class="comment">// 4.如果是第一次遍历，将头节点赋值给hd</span></span><br><span class="line">               <span class="keyword">if</span> (tl == <span class="literal">null</span>) <span class="comment">// tl为空代表为第一次循环</span></span><br><span class="line">                   hd = p;</span><br><span class="line">               <span class="comment">// 5.如果不是第一次遍历，则处理当前节点的prev属性和上一个节点的next属性</span></span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   p.prev = tl;</span><br><span class="line">                   tl.next = p;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 6.将p节点赋值给tl，用于在下一次循环中作为上一个节点进行一些链表的关联操作（p.prev = tl 和 tl.next = p）</span></span><br><span class="line">               tl = p;</span><br><span class="line">           &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">           <span class="comment">// 7.将table该索引位置赋值为新转的TreeNode的头节点，如果该节点不为空，则以以头节点(hd)为根节点, 构建红黑树treeify()</span></span><br><span class="line">           <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">               <span class="comment">//treeify()使用数组tab[Node&lt;key,value&gt;] 构建红黑树</span></span><br><span class="line">               hd.treeify(tab);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="⑤-HashMap里的treeify-方法构建红黑树"><a href="#⑤-HashMap里的treeify-方法构建红黑树" class="headerlink" title="⑤. HashMap里的treeify()方法构建红黑树"></a>⑤. HashMap里的treeify()方法构建红黑树</h2><p><img src="https://img-blog.csdnimg.cn/20210720104413215.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210720104422620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建红黑树</span></span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> &#123;</span><br><span class="line">     TreeNode&lt;K,V&gt; root = <span class="literal">null</span>;</span><br><span class="line">     <span class="comment">// 1.将调用此方法的节点hd赋值给x，以x作为起点，开始进行遍历</span></span><br><span class="line">     <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="built_in">this</span>, next; x != <span class="literal">null</span>; x = next) &#123;</span><br><span class="line">         <span class="comment">// next赋值为x的下个节点</span></span><br><span class="line">         next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">         <span class="comment">// 将x的左右节点设置为空</span></span><br><span class="line">         x.left = x.right = <span class="literal">null</span>;</span><br><span class="line">         <span class="comment">// 2.如果还没有根节点, 则将x设置为根节点</span></span><br><span class="line">         <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">             x.parent = <span class="literal">null</span>; <span class="comment">// 根节点没有父节点</span></span><br><span class="line">             x.red = <span class="literal">false</span>; <span class="comment">// 根节点必须为黑色</span></span><br><span class="line">             root = x; <span class="comment">// 将x设置为根节点</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//root不为空的时候</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> x.key; <span class="comment">// k赋值为x的key</span></span><br><span class="line">             <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> x.hash; <span class="comment">// h赋值为x的hash值</span></span><br><span class="line">             Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line">             <span class="comment">// 3.如果当前节点x不是根节点, 则从根节点开始查找属于该节点的位置</span></span><br><span class="line">             <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                 <span class="type">int</span> dir, ph;</span><br><span class="line">                 <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key;</span><br><span class="line">                 <span class="comment">// 4.如果x节点的hash值小于p节点的hash值，则将dir赋值为-1, 代表向p的左边查找</span></span><br><span class="line">                 <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                     dir = -<span class="number">1</span>;</span><br><span class="line">                 <span class="comment">// 5.如果x节点的hash值大于p节点的hash值，则将dir赋值为1, 代表向p的右边查找</span></span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                     dir = <span class="number">1</span>;</span><br><span class="line">                 <span class="comment">// 6.走到这代表x的hash值和p的hash值相等，则比较key值</span></span><br><span class="line">                     <span class="comment">// 6.1 如果k没有实现Comparable接口 或者 x节点的key和p节点的key相等</span></span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                           (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                          (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                     <span class="comment">// 6.2 使用定义的一套规则来比较x节点和p节点的大小，用来决定向左还是向右查找</span></span><br><span class="line">                     dir = tieBreakOrder(k, pk);</span><br><span class="line">                 <span class="comment">// xp赋值为x的父节点,中间变量用于下面给x的父节点赋值</span></span><br><span class="line">                 TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                 <span class="comment">// 7.dir&lt;=0则向p左边查找,否则向p右边查找,如果为null,则代表该位置即为x的目标位置</span></span><br><span class="line">                 <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">                     <span class="comment">// 8.x和xp节点的属性设置</span></span><br><span class="line">                     x.parent = xp; <span class="comment">// x的父节点即为最后一次遍历的p节点</span></span><br><span class="line">                     <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                         <span class="comment">// 如果时dir &lt;= 0, 则代表x节点为父节点的左节点</span></span><br><span class="line">                         xp.left = x;</span><br><span class="line">                     <span class="keyword">else</span></span><br><span class="line">                         <span class="comment">// 如果时dir &gt; 0, 则代表x节点为父节点的右节点</span></span><br><span class="line">                         xp.right = x;</span><br><span class="line">             <span class="comment">// 9.进行红黑树的插入平衡(通过左旋、右旋和改变节点颜色来保证当前树符合红黑树的要求)</span></span><br><span class="line">                     root = balanceInsertion(root, x);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 10.如果root节点不在table索引位置的头节点, 则将其调整为头节点</span></span><br><span class="line">     moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑥-HashMap里的moveRootToFront-方法将root放到头节点的位置"><a href="#⑥-HashMap里的moveRootToFront-方法将root放到头节点的位置" class="headerlink" title="⑥. HashMap里的moveRootToFront()方法将root放到头节点的位置"></a>⑥. HashMap里的moveRootToFront()方法将root放到头节点的位置</h2><p><img src="https://img-blog.csdnimg.cn/20210720104519417.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021072010453442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将root放到头节点的位置</span></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="keyword">void</span> <span class="title function_">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> &#123;</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line">            <span class="comment">// 1.校验root是否为空、table是否为空、table的length是否大于0</span></span><br><span class="line">            <span class="keyword">if</span> (root != <span class="literal">null</span> &amp;&amp; tab != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 2.计算root节点的索引位置</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">                TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">                <span class="comment">// 3.如果该索引位置的头节点不是root节点，则该索引位置的头节点替换为root节点</span></span><br><span class="line">                <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; rn;</span><br><span class="line">                    <span class="comment">// 3.1 将该索引位置的头节点赋值为root节点</span></span><br><span class="line">                    tab[index] = root;</span><br><span class="line">                    TreeNode&lt;K,V&gt; rp = root.prev; <span class="comment">// root节点的上一个节点</span></span><br><span class="line">                    <span class="comment">// 3.2 如果root节点的next节点不为空，则将root节点的next节点的prev属性设置为root节点的prev节点</span></span><br><span class="line">                    <span class="keyword">if</span> ((rn = root.next) != <span class="literal">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">                    <span class="comment">// 3.3 如果root节点的prev节点不为空，则将root节点的prev节点的next属性设置为root节点的next节点</span></span><br><span class="line">                    <span class="keyword">if</span> (rp != <span class="literal">null</span>)</span><br><span class="line">                        rp.next = rn;</span><br><span class="line">                    <span class="comment">// 3.4 如果原头节点不为空, 则将原头节点的prev属性设置为root节点</span></span><br><span class="line">                    <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">                        first.prev = root;</span><br><span class="line">                    <span class="comment">// 3.5 将root节点的next属性设置为原头节点</span></span><br><span class="line">                    root.next = first;</span><br><span class="line">                    <span class="comment">// 3.6 root此时已经被放到该位置的头节点位置，因此将prev属性设为空</span></span><br><span class="line">                    root.prev = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 4.该索引位置的头节点就是root节点,检查树是否正常</span></span><br><span class="line">                <span class="keyword">assert</span> <span class="title function_">checkInvariants</span><span class="params">(root)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="六-HashMap的get-方法"><a href="#六-HashMap的get-方法" class="headerlink" title="六.  HashMap的get()方法"></a>六.  HashMap的get()方法</h1><p><img src="https://img-blog.csdnimg.cn/20210720104803506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hashmap的get()分析</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 定义一个链表节点</span></span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//2. 通过key和hash以后的key获取值</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="①-通过hash函数进行计算索引的位置"><a href="#①-通过hash函数进行计算索引的位置" class="headerlink" title="①. 通过hash函数进行计算索引的位置"></a>①. 通过hash函数进行计算索引的位置</h2><p><img src="https://img-blog.csdnimg.cn/20210720104901744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过hash函数进行计算索引的位置</span></span><br><span class="line"><span class="comment">//当get的时候 还是通过这个计算找到table的位置 存的时候就是使用这个计算</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">//1.先拿到key的hashCode值</span></span><br><span class="line">    <span class="comment">//2.将hashCode后和hashcode的高16位进行异或运算</span></span><br><span class="line">    <span class="comment">//3. &gt;&gt;&gt; 右移在补码得基础上 高位补0</span></span><br><span class="line">    <span class="comment">//4. &gt;&gt; 右移补码得基础上 高位补符号位</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先获取对象的hashCode()值，然后将hashCode值右移16位，然后将右移后的值与原来的hashCode做异或运算，返回结果。（其中h&gt;&gt;&gt;16，在JDK1.8中，优化了高位运算的算法，使用了零扩展，无论正数还是负数，都在高位插入0）。</li><li>在putVal源码中，我们通过(n-1)&amp;hash获取该对象的键在hashmap中的位置。其中n表示的是hash桶数组的长度，并且该长度为2的n次方，这样(n-1)&amp;hash就等价于hash%n。因为&amp;运算的效率高于%运算。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210720105820910.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210720105846956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="②-hashmap的链表getNode-方法获取值"><a href="#②-hashmap的链表getNode-方法获取值" class="headerlink" title="②. hashmap的链表getNode()方法获取值"></a>②. hashmap的链表getNode()方法获取值</h2><p><img src="https://img-blog.csdnimg.cn/20210720104950165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取节点getNode()</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="comment">//1.对table进行效验 ：table不为空 &amp;&amp; table长度大于0 &amp;&amp;</span></span><br><span class="line">    <span class="comment">// table索引位置(使用table.length-1 和hash值进行位与计算)</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="comment">//i = (n - 1) &amp; hash</span></span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 检查first节点的hash值和key是否入参的一样,如果一样则first即为目标节点，直接返回first节点</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp;</span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 3.如果first不是目标节点，并且first的next节点e不为空则继续遍历</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.如果是红黑树节点，则调用红黑树的查找目标节点方法getTreeNode</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//调用红黑树的getTreeNode()方法获取值</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//do while 循环进行搜索</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 5.执行链表节点的查找，向下遍历链表, 直至找到节点的key和入参的key相等时,返回该节点</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                <span class="comment">//若有下一个节点 继续查找</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="③-Hashmap的红黑树getTreeNode-获取值"><a href="#③-Hashmap的红黑树getTreeNode-获取值" class="headerlink" title="③. Hashmap的红黑树getTreeNode()获取值"></a>③. Hashmap的红黑树getTreeNode()获取值</h2><p><img src="https://img-blog.csdnimg.cn/2021072010502919.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210720105040338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210228172019372.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在红黑树中获取节点</span></span><br><span class="line"> <span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">getTreeNode</span><span class="params">(<span class="type">int</span> h, Object k)</span> &#123;</span><br><span class="line">     <span class="comment">//1. 首先找到红黑树的根节点；</span></span><br><span class="line">     <span class="comment">//2. 再使用根节点调用find方法</span></span><br><span class="line">     <span class="keyword">return</span> ((parent != <span class="literal">null</span>) ? root() : <span class="built_in">this</span>).find(h, k, <span class="literal">null</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="④-Hashmap里的find-方法"><a href="#④-Hashmap里的find-方法" class="headerlink" title="④. Hashmap里的find()方法"></a>④. Hashmap里的find()方法</h2><p><img src="https://img-blog.csdnimg.cn/20210720105150573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//1. 从调用此方法的节点开始查找, 通过hash值和key找到对应的节点</span></span><br><span class="line">  <span class="comment">//2. 此方法是红黑树节点的查找, 红黑树是特殊的自平衡二叉查找树</span></span><br><span class="line">  <span class="comment">//3. 平衡二叉查找树的特点： 左节点&lt;根节点&lt;右节点</span></span><br><span class="line"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">find</span><span class="params">(<span class="type">int</span> h, Object k, Class&lt;?&gt; kc)</span> &#123;</span><br><span class="line">    <span class="comment">//1.将p节点赋值为调用此方法的节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">//2. 从p节点开始向下遍历</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">int</span> ph, dir; K pk;</span><br><span class="line">        TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">        <span class="comment">// 3.如果传入的hash值小于p节点的hash值，则往p节点的左边遍历</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="comment">// 4.如果传入的hash值大于p节点的hash值，则往p节点的右边遍历</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="comment">// 5.如果传入的hash值和key值等于p节点的hash值和key值,则p节点为目标节点,返回p节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="literal">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">// 6.p节点的左节点为空则将向右遍历</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="literal">null</span>)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="comment">// 7.p节点的右节点为空则向左遍历</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="literal">null</span>)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="comment">// 8.将p节点与k进行比较</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="literal">null</span> ||</span><br><span class="line">                  (kc = comparableClassFor(k)) != <span class="literal">null</span>) &amp;&amp;   <span class="comment">//kc不为空代表k实现了Comparable</span></span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>) <span class="comment">//k&lt;pk则dir&lt;0, k&gt;pk则dir&gt;0</span></span><br><span class="line">            p = (dir &lt; <span class="number">0</span>) ? pl : pr;  <span class="comment">//根据dir进行判断向哪一边搜索</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 9.代码走到此处, 代表key所属类没有实现Comparable, 直接指定向p的右边遍历</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = pl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑤-Hashmap里的comparableClassFor-方法"><a href="#⑤-Hashmap里的comparableClassFor-方法" class="headerlink" title="⑤.  Hashmap里的comparableClassFor()方法"></a>⑤.  Hashmap里的comparableClassFor()方法</h2><p><img src="https://img-blog.csdnimg.cn/20210720105233637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210720105244275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将key传进来判断是否实现了Comparable接口</span></span><br><span class="line"><span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">    <span class="comment">// 1.判断x是否实现了Comparable接口</span></span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">        Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;</span><br><span class="line">        <span class="comment">// 2.校验x是否为String类型</span></span><br><span class="line">        <span class="keyword">if</span> ((c = x.getClass()) == String.class)</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 3.遍历x实现的所有接口</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ts.length; ++i) &#123;</span><br><span class="line">                <span class="comment">// 4.如果x实现了Comparable接口，则返回x的Class</span></span><br><span class="line">                <span class="keyword">if</span> (((t = ts[i]) <span class="keyword">instanceof</span> ParameterizedType) &amp;&amp;</span><br><span class="line">                    ((p = (ParameterizedType)t).getRawType() ==</span><br><span class="line">                     Comparable.class) &amp;&amp;</span><br><span class="line">                    (as = p.getActualTypeArguments()) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                    as.length == <span class="number">1</span> &amp;&amp; as[<span class="number">0</span>] == c)</span><br><span class="line">                    <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七-HashMap里的resize-方法扩容"><a href="#七-HashMap里的resize-方法扩容" class="headerlink" title="七. HashMap里的resize()方法扩容"></a>七. HashMap里的resize()方法扩容</h1><ul><li><p>①. 计算新桶数组的容量 newCap 和新阈值 newThr</p></li><li><p>②. 根据计算出的 newCap 创建新的桶数组，桶数组 table 也是在这里进行初始化的</p></li><li><p>③. 将键值对节点重新映射到新的桶数组里。如果节点是 TreeNode 类型，则需要拆分红黑树。如果是普通节点，则节点按原顺序进行分组。</p></li><li><p>④. 如果e的hash值与旧表的容量进行&amp;与运算为0,则扩容后的索引位置跟旧表的索引位置一样。如果e的hash值与旧表的容量进行&amp;与运算为非0,则扩容后的索引位置为:旧表的索引位置＋oldCap。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210720112123456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210720105552992.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hashmap的扩容机制 重点重点</span></span><br><span class="line">   <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">       <span class="comment">//把没插入之前的哈希数组做我诶oldTal</span></span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       <span class="comment">//old的长度</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="comment">//old的阈值</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">       <span class="comment">//初始化new的长度和阈值</span></span><br><span class="line">       <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//oldCap &gt; 0也就是说不是首次初始化，因为hashMap用的是懒加载</span></span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 1.1 判断老表的容量是否超过最大容量值：如果超过则将阈值设置为Integer.MAX_VALUE，并直接返回老表,</span></span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 1.2 将newCap赋值为oldCap的2倍，如果newCap&lt;最大容量&amp;&amp;oldCap&gt;=16, 则将新阈值设置为原来的两倍</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               <span class="comment">//阈值也扩大到原来的两倍</span></span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//首次进行初始化扩容 走这里</span></span><br><span class="line">       <span class="comment">// 2.如果老表的容量为0, 老表的阈值大于0, 是因为初始容量被放入阈值，则将新表的容量设置为老表的阈值</span></span><br><span class="line">       <span class="comment">//这种情况走这里  HashMap hashMap = new HashMap(0);</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</span><br><span class="line">           <span class="comment">//将老的阈值赋给新的容量 感觉没啥逻辑感</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3.老表的容量为0, 老表的阈值为0，这种情况是没有传初始容量的new方法创建的空表，将阈值和容量设置为默认值</span></span><br><span class="line">       <span class="comment">// 这种情况只有 HashMap hashMap = new HashMap(); 不传参数的时候</span></span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//新表使用默认的容量值16</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           <span class="comment">//新的阈值 16*0.75=12</span></span><br><span class="line">           newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//进入这里可能就是 执行了上面的 (oldThr &gt; 0) 里面的阈值传给newCap 然后 newThr并没有执行</span></span><br><span class="line">       <span class="comment">// 4.如果新表的阈值为空, 则通过新的容量*负载因子获得阈值</span></span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 5.将当前阈值设置为刚计算出来的新的阈值，定义新表，容量为刚计算出来的新容量，将table设置为新定义的表。</span></span><br><span class="line">       threshold = newThr;</span><br><span class="line">       <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">           Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 6.如果老表不为空，则需遍历所有节点，将节点赋值给新表</span></span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="comment">// 将索引值为j的老表头节点赋值给e</span></span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// 将老表的节点设置为空, 以便垃圾收集器回收空间</span></span><br><span class="line">                   oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                   <span class="comment">// 7.如果e.next为空, 则代表老表的该位置只有1个节点，计算新表的索引位置, 直接将该节点放在该位置</span></span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="comment">// 8.如果是红黑树节点，则进行红黑树的重hash分布(跟链表的hash分布基本相同)</span></span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="comment">// 9.如果是普通的链表节点，则进行普通的重hash分布</span></span><br><span class="line">                   <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="comment">// 存储索引位置为:“原索引位置”的节点</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                       <span class="comment">// 存储索引位置为:“原索引位置+oldCap”的节点</span></span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="comment">// 9.1 如果e的hash值与旧表的容量进行与运算为0,则扩容后的索引位置跟旧表的索引位置一样</span></span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="comment">// 如果loTail为空, 代表该节点为第一个节点</span></span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                   <span class="comment">// 则将loHead赋值为第一个节点</span></span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   <span class="comment">// 否则将节点添加在loTail后面</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               <span class="comment">// 并将loTail赋值为新增的节点</span></span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">// 9.2 如果e的hash值与旧表的容量进行与运算为非0,则扩容后的索引位置为:旧表的索引位置＋oldCap</span></span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="comment">// 如果hiTail为空, 代表该节点为第一个节点</span></span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                   <span class="comment">// 则将hiHead赋值为第一个节点</span></span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   <span class="comment">// 否则将节点添加在hiTail后面</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               <span class="comment">// 并将hiTail赋值为新增的节点</span></span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                       <span class="comment">// 10.如果loTail不为空（说明老表的数据有分布到新表上“原索引位置”的节点），则将最后一个节点</span></span><br><span class="line">                       <span class="comment">// 的next设为空，并将新表上索引位置为“原索引位置”的节点设置为对应的头节点</span></span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                           loTail.next = <span class="literal">null</span>;</span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">// 11.如果hiTail不为空（说明老表的数据有分布到新表上“原索引+oldCap位置”的节点），则将最后</span></span><br><span class="line">                       <span class="comment">// 一个节点的next设为空，并将新表上索引位置为“原索引+oldCap”的节点设置为对应的头节点</span></span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 12.返回新表</span></span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=4> 将键值对节点重新映射到新的桶数组里</p></blockquote><ul><li>依次遍历链表，并计算节点 <strong>hash &amp; oldCap</strong> 的值。</li><li>如果值为0，将 loHead 和 loTail 指向这个节点。如果后面还有节点 hash &amp; oldCap 为0的话，则将节点链入 loHead 指向的链表中，并将 loTail 指向该节点。</li><li>如果值为非0的话，则让 hiHead 和 hiTail 指向该节点。完成遍历后，可能会得到两条链表，此时就完成了链表分组。</li><li>最后再将这两条链接存放到相应的桶中，完成扩容</li></ul><p><img src="https://img-blog.csdnimg.cn/20210720111407706.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210720111415204.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210720111441977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="①-HashMap里的split-方法红黑树的重-hash-分布"><a href="#①-HashMap里的split-方法红黑树的重-hash-分布" class="headerlink" title="①. HashMap里的split()方法红黑树的重 hash 分布"></a>①. HashMap里的split()方法红黑树的重 hash 分布</h2><blockquote><p><font color='red' size=4> 在扩容过程中，树化要满足两个条件</p></blockquote><ul><li>链表长度大于等于 TREEIFY_THRESHOLD</li><li>桶数组容量大于等于 MIN_TREEIFY_CAPACITY</li></ul><p><img src="https://img-blog.csdnimg.cn/20210720111532384.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210720111610269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> map 代表要扩容的HashMap</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> tab 代表新创建的数组，用来存放旧数组迁移的数据</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> index 代表旧数组的索引</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> bit 代表旧数组的长度，需要配合使用来做按位与运算</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">// split()方法的作用是将旧数组转移到新数组</span></span><br><span class="line">       <span class="comment">//这个方法在HashMap进行扩容时会调用到:  ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap)</span></span><br><span class="line">       <span class="comment">//扩容后，红黑树的hash分布，只可能存在于两个位置：原索引位置、原索引位置+oldCap</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="type">int</span> index, <span class="type">int</span> bit)</span> &#123;</span><br><span class="line">           <span class="comment">// 拿到调用此方法的节点</span></span><br><span class="line">           TreeNode&lt;K,V&gt; b = <span class="built_in">this</span>;</span><br><span class="line">           <span class="comment">// 存储索引位置为:“原索引位置”的节点</span></span><br><span class="line">           TreeNode&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">           <span class="comment">// 存储索引位置为:“原索引+oldCap”的节点</span></span><br><span class="line">           TreeNode&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">           <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">           <span class="comment">// 1.以调用此方法的节点开始，遍历整个红黑树节点</span></span><br><span class="line">           <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="literal">null</span>; e = next) &#123;</span><br><span class="line">               next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">               <span class="comment">// 同时将老表的节点设置为空，以便垃圾收集器回收</span></span><br><span class="line">               e.next = <span class="literal">null</span>;</span><br><span class="line">               <span class="comment">// 2.如果e的hash值与老表的容量进行与运算为0,则扩容后的索引位置跟老表的索引位置一样</span></span><br><span class="line">               <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="comment">// 如果loTail为空, 代表该节点为第一个节点</span></span><br><span class="line">                   <span class="keyword">if</span> ((e.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                       <span class="comment">// 则将loHead赋值为第一个节点</span></span><br><span class="line">                       loHead = e;</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                       <span class="comment">// 否则将节点添加在loTail后面</span></span><br><span class="line">                       loTail.next = e;</span><br><span class="line">                   <span class="comment">// 并将loTail赋值为新增的节点</span></span><br><span class="line">                   loTail = e;</span><br><span class="line">                   <span class="comment">// 统计原索引位置的节点个数</span></span><br><span class="line">                   ++lc;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//3.如果e的hash值与老表的容量进行与运算为非0,则扩容后的索引位置为:老表的索引位置＋oldCap</span></span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 如果hiHead为空, 代表该节点为第一个节点</span></span><br><span class="line">                   <span class="keyword">if</span> ((e.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                       <span class="comment">// 则将hiHead赋值为第一个节点</span></span><br><span class="line">                       hiHead = e;</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                       <span class="comment">// 否则将节点添加在hiTail后面</span></span><br><span class="line">                       hiTail.next = e;</span><br><span class="line">                   <span class="comment">// 并将hiTail赋值为新增的节点</span></span><br><span class="line">                   hiTail = e;</span><br><span class="line">                   <span class="comment">// 统计索引位置为原索引+oldCap的节点个数</span></span><br><span class="line">                   ++hc;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 4.如果原索引位置的节点不为空</span></span><br><span class="line">           <span class="keyword">if</span> (loHead != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 4.1 如果节点个数&lt;=6个则将红黑树转为链表结构</span></span><br><span class="line">               <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                   <span class="comment">//红黑树转链表</span></span><br><span class="line">                   tab[index] = loHead.untreeify(map);</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 4.2 将原索引位置的节点设置为对应的头节点</span></span><br><span class="line">                   tab[index] = loHead;</span><br><span class="line">                   <span class="comment">// 4.3 如果hiHead不为空，则代表原来的红黑树(老表的红黑树由于节点被分到两个位置)</span></span><br><span class="line">                   <span class="keyword">if</span> (hiHead != <span class="literal">null</span>)</span><br><span class="line">                       <span class="comment">// 4.4 以loHead为根节点, 构建新的红黑树</span></span><br><span class="line">                       loHead.treeify(tab);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 5.如果索引位置为原索引+oldCap的节点不为空</span></span><br><span class="line">           <span class="keyword">if</span> (hiHead != <span class="literal">null</span>) &#123;   <span class="comment">// 索引位置为原索引+oldCap的节点不为空</span></span><br><span class="line">               <span class="comment">// 5.1 如果节点个数&lt;=6个则将红黑树转为链表结构</span></span><br><span class="line">               <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                   tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 5.2 将索引位置为原索引+oldCap的节点设置为对应的头节点</span></span><br><span class="line">                   tab[index + bit] = hiHead;</span><br><span class="line">                   <span class="comment">// 5.3 loHead不为空则代表原来的红黑树(老表的红黑树由于节点被分到两个位置)</span></span><br><span class="line">                   <span class="keyword">if</span> (loHead != <span class="literal">null</span>)</span><br><span class="line">                       <span class="comment">// 5.4 以hiHead为根节点, 构建新的红黑树</span></span><br><span class="line">                       hiHead.treeify(tab);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><ul><li>从源码上可以看得出，重新映射红黑树的逻辑和重新映射链表的逻辑基本一致。不同的地方在于，重新映射后，会将红黑树拆分成两条由 TreeNode 组成的链表。如果链表长度小于 UNTREEIFY_THRESHOLD，则将链表转换成普通链表。否则根据条件重新将 TreeNode 链表树化。</li></ul><h2 id="②-HashMap里的untreeify-方法红黑树节点转为链表节点"><a href="#②-HashMap里的untreeify-方法红黑树节点转为链表节点" class="headerlink" title="②. HashMap里的untreeify()方法红黑树节点转为链表节点"></a>②. HashMap里的untreeify()方法红黑树节点转为链表节点</h2><p><img src="https://img-blog.csdnimg.cn/20210720111708373.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210720111729938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红黑树转链表 当节点&lt;=6个时会被触发</span></span><br><span class="line">       <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> &#123;</span><br><span class="line">           <span class="comment">// hd指向头节点, tl指向尾节点</span></span><br><span class="line">           Node&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">           <span class="comment">//1.从调用该方法的节点, 即链表的头节点开始遍历, 将所有节点全转为链表节点</span></span><br><span class="line">           <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="built_in">this</span>; q != <span class="literal">null</span>; q = q.next) &#123;</span><br><span class="line">               <span class="comment">// 2.调用replacementNode方法构建链表节点</span></span><br><span class="line">               Node&lt;K,V&gt; p = map.replacementNode(q, <span class="literal">null</span>);</span><br><span class="line">               <span class="comment">// 3.如果tl尾节点为null, 则代表当前节点为第一个节点, 将hd赋值为该节点</span></span><br><span class="line">               <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                   hd = p;</span><br><span class="line">               <span class="comment">// 4.否则, 将尾节点的next属性设置为当前节点p</span></span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   tl.next = p;</span><br><span class="line">               <span class="comment">// 5.每次都将tl节点指向当前节点, 即尾节点</span></span><br><span class="line">               tl = p;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 6.返回转换后的链表的头节点</span></span><br><span class="line">           <span class="keyword">return</span> hd;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h1 id="八-HashMap里的remove-方法移除某个节点"><a href="#八-HashMap里的remove-方法移除某个节点" class="headerlink" title="八. HashMap里的remove()方法移除某个节点"></a>八. HashMap里的remove()方法移除某个节点</h1><ul><li>HashMap 的删除操作并不复杂，仅需三个步骤即可完成。第一步是定位桶位置，第二步遍历链表并找到键值相等的节点，第三步删除节点。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210720112300631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除某个节点 remove()</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//直接调用removeNode()</span></span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">        <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="①-HashMap里的removeNode-方法移除某个节点"><a href="#①-HashMap里的removeNode-方法移除某个节点" class="headerlink" title="①.  HashMap里的removeNode()方法移除某个节点"></a>①.  HashMap里的removeNode()方法移除某个节点</h2><p><img src="https://img-blog.csdnimg.cn/20210720112331728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除节点</span></span><br><span class="line">    <span class="comment">// linkedhashMap也是使用的这个方法 本身未重写</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value, <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">        <span class="comment">// 1.如果table不为空并且根据hash值计算出来的索引位置不为空, 将该位置的节点赋值给p</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">            <span class="comment">// 2.如果p的hash值和key都与入参的相同, 则p即为目标节点, 赋值给node</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line">            <span class="comment">// 3.否则将p.next赋值给e，向下遍历节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 3.1 如果p是TreeNode则调用红黑树的方法查找节点</span></span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 3.2 否则，进行普通链表节点的查找</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="comment">// 当节点的hash值和key与传入的相同,则该节点即为目标节点</span></span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e; <span class="comment">// 赋值给node, 并跳出循环</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// p节点赋值为本次结束的e，在下一次循环中，e为p的next节点</span></span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.如果node不为空(即根据传入key和hash值查找到目标节点)，则进行移除操作</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value || (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)            <span class="comment">// 4.1 如果是TreeNode则调用红黑树的移除方法</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">                <span class="comment">// 4.2 如果node是该索引位置的头节点则直接将该索引位置的值赋值为node的next节点，</span></span><br><span class="line">                <span class="comment">// “node == p”只会出现在node是头节点的时候，如果node不是头节点，则node为p的next节点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="comment">// 4.3 否则将node的上一个节点的next属性设置为node的next节点,</span></span><br><span class="line">                <span class="comment">// 即将node节点移除, 将node的上下节点进行关联(链表的移除)</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                <span class="comment">// 供LinkedHashMap使用</span></span><br><span class="line">                <span class="comment">//调用删除回调方法进行后续操作</span></span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="comment">// 5.返回被移除的节点</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若不存在返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="②-HashMap里的removeTreeNode-方法红黑树中移除某个节点"><a href="#②-HashMap里的removeTreeNode-方法红黑树中移除某个节点" class="headerlink" title="②.  HashMap里的removeTreeNode()方法红黑树中移除某个节点"></a>②.  HashMap里的removeTreeNode()方法红黑树中移除某个节点</h2><p><img src="https://img-blog.csdnimg.cn/20210720112558102.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210720112623567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//红黑树中删除一个节点</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">//链表的操作</span></span><br><span class="line">    <span class="comment">// 1.table为空或者length为0直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 2.根据hash计算出索引的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">    <span class="comment">// 3.将索引位置的头节点赋值给first和root</span></span><br><span class="line">    TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">    <span class="comment">// 4.该方法被将要被移除的node(TreeNode)调用, 因此此方法的this为要被移除node节点,</span></span><br><span class="line">    <span class="comment">// 将node的next节点赋值给succ节点，prev节点赋值给pred节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">    <span class="comment">// 5.如果pred节点为空，则代表要被移除的node节点为头节点，</span></span><br><span class="line">    <span class="comment">// 则将table索引位置的值和first节点的值赋值为succ节点(node的next节点)即可</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">        tab[index] = first = succ;</span><br><span class="line">        <span class="comment">// 6.否则将pred节点的next属性设置为succ节点(node的next节点)</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = succ;</span><br><span class="line">    <span class="comment">// 7.如果succ节点不为空，则将succ的prev节点设置为pred, 与前面对应</span></span><br><span class="line">    <span class="keyword">if</span> (succ != <span class="literal">null</span>)</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    <span class="comment">// 8.如果进行到此first节点为空，则代表该索引位置已经没有节点则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (first == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 9.如果root的父节点不为空, 则将root赋值为根节点</span></span><br><span class="line">    <span class="keyword">if</span> (root.parent != <span class="literal">null</span>)</span><br><span class="line">        root = root.root();</span><br><span class="line">    <span class="comment">// 10.通过root节点来判断此红黑树是否太小, 如果是则调用untreeify方法转为链表节点并返回</span></span><br><span class="line">    <span class="comment">// (转链表后就无需再进行下面的红黑树处理)</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || root.right == <span class="literal">null</span> ||</span><br><span class="line">            (rl = root.left) == <span class="literal">null</span> || rl.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//红黑树的操作</span></span><br><span class="line">    <span class="comment">// 11.将p赋值为要被移除的node节点，pl赋值为p的左节点，pr赋值为p 的右节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="built_in">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">    <span class="comment">// 12.如果p的左节点和右节点都不为空时</span></span><br><span class="line">    <span class="keyword">if</span> (pl != <span class="literal">null</span> &amp;&amp; pr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 12.1 将s节点赋值为p的右节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">        <span class="comment">// 12.2 向左一直查找，跳出循环时,s为没有左节点的节点</span></span><br><span class="line">        <span class="keyword">while</span> ((sl = s.left) != <span class="literal">null</span>) <span class="comment">// find successor</span></span><br><span class="line">            s = sl;</span><br><span class="line">        <span class="comment">// 12.3 交换p节点和s节点的颜色</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">c</span> <span class="operator">=</span> s.red; s.red = p.red; p.red = c;</span><br><span class="line">        <span class="comment">// s的右节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">        <span class="comment">// p的父节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        <span class="comment">// 如果p节点的右节点即为s节点，则将p的父节点赋值为s，将s的右节点赋值为p</span></span><br><span class="line">        <span class="keyword">if</span> (s == pr) &#123;</span><br><span class="line">            p.parent = s;</span><br><span class="line">            s.right = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将sp赋值为s的父节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">            <span class="comment">// 将p的父节点赋值为sp</span></span><br><span class="line">            <span class="keyword">if</span> ((p.parent = sp) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果s节点为sp的左节点，则将sp的左节点赋值为p节点</span></span><br><span class="line">                <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                    sp.left = p;</span><br><span class="line">                    <span class="comment">// 否则s节点为sp的右节点，则将sp的右节点赋值为p节点</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sp.right = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// s的右节点赋值为p节点的右节点</span></span><br><span class="line">            <span class="keyword">if</span> ((s.right = pr) != <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">// 如果pr不为空，则将pr的父节点赋值为s</span></span><br><span class="line">                pr.parent = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 12.5 第二次调整</span></span><br><span class="line">        <span class="comment">// 将p的左节点赋值为空，pl已经保存了该节点</span></span><br><span class="line">        p.left = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 将p节点的右节点赋值为sr，如果sr不为空，则将sr的父节点赋值为p节点</span></span><br><span class="line">        <span class="keyword">if</span> ((p.right = sr) != <span class="literal">null</span>)</span><br><span class="line">            sr.parent = p;</span><br><span class="line">        <span class="comment">// 将s节点的左节点赋值为pl，如果pl不为空，则将pl的父节点赋值为s节点</span></span><br><span class="line">        <span class="keyword">if</span> ((s.left = pl) != <span class="literal">null</span>)</span><br><span class="line">            pl.parent = s;</span><br><span class="line">        <span class="comment">// 将s的父节点赋值为p的父节点pp</span></span><br><span class="line">        <span class="comment">// 如果pp为空，则p节点为root节点, 交换后s成为新的root节点</span></span><br><span class="line">        <span class="keyword">if</span> ((s.parent = pp) == <span class="literal">null</span>)</span><br><span class="line">            root = s;</span><br><span class="line">            <span class="comment">// 如果p不为root节点, 并且p是pp的左节点，则将pp的左节点赋值为s节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = s;</span><br><span class="line">            <span class="comment">// 如果p不为root节点, 并且p是pp的右节点，则将pp的右节点赋值为s节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = s;</span><br><span class="line">        <span class="comment">// 12.6 寻找replacement节点，用来替换掉p节点</span></span><br><span class="line">        <span class="comment">// 12.6.1 如果sr不为空，则replacement节点为sr，因为s没有左节点，所以使用s的右节点来替换p的位置</span></span><br><span class="line">        <span class="keyword">if</span> (sr != <span class="literal">null</span>)</span><br><span class="line">            replacement = sr;</span><br><span class="line">            <span class="comment">// 12.6.1 如果sr为空，则s为叶子节点，replacement为p本身，只需要将p节点直接去除即可</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            replacement = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 13.承接12点的判断，如果p的左节点不为空，右节点为空，replacement节点为p的左节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="literal">null</span>)</span><br><span class="line">        replacement = pl;</span><br><span class="line">        <span class="comment">// 14.如果p的右节点不为空,左节点为空，replacement节点为p的右节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="literal">null</span>)</span><br><span class="line">        replacement = pr;</span><br><span class="line">        <span class="comment">// 15.如果p的左右节点都为空, 即p为叶子节点, replacement节点为p节点本身</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        replacement = p;</span><br><span class="line">    <span class="comment">// 16.第三次调整：使用replacement节点替换掉p节点的位置，将p节点移除</span></span><br><span class="line">    <span class="keyword">if</span> (replacement != p) &#123; <span class="comment">// 如果p节点不是叶子节点</span></span><br><span class="line">        <span class="comment">// 16.1 将p节点的父节点赋值给replacement节点的父节点, 同时赋值给pp节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">        <span class="comment">// 16.2 如果p没有父节点, 即p为root节点，则将root节点赋值为replacement节点即可</span></span><br><span class="line">        <span class="keyword">if</span> (pp == <span class="literal">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">            <span class="comment">// 16.3 如果p不是root节点, 并且p为pp的左节点，则将pp的左节点赋值为替换节点replacement</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = replacement;</span><br><span class="line">            <span class="comment">// 16.4 如果p不是root节点, 并且p为pp的右节点，则将pp的右节点赋值为替换节点replacement</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = replacement;</span><br><span class="line">        <span class="comment">// 16.5 p节点的位置已经被完整的替换为replacement, 将p节点清空, 以便垃圾收集器回收</span></span><br><span class="line">        p.left = p.right = p.parent = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 17.如果p节点不为红色则进行红黑树删除平衡调整</span></span><br><span class="line">    <span class="comment">// (如果删除的节点是红色则不会破坏红黑树的平衡无需调整)</span></span><br><span class="line">    TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 18.如果p节点为叶子节点, 则简单的将p节点去除即可</span></span><br><span class="line">    <span class="keyword">if</span> (replacement == p) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        <span class="comment">// 18.1 将p的parent属性设置为空</span></span><br><span class="line">        p.parent = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 18.2 如果p节点为父节点的左节点，则将父节点的左节点赋值为空</span></span><br><span class="line">            <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 18.3 如果p节点为父节点的右节点， 则将父节点的右节点赋值为空</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                pp.right = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (movable)</span><br><span class="line">        <span class="comment">// 19.将root节点移到索引位置的头节点</span></span><br><span class="line">        moveRootToFront(tab, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="九-HashMap-和-Hashtable-的区别"><a href="#九-HashMap-和-Hashtable-的区别" class="headerlink" title="九. HashMap 和 Hashtable 的区别"></a>九. HashMap 和 Hashtable 的区别</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HashMap 允许 key 和 value 为 <span class="literal">null</span>，Hashtable 不允许。</span><br><span class="line">HashMap 的默认初始容量为 <span class="number">16</span>，Hashtable 为 <span class="number">11</span>。</span><br><span class="line">HashMap 的扩容为原来的 <span class="number">2</span> 倍，Hashtable 的扩容为原来的 <span class="number">2</span> 倍加 <span class="number">1</span>。</span><br><span class="line">HashMap 是非线程安全的，Hashtable是线程安全的。</span><br><span class="line">HashMap 的 hash 值重新计算过，Hashtable 直接使用 hashCode。</span><br><span class="line">HashMap 去掉了 Hashtable 中的 contains 方法。</span><br><span class="line">HashMap 继承自 AbstractMap 类，Hashtable 继承自 Dictionary 类。</span><br></pre></td></tr></table></figure><h1 id="十-JDK1-8版本前的死循环问题分析"><a href="#十-JDK1-8版本前的死循环问题分析" class="headerlink" title="十. JDK1.8版本前的死循环问题分析"></a>十. JDK1.8版本前的死循环问题分析</h1><ul><li>导致死循环的根本原因是 JDK 1.7 扩容采用的是“头插法”，会导致同一索引位置的节点在扩容后顺序反掉。而 JDK 1.8 之后采用的是“尾插法”，扩容后节点顺序不会反掉，不存在死循环问题。</li></ul><h1 id="十一-JDK1-8优化改变的结构总结"><a href="#十一-JDK1-8优化改变的结构总结" class="headerlink" title="十一. JDK1.8优化改变的结构总结"></a>十一. JDK1.8优化改变的结构总结</h1><ol><li>jdk1.8扩容时插入方式从“头插法”改成“尾插法”，避免了并发下的死循环。</li><li>底层数据结构从“数组+链表”改成“数组+链表+红黑树”，主要是优化了 hash 冲突较严重时，链表过长的查找性能：O(n) -&gt; O(logn)。</li><li>计算 table 初始容量的方式发生了改变，老的方式是从1开始不断向左进行移位运算，直到找到大于等于入参容量的值；新的方式则是通过“5个移位+或等于运算”来计算。</li><li>优化了 hash 值的计算方式，将 hashCode 的高16位和 hashCode 进行异或（XOR）运算，得到最终的 hash 值。</li><li>扩容时计算节点在新表的索引位置方式从<code>h &amp; (length-1)</code>改成<code>hash &amp; oldCap</code>，性能可能提升不大，但设计更巧妙</li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> Java集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CopyOnWriteArrayList-JDK1.8源码分析</title>
      <link href="/2020/04/16/CopyOnWriteArrayList-JDK1.8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2020/04/16/CopyOnWriteArrayList-JDK1.8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="一-CopyOnWriteArrayList介绍"><a href="#一-CopyOnWriteArrayList介绍" class="headerlink" title="一. CopyOnWriteArrayList介绍"></a>一. CopyOnWriteArrayList介绍</h1><ul><li>CopyOnWriteArrayList是Java并发包中提供的一个并发容器，它是个线程安全且<strong>读操作</strong>无锁的ArrayList，<strong>写操作</strong>则通过创建底层数组的新副本来实现，是一种读写分离的并发策略，我们也可以称这种容器为”写时复制器”。</li></ul><h1 id="二-CopyOnWriteArrayList源码分析"><a href="#二-CopyOnWriteArrayList源码分析" class="headerlink" title="二. CopyOnWriteArrayList源码分析"></a>二. CopyOnWriteArrayList源码分析</h1><h2 id="①-CopyOnWriteArrayList的内部类—COWIterator类"><a href="#①-CopyOnWriteArrayList的内部类—COWIterator类" class="headerlink" title="①.  CopyOnWriteArrayList的内部类—COWIterator类"></a>①.  CopyOnWriteArrayList的内部类—COWIterator类</h2><ul><li>COWIterator表示迭代器，其也有一个Object类型的数组作为CopyOnWriteArrayList数组的快照，这种快照风格的迭代器方法在创建迭代器时使用了对当时数组状态的引用。此数组在迭代器的生存期内不会更改，因此不可能发生冲突，并且迭代器保证不会抛出 ConcurrentModificationException。创建迭代器以后，迭代器就不会反映列表的添加、移除或者更改。在迭代器上进行的元素更改操作（remove、set 和 add）不受支持。这些方法将抛出 UnsupportedOperationException。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210516135421878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">COWIterator</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">ListIterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//快照</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line">    <span class="comment">//游标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cursor;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">COWIterator</span><span class="params">(Object[] elements, <span class="type">int</span> initialCursor)</span> &#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否还有下一项</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否有上一项</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// next项</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">previous</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 不存在下一项，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (! hasPrevious())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="comment">// 返回下一项</span></span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[--cursor];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一项索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上一项索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">previousIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不支持remove操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不支持set操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不支持add操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="②-CopyOnWriteArrayList的属性"><a href="#②-CopyOnWriteArrayList的属性" class="headerlink" title="②. CopyOnWriteArrayList的属性"></a>②. CopyOnWriteArrayList的属性</h2><ul><li>属性中有一个可重入锁，内部持有一个ReentrantLock lock &#x3D; new ReentrantLock()，用来保证线程安全访问。</li><li>还有一个Object类型的数组，用来存放具体的元素。使用到了反射机制和CAS来保证原子性的修改lock域。</li><li>底层是用volatile transient声明的数组 array。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210516135649122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    <span class="comment">// 版本序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8673264195747942595L</span>;</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// 对象数组，用于存放元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line">    <span class="comment">// Unsafe类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="comment">// lock域的内存偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> lockOffset;</span><br><span class="line">    <span class="comment">//静态代码块获取内存偏移量</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = CopyOnWriteArrayList.class;</span><br><span class="line">            lockOffset = UNSAFE.objectFieldOffset(k.getDeclaredField(<span class="string">&quot;lock&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="③-CopyOnWriteArrayList的构造函数"><a href="#③-CopyOnWriteArrayList的构造函数" class="headerlink" title="③. CopyOnWriteArrayList的构造函数"></a>③. CopyOnWriteArrayList的构造函数</h2><p><img src="https://img-blog.csdnimg.cn/20210516135856424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CopyOnWriteArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 设置当前数组</span></span><br><span class="line">    setArray(<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CopyOnWriteArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    <span class="comment">// 类型相同</span></span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == CopyOnWriteArrayList.class)</span><br><span class="line">        <span class="comment">// 获取c集合的数组</span></span><br><span class="line">        elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将c集合转化为数组并赋值给elements</span></span><br><span class="line">        elements = c.toArray();</span><br><span class="line">        <span class="comment">// elements类型不为Object[]类型</span></span><br><span class="line">        <span class="keyword">if</span> (elements.getClass() != Object[].class)</span><br><span class="line">            <span class="comment">// 将elements数组转化为Object[]类型的数组</span></span><br><span class="line">            elements = Arrays.copyOf(elements, elements.length, Object[].class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置数组</span></span><br><span class="line">    setArray(elements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将toCopyIn转化为Object[]类型数组，然后设置当前数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CopyOnWriteArrayList</span><span class="params">(E[] toCopyIn)</span> &#123;</span><br><span class="line">    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="④-Arrays-copyOf-方法"><a href="#④-Arrays-copyOf-方法" class="headerlink" title="④. Arrays.copyOf()方法"></a>④. Arrays.copyOf()方法</h2><p><img src="https://img-blog.csdnimg.cn/20210516140012526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="type">int</span> newLength, Class&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>[]&gt; newType) &#123;</span><br><span class="line">    <span class="comment">// 确定copy的类型 将newType转化为Object类型，将Object[].class转化为Object类型</span></span><br><span class="line">    <span class="comment">// 判断两者是否相等，若相等，则生成指定长度的Object数组</span></span><br><span class="line">    <span class="comment">// 否则,生成指定长度的新类型的数组</span></span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[].class)? (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[newLength]:</span><br><span class="line">            (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    <span class="comment">// 将original数组从下标0开始，复制长度为(original.length和newLength的较小者),复制到copy数组中（也从下标0开始）</span></span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=4> System.arraycopy()方法</p><p><img src="https://img-blog.csdnimg.cn/20210516140042374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//System.arraycopy() 是 native方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src 原数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcPos  原数组中的起始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dest  目标数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> destPos 目标数组的起始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 要赋值的数组元素数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src,  <span class="type">int</span>  srcPos,Object dest, <span class="type">int</span> destPos,<span class="type">int</span> length)</span>;</span><br></pre></td></tr></table></figure><h2 id="⑤-add-E-e-方法"><a href="#⑤-add-E-e-方法" class="headerlink" title="⑤. add(E e) 方法"></a>⑤. add(E e) 方法</h2><ul><li>此函数用于将指定元素添加到此列表的尾部</li></ul><ol><li><p>获取锁（保证多线程的安全访问），获取当前的Object数组，获取Object数组的长度为length。</p></li><li><p>根据Object数组复制一个长度为length+1的Object数组为newElements（此时，newElements[length]为null），进入步骤③。</p></li><li><p>将下标为length的数组元素newElements[length]设置为元素e，再设置当前Object[]为newElements，释放锁，返回。这样就完成了元素的添加。<br>  <img src="https://img-blog.csdnimg.cn/20210516140406834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       <span class="comment">// 可重入锁</span></span><br><span class="line">       <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">       <span class="comment">// 获取锁</span></span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 元素数组</span></span><br><span class="line">           Object[] elements = getArray();</span><br><span class="line">           <span class="comment">// 数组长度</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">           <span class="comment">// 复制数组</span></span><br><span class="line">           Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">           <span class="comment">// 存放元素e</span></span><br><span class="line">           newElements[len] = e;</span><br><span class="line">           <span class="comment">// 设置数组</span></span><br><span class="line">           setArray(newElements);</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// 释放锁</span></span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="⑥-addIfAbsent-方法"><a href="#⑥-addIfAbsent-方法" class="headerlink" title="⑥. addIfAbsent() 方法"></a>⑥. addIfAbsent() 方法</h2><p><img src="https://img-blog.csdnimg.cn/20210516140643159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该函数用于添加元素（如果数组中不存在，则添加；否则，不添加，直接返回）</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addIfAbsent</span><span class="params">(E e)</span> &#123;</span><br><span class="line">      <span class="comment">//获取当前数组</span></span><br><span class="line">      Object[] snapshot = getArray();</span><br><span class="line">      <span class="keyword">return</span> indexOf(e, snapshot, <span class="number">0</span>, snapshot.length) &gt;= <span class="number">0</span> ? <span class="literal">false</span> :addIfAbsent(e, snapshot);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//该函数用于添加元素（如果数组中不存在，则添加；否则，不添加，直接返回）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addIfAbsent</span><span class="params">(E e, Object[] snapshot)</span> &#123;</span><br><span class="line">      <span class="comment">// 重入锁</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">      <span class="comment">// 获取锁</span></span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 获取当前数组 current</span></span><br><span class="line">          Object[] current = getArray();</span><br><span class="line">          <span class="comment">// 数组长度 len</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> current.length;</span><br><span class="line">          <span class="comment">// 快照不等于当前数组，对数组进行了修改</span></span><br><span class="line">          <span class="keyword">if</span> (snapshot != current) &#123;</span><br><span class="line">              <span class="comment">// 取较小者</span></span><br><span class="line">              <span class="type">int</span> <span class="variable">common</span> <span class="operator">=</span> Math.min(snapshot.length, len);</span><br><span class="line">              <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; common; i++)</span><br><span class="line">                  <span class="comment">// 当前数组的元素与快照的元素不相等并且e与当前元素相等</span></span><br><span class="line">                  <span class="keyword">if</span> (current[i] != snapshot[i] &amp;&amp; eq(e, current[i]))</span><br><span class="line">                      <span class="comment">// 表示在snapshot与current之间修改了数组，并且设置了数组某一元素为e，已经存在</span></span><br><span class="line">                      <span class="comment">// 直接返回false</span></span><br><span class="line">                      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">              <span class="comment">// 在当前数组中找到e元素</span></span><br><span class="line">              <span class="keyword">if</span> (indexOf(e, current, common, len) &gt;= <span class="number">0</span>)</span><br><span class="line">                  <span class="comment">// 返回</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 复制数组</span></span><br><span class="line">          Object[] newElements = Arrays.copyOf(current, len + <span class="number">1</span>);</span><br><span class="line">          <span class="comment">// 对数组len索引的元素赋值为e</span></span><br><span class="line">          newElements[len] = e;</span><br><span class="line">          <span class="comment">// 设置当前数组</span></span><br><span class="line">          setArray(newElements);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// 释放锁</span></span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="⑦-set-int-index-E-element-方法"><a href="#⑦-set-int-index-E-element-方法" class="headerlink" title="⑦. set(int index, E element)方法"></a>⑦. set(int index, E element)方法</h2><p><img src="https://img-blog.csdnimg.cn/20210516140948792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 获取index索引的元素</span></span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> get(elements, index);</span><br><span class="line">        <span class="comment">// 旧值等于element</span></span><br><span class="line">        <span class="keyword">if</span> (oldValue != element) &#123; /</span><br><span class="line">            <span class="comment">// 数组长度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">            <span class="comment">// 复制数组</span></span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">            <span class="comment">// 重新赋值index索引的值</span></span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            <span class="comment">// 设置数组</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 设置数组</span></span><br><span class="line">            setArray(elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回旧值</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑧-remove-int-index-方法"><a href="#⑧-remove-int-index-方法" class="headerlink" title="⑧. remove(int index) 方法"></a>⑧. remove(int index) 方法</h2><ol><li><p>获取锁，获取数组elements，数组长度为length，获取索引的值elements[index]，计算需要移动的元素个数（length - index - 1）,若个数为0，则表示移除的是数组的最后一个元素，复制elements数组，复制长度为length-1，然后设置数组进入步骤3；否则，进入步骤2。</p></li><li><p>先复制index索引前的元素，再复制index索引后的元素，然后设置数组。</p></li><li><p>释放锁，返回旧值。</p></li></ol><p><img src="https://img-blog.csdnimg.cn/20210516141215592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过下标移除元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取数组 elements</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 数组长度 length</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        <span class="comment">// 获取旧值</span></span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> get(elements, index);</span><br><span class="line">        <span class="comment">// 需要移动的元素个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 移动个数为0 则表示移除的是数组的最后一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 复制elements数组，复制长度为length-1，然后设置数组</span></span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 移动个数不为0</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 新生数组</span></span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> <span class="title class_">Object</span>[len - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 复制index索引之前的元素</span></span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            <span class="comment">// 复制index索引之后的元素</span></span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,numMoved);</span><br><span class="line">            <span class="comment">// 设置当前数组</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回旧值</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="三-CopyOnWriteArrayList为什么并发安全且性能比Vector好"><a href="#三-CopyOnWriteArrayList为什么并发安全且性能比Vector好" class="headerlink" title="三. CopyOnWriteArrayList为什么并发安全且性能比Vector好"></a>三. CopyOnWriteArrayList为什么并发安全且性能比Vector好</h1><ul><li>Vector是增删改查方法都加了synchronized，保证同步，但是每个方法执行的时候都要去获得锁，性能就会大大下降，而CopyOnWriteArrayList 只是在增删改上加锁，但是读不加锁，在读方面的性能就好于Vector，CopyOnWriteArrayList支持读多写少的并发情况。</li></ul><h1 id="四-CopyOnWriteArrayList优缺点"><a href="#四-CopyOnWriteArrayList优缺点" class="headerlink" title="四. CopyOnWriteArrayList优缺点"></a>四. CopyOnWriteArrayList优缺点</h1><blockquote><p><font color='red' size=4> 优点</p></blockquote><ul><li>读操作性能很高，因为无需任何同步措施，比较适用于读多写少的并发场景。</li><li>Java的list在遍历时，若中途有别的线程对list容器进行修改，则会抛出ConcurrentModificationException异常。而CopyOnWriteArrayList由于其”读写分离”的思想，遍历和修改操作分别作用在不同的list容器，所以在使用迭代器进行遍历时候，也就不会抛出ConcurrentModificationException异常了</li></ul><blockquote><p><font color='red' size=4> 缺点</p></blockquote><ol><li><strong>内存占用问题</strong>，毕竟每次执行写操作都要将原容器拷贝一份，数据量大时，对内存压力较大，可能会引起频繁GC；</li><li><strong>无法保证实时性</strong>，Vector对于读写操作均加锁同步，可以保证读和写的强一致性。而CopyOnWriteArrayList由于其实现策略的原因，写和读分别作用在新老不同容器上，在写操作执行过程中，读不会阻塞但读取到的却是老容器的数据。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
