<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>开发规范总结(持续更新)</title>
      <link href="/2022/07/13/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93/"/>
      <url>/2022/07/13/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="代码整洁之道总结—持续更新"><a href="#代码整洁之道总结—持续更新" class="headerlink" title="代码整洁之道总结—持续更新"></a>代码整洁之道总结—持续更新</h1><blockquote><p>不要重复代码、只做一件事、表达力、小规模抽象。</p></blockquote><h3 id="一、有意义的命名【第二章】"><a href="#一、有意义的命名【第二章】" class="headerlink" title="一、有意义的命名【第二章】"></a>一、有意义的命名【第二章】</h3><ol><li>别用List命名。</li><li>别使用相似度较高的名称。</li><li>别用小写l和大写O。</li><li>别用前缀标明成员变量。</li><li>接口名称别用IXXX，使用XXXXImpl。</li><li>类名&#x2F;对象名使用名词&#x2F;名称短语。</li><li>方法名使用动词&#x2F;动词短语。</li><li>不要加没用的语境前缀词。</li></ol><h3 id="二、函数【第三章】"><a href="#二、函数【第三章】" class="headerlink" title="二、函数【第三章】"></a>二、函数【第三章】</h3><ol><li><strong>函数短小：</strong>函数的规则就是短小,正常我们编辑器一屏显示的函数一般在30-40行左右，我们应该控制函数在一屏之内结束，让函数短小精悍。</li><li><strong>职责单一：</strong>我们应尽量让一个函数只做一件事情，不要让太多功能混在一个函数中，如果确实做了很多事情，那一定要好好对该函数命名，不能以其中一个功能命名整个函数。</li><li><strong>函数顺序：</strong>我们阅读代码的时候，往往都是从上往下的，所以我们在写函数的时候也要注意，先出现的函数在上面，函数中有调用其他函数，那就紧随其后，这样看代码的时候就不用跳来跳去，我是谁，我在哪，我要回哪里…</li><li><strong>函数参数数量限制：</strong>最理想的函数参数数量是零，其次是单参数，再次是双参数，应尽量避免三参数函数.</li><li><strong>使用具有描述性的名称</strong></li></ol><h3 id="三-、注释【第四章】"><a href="#三-、注释【第四章】" class="headerlink" title="三 、注释【第四章】"></a>三 、注释【第四章】</h3><ol><li>带有少量注释的整洁而有表达力的代码，要比带有大量注释的零碎而复杂的代码像样的多。</li><li>用代码来阐述，很多时候，简单到只需要创建一个描述与注释所言同一事物的函数即可</li><li>能用函数或变量时就别用注释</li></ol><h3 id="三、对象和数据结构【第六章】"><a href="#三、对象和数据结构【第六章】" class="headerlink" title="三、对象和数据结构【第六章】"></a>三、对象和数据结构【第六章】</h3><ol><li><strong>数据抽象：</strong>隐藏实现，暴露抽象。</li><li><strong>对象和数据结构差异：</strong>对象把数据隐藏于抽象之后，暴露操作数据的函数，数据结构暴露其数据，不提供有意义的函数。</li><li><strong>禁止使用魔法数字</strong></li></ol><h3 id="四、错误处理【第七章】"><a href="#四、错误处理【第七章】" class="headerlink" title="四、错误处理【第七章】"></a>四、错误处理【第七章】</h3><ol><li>使用异常而非返回码</li><li>有限书写捕获异常代码，以确定异常范围</li><li>使用未检异常</li><li>抛出异常时应当提供足够的环境说明，以便判断错误的来源于位置；创建充分的错误消息</li><li>依据调用者需要定义异常：定义异常类时，最重要的考虑应该是如何被捕获</li><li><strong>不返回null值，不传递null值，防止意外Null异常</strong></li></ol><h3 id="五、类【第十章】"><a href="#五、类【第十章】" class="headerlink" title="五、类【第十章】"></a>五、类【第十章】</h3><blockquote><p>类中的代码遵循标准的Java约定，一般按照出现的先后顺序为：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">公共静态常量</span><br><span class="line">私有静态变量</span><br><span class="line">私有实体变量</span><br><span class="line">公共函数</span><br><span class="line">公共函数调用的私有函数紧随在该公共函数后面</span><br></pre></td></tr></table></figure><ol><li>第一条规则：类应该短小；第二天规则：还是要更短小，以计算权责的方式衡量</li><li>单一权则原则（SRP）：类或模块应该只有一条加以修改的理由</li><li>内聚：类应该只有少数实体变量。若一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性</li><li>保持内聚会得到许多短小的类</li><li>遵循开发闭合原则（OCP）：类应该对扩展开放，对修改封闭</li><li>遵循依赖倒置原则（DIP）：类应该依赖抽象而不是依赖具体细节</li></ol><h3 id="六、重构"><a href="#六、重构" class="headerlink" title="六、重构"></a>六、重构</h3><ol><li>重复的代码，重复的代码需要提取出来形成函数以便于多处调用。</li><li>冗长的代码块，需要进行分析抽离成若干个简洁的函数实现。</li><li>循环过长和嵌套过深的代码，循环内部的复杂 代码往往可以转成子程序。</li><li>子程序命名不当，需要对子程序重新命名，拆分或合并。</li><li>难以理解的代码，需要进行整理流程并进行模块化。</li></ol><h1 id="阿里开发手册总结—持续更新"><a href="#阿里开发手册总结—持续更新" class="headerlink" title="阿里开发手册总结—持续更新"></a>阿里开发手册总结—持续更新</h1><h3 id="一、命名风格"><a href="#一、命名风格" class="headerlink" title="一、命名风格"></a>一、命名风格</h3><ol><li><p>【强制】POJO 类中布尔类型变量都不要加 is 前缀，否则部分框架解析会引起序列化错误。</p><blockquote><p>说明：在MySQL 规约中的建表约定第一条，表达是与否的值采用 is_xxx 的命名方式，所以，需要在<resultMap>设置从 is_xxx 到 xxx 的映射关系。<br>反例：定义为基本数据类型 Boolean isDeleted 的属性，它的方法也是 isDeleted()，RPC 框架在反向解析的时候，“误以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异常。</p></blockquote></li><li><p>【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。</p></li><li><p>【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。</p></li><li><p>【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。</p></li><li><p>【推荐】在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。</p><blockquote><p>正例：startTime &#x2F; workQueue &#x2F; nameList &#x2F; TERMINATED_THREAD_COUNT<br>反例：startedAt &#x2F; QueueOfWork &#x2F; listName &#x2F; COUNT_TERMINATED_THREAD</p></blockquote></li><li><p>【参考】各层命名规约：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Service/DAO 层方法命名规约</span><br><span class="line">  <span class="number">1.</span> 获取单个对象的方法用 get 做前缀。</span><br><span class="line">  <span class="number">2.</span> 获取多个对象的方法用 list 做前缀，复数形式结尾如：listObjects。</span><br><span class="line">  <span class="number">3.</span> 获取统计值的方法用 count 做前缀。</span><br><span class="line">  <span class="number">4.</span> 插入的方法用 save/insert 做前缀。</span><br><span class="line">  <span class="number">5.</span> 删除的方法用 remove/delete 做前缀。</span><br><span class="line">  <span class="number">6.</span> 修改的方法用 update 做前缀。</span><br><span class="line">领域模型命名规约</span><br><span class="line">  <span class="number">1.</span> 数据对象：xxxDO，xxx 即为数据表名。</span><br><span class="line">  <span class="number">2.</span> 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。</span><br><span class="line">  <span class="number">3.</span> 展示对象：xxxVO，xxx 一般为网页名称。</span><br><span class="line">  <span class="number">4.</span> POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。</span><br></pre></td></tr></table></figure></li></ol><h3 id="二、常量定义"><a href="#二、常量定义" class="headerlink" title="二、常量定义"></a>二、常量定义</h3><ol><li><p>【强制】不允许任何魔法值（即未经预先定义的常量）直接出现在代码中</p></li><li><p>【强制】在 long 或者 Long 赋值时，数值后使用大写的 L，不能是小写的 l，小写容易跟数字 1 混淆，造成误解。<br>说明：Long a &#x3D; 2l; 写的是数字的 21，还是 Long 型的 2。</p></li></ol><h3 id="三、代码格式"><a href="#三、代码格式" class="headerlink" title="三、代码格式"></a>三、代码格式</h3><ol><li>【推荐】单个方法的总行数不超过 80 行。</li><li>【推荐】不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。</li><li>【强制】注释的双斜线与注释内容之间有且仅有一个空格。</li></ol><h3 id="四、OOP-规约"><a href="#四、OOP-规约" class="headerlink" title="四、OOP 规约"></a>四、OOP 规约</h3><ol><li><p>【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。</p></li><li><p>【强制】所有的覆写方法，必须加@Override 注解。</p><blockquote><p>说明：getObject()与 get0bject()的问题。一个是字母的 O，一个是数字的 0，加@Override 可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。</p></blockquote></li><li><p>【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。</p><blockquote><p>说明：可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）<br>正例：CloseCode public List<User> listUsers(String type, Long… ids) {…}</p></blockquote></li><li><p>【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。</p></li><li><p>【强制】不能使用过时的类或方法。</p></li></ol><blockquote><p>说明：java.net.URLDecoder 中的方法 decode(String encodeStr) 这个方法已经过时，应该使用双参数 decode(String source, String encode)。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。</p></blockquote><ol start="6"><li>【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。</li></ol><blockquote><p>正例：”test”.equals(object);<br>反例：object.equals(“test”);<br>说明：推荐使用 java.util.Objects#equals（JDK7 引入的工具类）。</p></blockquote><ol start="7"><li>【强制】所有整型包装类对象之间值的比较，全部使用 equals 方法比较。</li></ol><blockquote><p>说明：对于 Integer var &#x3D; ? 在-128 至 127 范围内的赋值，Integer 对象是在 IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用&#x3D;&#x3D;进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。</p></blockquote><ol start="8"><li>【强制】浮点数之间的等值判断，基本数据类型不能用&#x3D;&#x3D;来比较，包装数据类型不能用 equals 来判断。</li></ol><blockquote><p>说明：浮点数采用“尾数+阶码”的编码方式，类似于科学计数法的“有效数字+指数”的表示方式。二进制无法精确表示大部分的十进制小数，具体原理参考《码出高效》。<br>反例：float a &#x3D; 1.0f - 0.9f; float b &#x3D; 0.9f - 0.8f;  &#x2F;&#x2F; 但事实上 a&#x3D;&#x3D;b 的结果为 false</p><p>Float x &#x3D; Float.valueOf(a); Float y &#x3D; Float.valueOf(b); &#x2F;&#x2F;但事实上 x.equals(y)  的结果为 false</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) 指定一个误差范围，两个浮点数的差值在此范围之内，则认为是相等的。</span><br><span class="line">  <span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1.0f</span> - <span class="number">0.9f</span>;</span><br><span class="line">  <span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.9f</span> - <span class="number">0.8f</span>;</span><br><span class="line">  <span class="type">float</span> <span class="variable">diff</span> <span class="operator">=</span> <span class="number">1e-6f</span>;</span><br><span class="line">  <span class="keyword">if</span> (Math.abs(a - b) &lt; diff) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) 使用 BigDecimal 来定义值，再进行浮点数的运算操作。</span><br><span class="line">  <span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">  <span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">  <span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(b);</span><br><span class="line">  <span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c);</span><br><span class="line">  <span class="keyword">if</span> (x.equals(y)) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="9"><li><p>【强制】定义数据对象 DO 类时，属性类型要与数据库字段类型相匹配。</p><blockquote><p>正例：数据库字段的 bigint 必须与类属性的 Long 类型相对应。<br>反例：某个案例的数据库表 id 字段定义类型 bigint unsigned，实际类对象属性为 Integer，随着 id 越来越大，超过 Integer 的表示范围而溢出成为负数。</p></blockquote></li><li><p>【强制】为了防止精度损失，禁止使用构造方法 BigDecimal(double)的方式把 double 值转化为 BigDecimal 对象。</p><blockquote><p>说明：BigDecimal(double)存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。<br>如：BigDecimal g &#x3D; new BigDecimal(0.1f); 实际的存储值为：0.10000000149<br>正例：优先推荐入参为 String 的构造方法，或使用 BigDecimal 的 valueOf 方法，此方法内部其实执行了 Double 的 toString，而 Double 的 toString 按 double 的实际能表达的精度对尾数进行了截断。</p></blockquote></li><li><p>关于基本数据类型与包装数据类型的使用标准如下：</p><p>【强制】所有的 POJO 类属性必须使用包装数据类型。<br>【强制】RPC 方法的返回值和参数必须使用包装数据类型。<br>【推荐】所有的局部变量使用基本数据类型。</p><blockquote><p>说明：POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或者入库检查，都由使用者来保证。<br>正例：数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。<br>反例：比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线。所以包装数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。</p></blockquote></li><li><p>【推荐】慎用 Object 的 clone 方法来拷贝对象。</p><blockquote><p>说明：对象 clone 方法默认是浅拷贝，若想实现深拷贝需覆写 clone 方法实现域对象的深度遍历式拷贝。</p></blockquote></li><li><p>【推荐】类成员与方法访问控制从严：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 如果不允许外部直接通过 <span class="keyword">new</span> 来创建对象，那么构造方法必须是 <span class="keyword">private</span>。</span><br><span class="line"><span class="number">2.</span> 工具类不允许有 <span class="keyword">public</span> 或 <span class="keyword">default</span> 构造方法。</span><br><span class="line"><span class="number">3.</span> 类非 <span class="keyword">static</span> 成员变量并且与子类共享，必须是 <span class="keyword">protected</span>。</span><br><span class="line"><span class="number">4.</span> 类非 <span class="keyword">static</span> 成员变量并且仅在本类使用，必须是 <span class="keyword">private</span>。</span><br><span class="line"><span class="number">5.</span> 类 <span class="keyword">static</span> 成员变量如果仅在本类使用，必须是 <span class="keyword">private</span>。</span><br><span class="line"><span class="number">6.</span> 若是 <span class="keyword">static</span> 成员变量，考虑是否为 <span class="keyword">final</span>。</span><br><span class="line"><span class="number">7.</span> 类成员方法只供类内部调用，必须是 <span class="keyword">private</span>。</span><br><span class="line"><span class="number">8.</span> 类成员方法只对继承类公开，那么限制为 <span class="keyword">protected</span>。 </span><br></pre></td></tr></table></figure></li><li><p>【推荐】final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 不允许被继承的类，如：String 类。</span><br><span class="line"><span class="number">2.</span> 不允许修改引用的域对象。</span><br><span class="line"><span class="number">3.</span> 不允许被覆写的方法，如：POJO 类的 setter 方法。</span><br><span class="line"><span class="number">4.</span> 不允许运行过程中重新赋值的局部变量。</span><br><span class="line"><span class="number">5.</span> 避免上下文重复使用一个变量，使用 <span class="keyword">final</span> 可以强制重新定义一个变量，方便更好地进行重构</span><br></pre></td></tr></table></figure></li><li><p>【推荐】循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。</p><blockquote><p>说明：下例中，反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行 append 操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。</p></blockquote></li><li><p>【推荐】setter 方法中，参数名称与类成员变量名称一致，this.成员名 &#x3D; 参数名。在 getter&#x2F;setter 方法中，不要增加业务逻辑，增加排查问题的难度。</p></li><li><p>【推荐】类内方法定义的顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter &#x2F; setter 方法。</p><blockquote><p>说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为承载的信息价值较低，所有 Service 和 DAO 的 getter&#x2F;setter 方法放在类体最后。</p></blockquote></li><li><p>【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。</p></li><li><p>【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。</p><blockquote><p>说明：注意 serialVersionUID 不一致会抛出序列化运行时异常。</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Compose</title>
      <link href="/2022/07/05/Docker_Compose/"/>
      <url>/2022/07/05/Docker_Compose/</url>
      
        <content type="html"><![CDATA[<h1 id="一-Docker-Compose"><a href="#一-Docker-Compose" class="headerlink" title="一.  Docker Compose"></a>一.  Docker Compose</h1><h2 id="1-Docker-Compose介绍"><a href="#1-Docker-Compose介绍" class="headerlink" title="1 . Docker Compose介绍"></a>1 . Docker Compose介绍</h2><ol><li><p>Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。</p></li><li><p>其代码目前在 <a href="https://github.com/docker/compose">https://github.com/docker/compose</a> 上开源。</p></li><li><p>它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p></li><li><p>Compose 中有两个重要的概念：</p><ul><li>服务 (service)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li><li>项目 (project)：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。</li></ul></li><li><p>Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p></li><li><p>Compose 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 Compose 来进行编排管理。</p></li></ol><h2 id="2-Docker-Compose安装与卸载"><a href="#2-Docker-Compose安装与卸载" class="headerlink" title="2. Docker Compose安装与卸载"></a>2. Docker Compose安装与卸载</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p><font color='red'>本次Docker学习一直是在Linux系统上搭建</font></p><p>在 Linux 上的安装，从 官方 GitHub Release 处直接下载编译好的二进制文件即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo curl -L https:<span class="comment">//github.com/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210107100131279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210107100134923.png" alt="在这里插入图片描述"></p><h3 id="2-卸载"><a href="#2-卸载" class="headerlink" title="2. 卸载"></a>2. 卸载</h3><p>如果是二进制包方式安装的，删除二进制文件即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="3-测试安装成功"><a href="#3-测试安装成功" class="headerlink" title="3. 测试安装成功"></a>3. 测试安装成功</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose --version</span><br><span class="line"> docker-compose version <span class="number">1.25</span><span class="number">.5</span>, build 4667896b</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210107100206832.png" alt="在这里插入图片描述"></p><h2 id="3-docker-compose简单使用"><a href="#3-docker-compose简单使用" class="headerlink" title="3 . docker-compose简单使用"></a>3 . docker-compose简单使用</h2><ol><li>两个重要概念<br> 项目:  有多个服务共同组成一个完整业务单元定义docker -compose. yml交件中<br> 服务: 一个服务对应一 个应用容器在一个项目 中可以存在多个服务</li><li>docker-composeup启动这个项日的所有服务必领保证运行命令的8录存在docker-comgse.yml</li></ol><h3 id="1-创建docker-compose-yml文件"><a href="#1-创建docker-compose-yml文件" class="headerlink" title="1. 创建docker-compose.yml文件"></a>1. 创建docker-compose.yml文件</h3><p><img src="https://img-blog.csdnimg.cn/20210107100401483.png" alt="在这里插入图片描述"></p><h3 id="2-编辑docker-compose-yml文件"><a href="#2-编辑docker-compose-yml文件" class="headerlink" title="2.编辑docker-compose.yml文件"></a>2.编辑docker-compose.yml文件</h3><p><img src="https://img-blog.csdnimg.cn/20210107100412127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-启动docker-compose"><a href="#3-启动docker-compose" class="headerlink" title="3.启动docker-compose"></a>3.启动docker-compose</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210107100419472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="4-访问Tomcat测试"><a href="#4-访问Tomcat测试" class="headerlink" title="4. 访问Tomcat测试"></a>4. 访问Tomcat测试</h3><p><img src="https://img-blog.csdnimg.cn/2021010710042354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="5-测试多个容器一起启动"><a href="#5-测试多个容器一起启动" class="headerlink" title="5. 测试多个容器一起启动"></a>5. 测试多个容器一起启动</h3><p><img src="https://img-blog.csdnimg.cn/2021010710081225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210107100815544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210107100819314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="二-docker-compose模板命令"><a href="#二-docker-compose模板命令" class="headerlink" title="二 .docker-compose模板命令"></a>二 .docker-compose模板命令</h1><h2 id="1-docker-compose-模板文件"><a href="#1-docker-compose-模板文件" class="headerlink" title="1. docker-compose 模板文件"></a>1. docker-compose 模板文件</h2><ol><li><p>模板文件是使用 Compose 的核心，涉及到的指令关键字也比较多，这里面大部分指令跟 docker run 相关参数的含义都是类似的。</p></li><li><p>默认的模板文件名称为 docker-compose.yml，格式为 YAML 格式。</p></li><li><p>注意每个服务都必须通过 image 指令指定镜像或 build 指令（需要 Dockerfile）等来自动构建生成镜像。</p></li><li><p>如果使用 build 指令，在 Dockerfile 中设置的选项(例如：CMD, EXPOSE, VOLUME, ENV 等) 将会自动被获取，无需在 docker-compose.yml 中重复设置。</p></li></ol><h2 id="2-build"><a href="#2-build" class="headerlink" title="2. build"></a>2. build</h2><ol><li>启动服务时先将build命令中指定dockerfile打包成镜像。再运行镜像</li><li>指定 Dockerfile 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像。</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">demo:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="comment">#启动服务时先将build命令中指定dockerfile打包成镜像。再运行镜像</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">demo</span> <span class="comment"># 指定上下文目录</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">demo</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8081:8081&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hello</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">tomcat01</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210107102622369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210107102626323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021010710263036.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-command"><a href="#3-command" class="headerlink" title="3. command"></a>3. command</h2><p>覆盖容器启动后默认执行的命令。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">command:</span> <span class="string">&quot;redis-server --appendonly yes&quot;</span> <span class="comment">#run 镜像之后用来覆盖容器内默认命令</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210107102740107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4-container-name"><a href="#4-container-name" class="headerlink" title="4. container_name"></a>4. container_name</h2><ol><li><p>指定容器名称。默认将会使用 项目名称_服务名称_序号 这样的格式。</p></li><li><p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</p></li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">container_name:</span> <span class="string">tomcat01</span> <span class="comment"># 相当于run 的 --name</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210107102833935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210107104838477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="5-depends-on"><a href="#5-depends-on" class="headerlink" title="5. depends_on"></a>5. depends_on</h2><p>解决容器的依赖、启动先后的问题，注意： 服务不会等待 依赖服务完全启动之后才启动。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">depends_on:</span> <span class="comment">#代表这个容器必须依赖哪些容器启动之后才能启动</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">tomcat02</span> <span class="comment"># --服务名</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">mysql</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210107102952172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210107104134943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="6-env-file"><a href="#6-env-file" class="headerlink" title="6. env_file"></a>6. env_file</h2><p> 从文件中获取环境变量，可以为单独的文件路径或列表。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">env_file:</span> <span class="comment">#用来将environment环境中配置放入指定配置文件中</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">mysql.env</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210107103145211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210107103148939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210107103154272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="7-environment"><a href="#7-environment" class="headerlink" title="7. environment"></a>7. environment</h2><p>设置环境变量，只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210107103311606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="8-healthcheck"><a href="#8-healthcheck" class="headerlink" title="8. healthcheck"></a>8. healthcheck</h2><p>通过命令检查容器是否健康运行。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">healthcheck:</span></span><br><span class="line">  <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost&quot;</span>]</span><br><span class="line">  <span class="attr">interval:</span> <span class="string">1m30s</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">retries:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210107103403103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="9-image"><a href="#9-image" class="headerlink" title="9. image"></a>9. image</h2><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tomcat01:</span> <span class="comment">#服务名唯一</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">tomcat01</span> <span class="comment"># 相当于run 的 --name</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">tomcat:8.0-jre8-slim</span> <span class="comment">#创建当前这个服务使用镜像是谁 相当于run 的 image</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210107103437259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="10-networks"><a href="#10-networks" class="headerlink" title="10. networks"></a>10. networks</h2><h3 id="1-网桥的使用"><a href="#1-网桥的使用" class="headerlink" title="1. 网桥的使用"></a>1. 网桥的使用</h3><p>配置容器连接的网络。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="attr">networks:</span> <span class="comment">#相当于run 的 --network</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hello</span></span><br><span class="line"><span class="attr">networks:</span> <span class="comment">#定义服务的网桥</span></span><br><span class="line">  <span class="attr">hello:</span> <span class="comment"># 定义上面的服务用到的网桥名称 默认创建bridge</span></span><br><span class="line">    <span class="attr">external:</span></span><br><span class="line">      <span class="literal">false</span>  <span class="comment"># true 使用外部网桥</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210107103628719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210107103701729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2-测试相同网桥的容器通信"><a href="#2-测试相同网桥的容器通信" class="headerlink" title="2. 测试相同网桥的容器通信"></a>2. 测试相同网桥的容器通信</h3><p><font color='red'>运行的容器都放在一个网桥下面</font><br><img src="https://img-blog.csdnimg.cn/20210107104752482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><font color='red'>查看全部网桥</font><br><img src="https://img-blog.csdnimg.cn/20210107104802989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><font color='red'>安装curl命令</font></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">sudo</span> <span class="string">apt-get</span> <span class="string">update;</span> </span><br><span class="line"><span class="string">sudo</span> <span class="string">apt-get</span> <span class="string">install</span> <span class="string">curl</span></span><br></pre></td></tr></table></figure><p><font color='red'>curl直接测试tomcat02的地址首页—-容器名和主机号映射</font><br><img src="https://img-blog.csdnimg.cn/20210107104848646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210107104903349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="11-ports"><a href="#11-ports" class="headerlink" title="11. ports"></a>11. ports</h2><p>暴露端口信息。</p><p>使用宿主端口：容器端口 (HOST:CONTAINER) 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ports:</span>  <span class="comment">#相当于run 的 -p</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210107103731594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>注意：当使用 HOST:CONTAINER 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 YAML 会自动解析 xx:yy 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</p><h2 id="12-sysctls"><a href="#12-sysctls" class="headerlink" title="12. sysctls"></a>12. sysctls</h2><p>配置容器内核参数。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sysctls:</span>  <span class="comment"># 修改容器中系统内部参数 并不是必须的</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">net.core.somaxconn=1024</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">net.ipv4.tcp_syncookies=0</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210107104318521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="13-ulimits"><a href="#13-ulimits" class="headerlink" title="13. ulimits"></a>13. ulimits</h2><ol><li>指定容器的 ulimits 限制值。</li><li>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ulimits:</span>  <span class="comment"># 修改容器中系统内部进程数限制</span></span><br><span class="line">  <span class="attr">nproc:</span> <span class="number">65535</span></span><br><span class="line">  <span class="attr">nofile:</span></span><br><span class="line">    <span class="attr">soft:</span> <span class="number">20000</span></span><br><span class="line">    <span class="attr">hard:</span> <span class="number">40000</span></span><br></pre></td></tr></table></figure><p>  <img src="https://img-blog.csdnimg.cn/20210107104326908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="14-volumes"><a href="#14-volumes" class="headerlink" title="14. volumes"></a>14. volumes</h2><ol><li>数据卷所挂载路径设置。可以设置为宿主机路径或者数据卷名称，并且可以设置访问模式 （HOST:CONTAINER:ro）。该指令中路径支持相对路径。</li></ol><p><img src="https://img-blog.csdnimg.cn/20210107104522409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><font color='red'>启动compose—测试volume</font><br><img src="https://img-blog.csdnimg.cn/20210107104701204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><font color='red'>查看全部的数据卷</font><br><img src="https://img-blog.csdnimg.cn/20210107104710860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><font color='red'>查看数据卷同步的数据</font><br><img src="https://img-blog.csdnimg.cn/20210107104718296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="2"><li>如果路径为数据卷名称，必须在文件中配置数据卷。<br><img src="https://img-blog.csdnimg.cn/20210107104730162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span>  <span class="comment"># 必须声明上面服务所使用的自动创建的卷名</span></span><br><span class="line">  <span class="attr">tomcatwebapps01:</span> <span class="comment">#声明指定的卷名 compose自动创建卷名但是项目名会连接在一起</span></span><br><span class="line">    <span class="attr">external:</span>  <span class="comment">#使用自定义卷名</span></span><br><span class="line">      <span class="literal">false</span>      <span class="comment"># true使用外部卷名</span></span><br><span class="line">  <span class="attr">tomcatwebapps02:</span> <span class="comment">#声明指定的卷名 compose自动创建卷名但是项目名会连接在一起</span></span><br><span class="line">  <span class="attr">mysqldata:</span></span><br><span class="line">  <span class="attr">mysqlconf:</span></span><br><span class="line">  <span class="attr">redisdata:</span></span><br><span class="line">  <span class="attr">portainer_data:</span></span><br></pre></td></tr></table></figure><h2 id="15-compose-yml-Tomcat，mysql，Redis"><a href="#15-compose-yml-Tomcat，mysql，Redis" class="headerlink" title="15. compose.yml (Tomcat，mysql，Redis)"></a>15. compose.yml (Tomcat，mysql，Redis)</h2><p><font color='red'>这里放一份全部的测试配置文件(Tomcat，mysql，Redis)</font></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">demo:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="comment">#启动服务时先将build命令中指定dockerfile打包成镜像。再运行镜像</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">demo</span> <span class="comment"># 指定上下文目录</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">demo</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8081:8081&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hello</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">tomcat01</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="attr">tomcat01:</span> <span class="comment">#服务名唯一</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">tomcat01</span> <span class="comment"># 相当于run 的 --name</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">tomcat:8.0-jre8-slim</span> <span class="comment">#创建当前这个服务使用镜像是谁 相当于run 的 image</span></span><br><span class="line">    <span class="attr">ports:</span>  <span class="comment">#相当于run 的 -p</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span> <span class="comment">#完成宿主机与容器目录数据卷共享  相当于run 的 -v</span></span><br><span class="line"><span class="comment">#      - /root/apps:/usr/local/tomcat/webapps  #使用自定义路径映射</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">tomcatwebapps01:/usr/local/tomcat/webapps</span></span><br><span class="line">    <span class="attr">networks:</span> <span class="comment">#相当于run 的 --network</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hello</span></span><br><span class="line">    <span class="attr">depends_on:</span> <span class="comment">#代表这个容器必须依赖哪些容器启动之后才能启动</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">tomcat02</span> <span class="comment"># --服务名</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost&quot;</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">1m30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="attr">tomcat02:</span> <span class="comment">#服务名唯一</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">tomcat02</span> <span class="comment"># 相当于run 的 --name</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">tomcat:8.0-jre8-slim</span> <span class="comment">#创建当前这个服务使用镜像是谁</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;8082:8080&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span> <span class="comment">#完成宿主机与容器目录数据卷共享</span></span><br><span class="line">    <span class="comment">#      - /root/apps:/usr/local/tomcat/webapps  #使用自定义路径映射</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">tomcatwebapps02:/usr/local/tomcat/webapps</span></span><br><span class="line">    <span class="attr">networks:</span>  <span class="comment"># 代表当前服务使用哪个网络桥</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hello</span></span><br><span class="line"><span class="comment">#    sysctls:  # 修改容器中系统内部参数 并不是必须的</span></span><br><span class="line"><span class="comment">#    - net.core.somaxconn=1024</span></span><br><span class="line"><span class="comment">#    - net.ipv4.tcp_syncookies=0</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">ulimits:</span>  <span class="comment"># 修改容器中系统内部进程数限制</span></span><br><span class="line">      <span class="attr">nproc:</span> <span class="number">65535</span></span><br><span class="line">      <span class="attr">nofile:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">20000</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">40000</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7.32</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mysqldata:/var/lib/mysql</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mysqlconf:/etc/mysql</span></span><br><span class="line">    <span class="attr">env_file:</span> <span class="comment">#用来将environment环境中配置放入指定配置文件中</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql.env</span></span><br><span class="line"><span class="comment">#    environment:</span></span><br><span class="line"><span class="comment">#      MYSQL_ROOT_PASSWORD: root</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hello</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:5.0.10</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hello</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">redisdata:/data</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">&quot;redis-server --appendonly yes&quot;</span> <span class="comment">#run 镜像之后用来覆盖容器内默认命令</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">portainer:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">portainer/portainer</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">portainer</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">portainer_data:/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hello</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8000:8000&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9000:9000&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span>  <span class="comment"># 必须声明上面服务所使用的自动创建的卷名</span></span><br><span class="line">  <span class="attr">tomcatwebapps01:</span> <span class="comment">#声明指定的卷名 compose自动创建卷名但是项目名会连接在一起</span></span><br><span class="line">    <span class="attr">external:</span>  <span class="comment">#使用自定义卷名</span></span><br><span class="line">      <span class="literal">false</span>      <span class="comment"># true使用外部卷名</span></span><br><span class="line">  <span class="attr">tomcatwebapps02:</span> <span class="comment">#声明指定的卷名 compose自动创建卷名但是项目名会连接在一起</span></span><br><span class="line">  <span class="attr">mysqldata:</span></span><br><span class="line">  <span class="attr">mysqlconf:</span></span><br><span class="line">  <span class="attr">redisdata:</span></span><br><span class="line">  <span class="attr">portainer_data:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span> <span class="comment">#定义服务的网桥</span></span><br><span class="line">  <span class="attr">hello:</span> <span class="comment"># 定义上面的服务用到的网桥名称 默认创建bridge</span></span><br><span class="line">    <span class="attr">external:</span></span><br><span class="line">      <span class="literal">false</span>  <span class="comment"># true 使用外部网桥</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><font color='red'>连接测试</font></p><p><img src="https://img-blog.csdnimg.cn/20210107105901779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210107105905572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210107110002383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210107110007856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210107110023625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="三-docker-compose-常用命令"><a href="#三-docker-compose-常用命令" class="headerlink" title="三. docker-compose 常用命令"></a>三. docker-compose 常用命令</h1><h2 id="1-模板指令和指令区别"><a href="#1-模板指令和指令区别" class="headerlink" title="1. 模板指令和指令区别"></a>1. 模板指令和指令区别</h2><ol><li>模板指令:用来书写在docker-compose.yml文件中指令称之为模板指令用来为服务进行服务的。</li><li>指令:用来对整个docker - compose . ym1对应的这个项目操作书写docker - cou pose命令之后命令。</li></ol><h2 id="2-help帮助命令"><a href="#2-help帮助命令" class="headerlink" title="2. help帮助命令"></a>2. help帮助命令</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行 docker-compose [COMMAND] --help </span><br><span class="line">或者 docker-compose help [COMMAND] 可以查看具体某个命令的使用格式。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210107110606937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-命令选项"><a href="#3-命令选项" class="headerlink" title="3.  命令选项"></a>3.  命令选项</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-f, --file FILE 指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。</span><br><span class="line">-p, --project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。</span><br><span class="line">--x-networking 使用 Docker 的可拔插网络后端特性</span><br><span class="line">--x-network-driver DRIVER 指定网络后端的驱动，默认为 bridge</span><br><span class="line">--verbose 输出更多调试信息。</span><br><span class="line">-v, --version 打印版本并退出。</span><br></pre></td></tr></table></figure><h2 id="4-up"><a href="#4-up" class="headerlink" title="4 .up"></a>4 .up</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式为 docker-compose up [options] [SERVICE...]。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210107111533872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</li><li>链接的服务都将会被自动启动，除非已经处于运行状态。</li><li>可以说，大部分时候都可以直接通过该命令来启动一个项目。</li><li>默认情况，docker-compose up 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</li><li>当通过 Ctrl-C 停止命令时，所有容器将会停止。</li><li>如果使用 docker-compose up -d，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</li><li>默认情况，如果服务容器已经存在，docker-compose up 将会尝试停止容器，然后重新创建（保持使用 volumes-from 挂载的卷），以保证新启动的服务匹配 docker-compose.yml 文件的最新内容</li></ol><hr><h2 id="5-down"><a href="#5-down" class="headerlink" title="5 . down"></a>5 . down</h2><p>此命令将会停止 up 命令所启动的容器，并移除网络<br><img src="https://img-blog.csdnimg.cn/2021010711083756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="6-exec"><a href="#6-exec" class="headerlink" title="6 . exec"></a>6 . exec</h2><p> 进入指定的容器。<br><img src="https://img-blog.csdnimg.cn/20210107110906968.png" alt="在这里插入图片描述"></p><h2 id="7-ps"><a href="#7-ps" class="headerlink" title="7. ps"></a>7. ps</h2><p>列出项目中目前的所有容器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker-compose ps [options] [SERVICE...]。</span><br><span class="line">选项：</span><br><span class="line">- -q 只打印容器的 ID 信息</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2021010711100044.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="8-restart"><a href="#8-restart" class="headerlink" title="8 . restart"></a>8 . restart</h2><p>重启项目中的服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> docker-compose restart [options] [SERVICE...]。</span><br><span class="line">选项：</span><br><span class="line">- -t, --timeout TIMEOUT 指定重启前停止容器的超时（默认为 <span class="number">10</span> 秒）。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210107111043794.png" alt="在这里插入图片描述"></p><h2 id="9-rm"><a href="#9-rm" class="headerlink" title="9 . rm"></a>9 . rm</h2><p>删除所有（停止状态的）服务容器。推荐先执行 docker-compose stop 命令来停止容器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> docker-compose rm [options] [SERVICE...]。</span><br><span class="line">选项：</span><br><span class="line">-f, --force 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</span><br><span class="line">-v 删除容器所挂载的数据卷。</span><br></pre></td></tr></table></figure><h2 id="10-start"><a href="#10-start" class="headerlink" title="10. start"></a>10. start</h2><p>启动已经存在的服务容器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose start [SERVICE...]。</span><br></pre></td></tr></table></figure><h2 id="11-stop"><a href="#11-stop" class="headerlink" title="11. stop"></a>11. stop</h2><p>停止已经处于运行状态的容器，但不删除它。通过 docker-compose start 可以再次启动这些容器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop [options] [SERVICE...]。</span><br><span class="line">选项：</span><br><span class="line">- -t, --timeout TIMEOUT 停止容器时候的超时（默认为 <span class="number">10</span> 秒）。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="12-top"><a href="#12-top" class="headerlink" title="12. top"></a>12. top</h2><p>查看各个服务容器内运行的进程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose top[SERVICE...]。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210107111454584.png" alt="在这里插入图片描述"></p><h2 id="13-unpause"><a href="#13-unpause" class="headerlink" title="13. unpause"></a>13. unpause</h2><p>恢复处于暂停状态中的服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose unpause [SERVICE...]。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210107111341872.png" alt="在这里插入图片描述"></p><h2 id="14-pause"><a href="#14-pause" class="headerlink" title="14. pause"></a>14. pause</h2><p>暂停服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose pause [SERVICE...]。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210107111334652.png" alt="在这里插入图片描述"></p><h2 id="15-logs"><a href="#15-logs" class="headerlink" title="15. logs"></a>15. logs</h2><p>查看日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose logs[SERVICE...]。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210107111415651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/2022/07/04/Docker/"/>
      <url>/2022/07/04/Docker/</url>
      
        <content type="html"><![CDATA[<h1 id="一-Docker镜像操作"><a href="#一-Docker镜像操作" class="headerlink" title="一. Docker镜像操作"></a>一. Docker镜像操作</h1><ol><li>镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时所需的库、环境变量和配置文件。</li></ol><h2 id="1-查看docker引擎以及docker帮助命令"><a href="#1-查看docker引擎以及docker帮助命令" class="headerlink" title="1.查看docker引擎以及docker帮助命令"></a>1.查看docker引擎以及docker帮助命令</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version----------------查看docker的信息</span><br><span class="line">docker info------------------查看更详细的信息</span><br><span class="line">docker --help-----------------帮助命令</span><br></pre></td></tr></table></figure><h2 id="2-查看本机中所有镜像"><a href="#2-查看本机中所有镜像" class="headerlink" title="2.查看本机中所有镜像"></a>2.查看本机中所有镜像</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker images------------列出本地所有镜像</span><br><span class="line"> -a列出所有镜像（包含中间映像层）</span><br><span class="line">   -q只显示镜像id</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210104100143702.png" alt="在这里插入图片描述"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]# docker images</span><br><span class="line">REPOSITORY       TAG             IMAGE ID       CREATED             SIZE</span><br><span class="line">mysql            5.7             f07dfa83b528   13 days ago         448MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#解释</span><br><span class="line">REPOSITORY   镜像的仓库源</span><br><span class="line">TAG          镜像的标签</span><br><span class="line">IMAGE ID    镜像的id</span><br><span class="line">CREATED      镜像的创建时间</span><br><span class="line">SIZE         镜像的大小</span><br></pre></td></tr></table></figure><h2 id="3-搜索镜像"><a href="#3-搜索镜像" class="headerlink" title="3.搜索镜像"></a>3.搜索镜像</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker search [options] 镜像名---- 去dockerhub上查询当前镜像</span><br><span class="line">--filter=STARS=指定值     ---- 列出收藏数不少于指定值的镜像</span><br><span class="line">     --no-trunc                ---- 显示完整的镜像信息</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210104100756571.png" alt="在这里插入图片描述"></p><h2 id="4-从仓库下载镜像"><a href="#4-从仓库下载镜像" class="headerlink" title="4.从仓库下载镜像"></a>4.从仓库下载镜像</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名[:TAG|<span class="meta">@DIGEST</span>]-------------- 下载镜像</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210104100843373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="5-删除镜像"><a href="#5-删除镜像" class="headerlink" title="5.删除镜像"></a>5.删除镜像</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker image rm   镜像名:tag |镜像id</span><br><span class="line">docker image rm -f 镜像名:tag |镜像id (强制删除)</span><br><span class="line"></span><br><span class="line">docker rmi -f 镜像名:tag |镜像id (简化写法)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210104104540306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="二-容器相关操作"><a href="#二-容器相关操作" class="headerlink" title="二.容器相关操作"></a>二.容器相关操作</h1><h2 id="1-运行容器"><a href="#1-运行容器" class="headerlink" title="1.运行容器"></a>1.运行容器</h2><blockquote><p>容器: 镜像每次运行之后就是产生一个容器,就是正在运行的镜像,特点就是可读可写</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run 镜像名--------镜像名新建并启动容器</span><br><span class="line">   --name     别名为容器起一个名字</span><br><span class="line">   -d启动守护式容器（在后台启动容器）</span><br><span class="line">   -p 映射端口号：原始端口号------指定端口号启动</span><br></pre></td></tr></table></figure><p><font color='red' size=5> DockerHub上拉取tomcat，并运行起来</font><br><img src="https://img-blog.csdnimg.cn/20210104163219804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><font color='red' size=5>1. 映射端口运行容器</font><br><img src="https://img-blog.csdnimg.cn/20210104155818655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><font color='red' size=5>2.  后台启动+映射端口启动容器</font></p><blockquote><p>docker run -d :p 8082:8080 tomcat:8.0-tre8-stim</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210104160033946.png" alt="在这里插入图片描述"><font color='red' size=5>3.  访问测试</font><br><img src="https://img-blog.csdnimg.cn/20210104161619233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-查看运行的容器"><a href="#2-查看运行的容器" class="headerlink" title="2.查看运行的容器"></a>2.查看运行的容器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps--------------------------列出所有正在运行的容器</span><br><span class="line">-a正在运行的和历史运行过的容器</span><br><span class="line">-q静默模式，只显示容器编号</span><br></pre></td></tr></table></figure><p><font color='red' size=5>1. 查看当前运行的容器</font></p><blockquote><p>docker ps</p><p><img src="https://img-blog.csdnimg.cn/20210104155803463.png" alt="在这里插入图片描述"><br><font color='red' size=5> 2. 正在运行的和历史运行过的容器</font><br>docker ps -a</p><p><img src="https://img-blog.csdnimg.cn/20210104160237478.png" alt="在这里插入图片描述"></p></blockquote><h2 id="3-停止-关闭-重启容器"><a href="#3-停止-关闭-重启容器" class="headerlink" title="3.停止|关闭|重启容器"></a>3.停止|关闭|重启容器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start   容器名字或者容器id  --------------- 开启容器</span><br><span class="line">docker restart 容器名或者容器id    --------------- 重启容器</span><br><span class="line">docker stop  容器名或者容器id     ------------------ 正常停止容器运行</span><br><span class="line">docker kill  容器名或者容器id      ------------------ 立即停止容器运行</span><br></pre></td></tr></table></figure><p><font color='red' size=5>1. 启动一个容器，其他的就不测试了</font></p><blockquote><pre><code>    docker start   容器名字或者容器id  --------------- 开启容器![在这里插入图片描述](https://img-blog.csdnimg.cn/20210104160523417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70)</code></pre></blockquote><h2 id="4-删除容器"><a href="#4-删除容器" class="headerlink" title="4.删除容器"></a>4.删除容器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f 容器id和容器名     </span><br><span class="line">docker rm -f $(docker ps -aq)--------------------------删除所有容器</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>docker rm -f $(docker ps -aq)</p><p><img src="https://img-blog.csdnimg.cn/20210104160655482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><h2 id="5-查看容器内进程"><a href="#5-查看容器内进程" class="headerlink" title="5.查看容器内进程"></a>5.查看容器内进程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器id或者容器名 ------------------ 查看容器内的进程</span><br></pre></td></tr></table></figure><p>  <img src="https://img-blog.csdnimg.cn/20210104160806467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="6-查看查看容器内部细节"><a href="#6-查看查看容器内部细节" class="headerlink" title="6.查看查看容器内部细节"></a>6.查看查看容器内部细节</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器id ------------------ 查看容器内部细节</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210104160952467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="7-查看容器的运行日志"><a href="#7-查看容器的运行日志" class="headerlink" title="7.查看容器的运行日志"></a>7.查看容器的运行日志</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker logs [OPTIONS] 容器id或容器名------------------ 查看容器日志</span><br><span class="line">   -t 加入时间戳</span><br><span class="line">   -f 跟随最新的日志打印</span><br><span class="line">   --tail  数字显示最后多少条</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210104161213738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="8-进入容器内部"><a href="#8-进入容器内部" class="headerlink" title="8.进入容器内部"></a>8.进入容器内部</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器id|容器名 bash(命令行) ====&gt; 进入容器,并与容器内命令终端进行交互</span><br><span class="line">退出容器 exit</span><br><span class="line"></span><br><span class="line">-i以交互模式运行容器，通常与-t一起使用</span><br><span class="line">   -t分配一个伪终端    shell窗口   bash</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210104161416349.png" alt="在这里插入图片描述"></p><h2 id="9-容器和宿主机之间复制文件"><a href="#9-容器和宿主机之间复制文件" class="headerlink" title="9.容器和宿主机之间复制文件"></a>9.容器和宿主机之间复制文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 文件|目录 容器id:容器路径           -----------------   将宿主机复制到容器内部</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210104161541763.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器id:容器内资源路径 宿主机目录路径  -----------------   将容器内资源拷贝到主机上</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210104161518970.png" alt="在这里插入图片描述"></p><h2 id="10-数据卷-volum-实现与宿主机共享目录"><a href="#10-数据卷-volum-实现与宿主机共享目录" class="headerlink" title="10.数据卷(volum)实现与宿主机共享目录"></a>10.数据卷(volum)实现与宿主机共享目录</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v 宿主机的路径|任意别名:/容器内的路径 镜像名</span><br></pre></td></tr></table></figure><h3 id="1-自定义数据卷"><a href="#1-自定义数据卷" class="headerlink" title="1. 自定义数据卷"></a>1. 自定义数据卷</h3><blockquote><p>自定义数据卷:如果是宿主机路径必须是绝对路径,宿主机目录会覆盖容器内目录内容</p><p><img src="https://img-blog.csdnimg.cn/20210104162143595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210104162150974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210104162154987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><h3 id="2-自动数据卷目录"><a href="#2-自动数据卷目录" class="headerlink" title="2. 自动数据卷目录"></a>2. 自动数据卷目录</h3><blockquote><p>如果是别名则会在docker运行容器时自动在宿主机中创建一个目录,并将容器目录文件复制到宿主机中</p><p><img src="https://img-blog.csdnimg.cn/20210104162207714.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210104162210947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210104162216814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210104162222277.png" alt="在这里插入图片描述"></p></blockquote><h2 id="11-打包镜像"><a href="#11-打包镜像" class="headerlink" title="11.打包镜像"></a>11.打包镜像</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save 镜像名 -o  名称.tar</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210104162436690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="12-载入镜像"><a href="#12-载入镜像" class="headerlink" title="12.载入镜像"></a>12.载入镜像</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i   名称.tar</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210104162312387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="13-容器打包成新的镜像"><a href="#13-容器打包成新的镜像" class="headerlink" title="13.容器打包成新的镜像"></a>13.容器打包成新的镜像</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m <span class="string">&quot;描述信息&quot;</span> -a <span class="string">&quot;作者信息&quot;</span>   （容器id或者名称）打包的镜像名称:标签</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210104162241191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><font color='red' size=5>1. 直接启动新的镜像测试</font><br><img src="https://img-blog.csdnimg.cn/20210104162251550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="三-网络配置"><a href="#三-网络配置" class="headerlink" title="三. 网络配置"></a>三. 网络配置</h1><ol><li><p>当 Docker 启动时，会自动在主机上创建一个 docker0 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p></li><li><p>Docker 随机分配一个本地未占用的私有网段（在 RFC1918 中定义）中的一个地址给 docker0 接口。</p></li><li><p>当创建一个 Docker 容器的时候，同时会创建了一对 veth pair 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 eth0；另一端在本地并被挂载到 docker0 网桥，名称以 veth 开头。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。</p></li></ol><p><img src="https://img-blog.csdnimg.cn/20210105135918158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-查看网络信息"><a href="#1-查看网络信息" class="headerlink" title="1.  查看网络信息"></a>1.  查看网络信息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210105135807442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-创建一个网桥"><a href="#2-创建一个网桥" class="headerlink" title="2. 创建一个网桥"></a>2. 创建一个网桥</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d bridge 网桥名称</span><br></pre></td></tr></table></figure><p><font color='red' size=5>创建网桥 -d bridge 可以省略</font><br><img src="https://img-blog.csdnimg.cn/20210105135817385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4-查看网桥的详细信息"><a href="#4-查看网桥的详细信息" class="headerlink" title="4. 查看网桥的详细信息"></a>4. 查看网桥的详细信息</h2><p><img src="https://img-blog.csdnimg.cn/20210105140646687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210105140658707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-删除一个网桥"><a href="#3-删除一个网桥" class="headerlink" title="3. 删除一个网桥"></a>3. 删除一个网桥</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network rm 网桥名称</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210105135836553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4-容器之前使用网络通信"><a href="#4-容器之前使用网络通信" class="headerlink" title="4. 容器之前使用网络通信"></a>4. 容器之前使用网络通信</h2><h3 id="1-启动Tomcat容器指定使用网桥"><a href="#1-启动Tomcat容器指定使用网桥" class="headerlink" title="1.启动Tomcat容器指定使用网桥"></a>1.启动Tomcat容器指定使用网桥</h3><ul><li><font color='red' >这里使用Tomcat容器来测试</font></li><li><font color='red'>注意:使用dockerrun指定–network网桥时网桥必须存在</font></li><li><font color='red' >注意:一旦指定网桥后–name指定名字就是主机名,多个容器指定在同一个网桥时,可以在任意一个容器中使用主机名与容器进行互通</font></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p <span class="number">8080</span>:<span class="number">8080</span> --name tomcat --network ems tomcat:<span class="number">8.0</span>-jre8-slim</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210105140257956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2-在自定义网桥上创建两个Tomcat容器测试通信"><a href="#2-在自定义网桥上创建两个Tomcat容器测试通信" class="headerlink" title="2.在自定义网桥上创建两个Tomcat容器测试通信"></a>2.在自定义网桥上创建两个Tomcat容器测试通信</h3><p><font color='red' >可以查看当前网桥上容器的信息</font><br><img src="https://img-blog.csdnimg.cn/20210105140807110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h3><p><font color='red' >我这Tomcat容器没有装curl命令，执行无效</font><br><img src="https://img-blog.csdnimg.cn/2021010514213826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><font color='red' >我就在宿主机上测试一下，看一下效果</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http:<span class="comment">//192.168.153.170:8080</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210105141601698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="四-数据卷配置"><a href="#四-数据卷配置" class="headerlink" title="四. 数据卷配置"></a>四. 数据卷配置</h1><p>数据卷是一个可供一个或多个容器使用的特殊目录</p><ul><li>数据卷 可以在容器之间共享和重用</li><li>对 数据卷 的修改会立马生效</li><li>对 数据卷 的更新，不会影响镜像</li><li>数据卷 默认会一直存在，即使容器被删除</li></ul><p>注意：数据卷 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p><h2 id="1-创建数据卷"><a href="#1-创建数据卷" class="headerlink" title="1.创建数据卷"></a>1.创建数据卷</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker volume create 数据卷名称/id</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210105142939611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-查看全部数据卷"><a href="#2-查看全部数据卷" class="headerlink" title="2.查看全部数据卷"></a>2.查看全部数据卷</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls</span><br></pre></td></tr></table></figure><p> <img src="https://img-blog.csdnimg.cn/20210105142929213.png" alt="在这里插入图片描述"></p><h2 id="3-查看数据卷详细信息"><a href="#3-查看数据卷详细信息" class="headerlink" title="3.查看数据卷详细信息"></a>3.查看数据卷详细信息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect 数据卷名称/id     </span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210105143057291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4-启动容器使用数据卷"><a href="#4-启动容器使用数据卷" class="headerlink" title="4.启动容器使用数据卷"></a>4.启动容器使用数据卷</h2><h3 id="1-宿主机和容器两边共享"><a href="#1-宿主机和容器两边共享" class="headerlink" title="1. 宿主机和容器两边共享"></a>1. 宿主机和容器两边共享</h3><p><img src="https://img-blog.csdnimg.cn/20210105143200818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><font color='red'>测试共享—-容器中创建目录</font><br><img src="https://img-blog.csdnimg.cn/20210105143557163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><font color='red'>测试共享—-宿主机只能生成共享文件</font><br><img src="https://img-blog.csdnimg.cn/20210105143551882.png" alt="在这里插入图片描述"></p><h3 id="2-设置容器这边只能读权限"><a href="#2-设置容器这边只能读权限" class="headerlink" title="2. 设置容器这边只能读权限"></a>2. 设置容器这边只能读权限</h3><p><font color='red'>在容器路径后面追加 :ro</font><br><img src="https://img-blog.csdnimg.cn/20210105143318853.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210105143329128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4-删除数据卷"><a href="#4-删除数据卷" class="headerlink" title="4. 删除数据卷"></a>4. 删除数据卷</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm 数据卷名称/id</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210105143523659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume prune</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210105143453239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="五-Dockerfile解释"><a href="#五-Dockerfile解释" class="headerlink" title="五 . Dockerfile解释"></a>五 . Dockerfile解释</h1><ol><li>Dockerfile可以认为是Docker镜像的描述文件，是由一系列命令和参数构成的脚本。主要作用是用来构建docker镜像的构建文件。DockerFile可以直接构建镜像。<br><img src="https://img-blog.csdnimg.cn/2021010708212456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><h2 id="1-Dockerfile解析过程图"><a href="#1-Dockerfile解析过程图" class="headerlink" title="1 . Dockerfile解析过程图"></a>1 . Dockerfile解析过程图</h2><p><img src="https://img-blog.csdnimg.cn/20210107082229702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-Dockerfile的保留命令"><a href="#2-Dockerfile的保留命令" class="headerlink" title="2. Dockerfile的保留命令"></a>2. Dockerfile的保留命令</h2><h3 id="1-FROM"><a href="#1-FROM" class="headerlink" title="1.  FROM"></a>1.  FROM</h3><p>基于那个镜像进行构建新的镜像,在构建时会自动从docker hub拉取base镜像 必须作为Dockerfile的第一个指令出现  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM  &lt;image&gt;</span><br><span class="line">FROM  &lt;image&gt;[:&lt;tag&gt;]     使用版本不写为latest</span><br><span class="line">FROM  &lt;image&gt;[@&lt;digest&gt;]  使用摘要</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210107084140556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2-MAINTAINER"><a href="#2-MAINTAINER" class="headerlink" title="2.   MAINTAINER"></a>2.   MAINTAINER</h3><p>镜像维护者的姓名和邮箱地址[废弃]  —不演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER &lt;name&gt;</span><br></pre></td></tr></table></figure><h3 id="3-RUN"><a href="#3-RUN" class="headerlink" title="3.  RUN"></a>3.  RUN</h3><p>RUN指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于Dockerfile中的下一步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//命令形式</span></span><br><span class="line">RUN &lt;command&gt; </span><br><span class="line"><span class="comment">//数组形式</span></span><br><span class="line">RUN [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>] </span><br></pre></td></tr></table></figure><p>   <font color='red'>进入容器都是没有Vim编辑命名，我们使用RUN命令自动创建</font><br><img src="https://img-blog.csdnimg.cn/20210107084427118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><font color='red'>使用普通形式运行命令</font><br><img src="https://img-blog.csdnimg.cn/2021010708443696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><font color='red'>使用数组形式运行命令</font><br><img src="https://img-blog.csdnimg.cn/20210107085301599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><font color='red'>RUN 使用yum直接报错</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Could not retrieve mirrorlist http:<span class="comment">//mirrorlist.centos.org/?release=7&amp;arch=x86_64&amp;repo=os&amp;infra=container error was</span></span><br><span class="line"><span class="number">12</span>: Timeout on http:<span class="comment">//mirrorlist.centos.org/?release=7&amp;arch=x86_64&amp;repo=os&amp;infra=container: (28, &#x27;Resolving timed out after 30566 milliseconds&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> One of the configured repositories <span class="title function_">failed</span> <span class="params">(Unknown)</span>,</span><br><span class="line"> and yum doesn<span class="string">&#x27;t have enough cached data to continue. At this point the only</span></span><br><span class="line"><span class="string"> safe thing yum can do is fail. There are a few ways to work &quot;fix&quot; this:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">     1. Contact the upstream for the repository and get them to fix the problem.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">     2. Reconfigure the baseurl/etc. for the repository, to point to a working</span></span><br><span class="line"><span class="string">        upstream. This is most often useful if you are using a newer</span></span><br><span class="line"><span class="string">        distribution release than is supported by the repository (and the</span></span><br><span class="line"><span class="string">        packages for the previous distribution release still work).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">     3. Run the command with the repository temporarily disabled</span></span><br><span class="line"><span class="string">            yum --disablerepo=&lt;repoid&gt; ...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">     4. Disable the repository permanently, so yum won&#x27;</span>t use it by <span class="keyword">default</span>. Yum</span><br><span class="line">        will then just ignore the repository until you permanently enable it</span><br><span class="line">        again or use --enablerepo <span class="keyword">for</span> temporary usage:</span><br><span class="line"></span><br><span class="line">            yum-config-manager --disable &lt;repoid&gt;</span><br><span class="line">        or</span><br><span class="line">            subscription-manager repos --disable=&lt;repoid&gt;</span><br><span class="line"></span><br><span class="line">     <span class="number">5.</span> Configure the failing repository to be skipped, <span class="keyword">if</span> it is unavailable.</span><br><span class="line">        Note that yum will <span class="keyword">try</span> to contact the repo. when it runs most commands,</span><br><span class="line">        so will have to <span class="keyword">try</span> and fail each <span class="title function_">time</span> <span class="params">(and thus. yum will be be much</span></span><br><span class="line"><span class="params">        slower)</span>. If it is a very temporary problem though, <span class="built_in">this</span> is often a nice</span><br><span class="line">        compromise:</span><br><span class="line"></span><br><span class="line">            yum-config-manager --save --setopt=&lt;repoid&gt;.skip_if_unavailable=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Cannot find a valid baseurl <span class="keyword">for</span> repo: base/<span class="number">7</span>/x86_64</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210107084442951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>   <font color='red'>解决方案修改resolv.conf配置文件</font><br><img src="https://img-blog.csdnimg.cn/20210107084504137.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210107084507666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>   <font color='red'>再次运行Dockerfile，Vim安装成功</font><br><img src="https://img-blog.csdnimg.cn/20210107084522744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><font color='red'>进入容器测试Vim命令</font><br><img src="https://img-blog.csdnimg.cn/20210107084538487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="4-EXPOSE"><a href="#4-EXPOSE" class="headerlink" title="4. EXPOSE"></a>4. EXPOSE</h3><p>用来指定构建的镜像在运行为容器时对外暴露的端口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE <span class="number">80</span>/tcp  如果没有显示指定则默认暴露都是tcp</span><br><span class="line">EXPOSE <span class="number">80</span>/udp</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210107085550238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="5-WORKDIR"><a href="#5-WORKDIR" class="headerlink" title="5.WORKDIR"></a>5.WORKDIR</h3><p>用来为Dockerfile中的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。如果WORKDIR不存在，即使它没有在任何后续Dockerfile指令中使用，它也将被创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /path/to/workdir</span><br><span class="line"></span><br><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">注意:WORKDIR指令可以在Dockerfile中多次使用。如果提供了相对路径，则该路径将与先前WORKDIR指令的路径相对</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210107085556923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210107085606964.png" alt="在这里插入图片描述"></p><h3 id="7-ADD"><a href="#7-ADD" class="headerlink" title="7.   ADD"></a>7.   ADD</h3><p>用来从context上下文复制新文件、目录或远程文件url，并将它们添加到位于指定路径的映像文件系统中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ADD hom* /mydir/       通配符添加多个文件</span><br><span class="line">ADD hom?.txt /mydir/   通配符添加</span><br><span class="line">ADD test.txt relativeDir/  可以指定相对路径</span><br><span class="line">ADD test.txt /absoluteDir/ 也可以指定绝对路径</span><br><span class="line">ADD url </span><br></pre></td></tr></table></figure><h4 id="1-测试ADD复制文件"><a href="#1-测试ADD复制文件" class="headerlink" title="1. 测试ADD复制文件"></a>1. 测试ADD复制文件</h4><p><img src="https://img-blog.csdnimg.cn/20210107085755635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021010708580498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="2-测试ADD命令URL自动下载和解压tar"><a href="#2-测试ADD命令URL自动下载和解压tar" class="headerlink" title="2. 测试ADD命令URL自动下载和解压tar"></a>2. 测试ADD命令URL自动下载和解压tar</h4><p><font color='red'>1. Dockerfile直接ADD后放下载地址</font><br><img src="https://img-blog.csdnimg.cn/20210107085810132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210107090342982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><font color='red'>2. 宿主机下载安装包,ADD直接拷贝&#x2F;解压—测试</font><br><img src="https://img-blog.csdnimg.cn/20210107090348341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210107090351970.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210107090356369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210107090402346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>   <font color='red'>3. 修改文件的名称使用RUN</font><br><img src="https://img-blog.csdnimg.cn/20210107090417968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210107090430483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="8-ENV"><a href="#8-ENV" class="headerlink" title="8.   ENV"></a>8.   ENV</h3><p>用来为构建镜像设置环境变量。这个值将出现在构建阶段中所有后续指令的环境中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure><p><font color='red'>将出现多次的路径设置成公共变量–$直接使用</font><br><img src="https://img-blog.csdnimg.cn/2021010709124341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210107091248120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="9-COPY"><a href="#9-COPY" class="headerlink" title="9.   COPY"></a>9.   COPY</h3><p>用来将context目录中指定文件复制到镜像的指定目录中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY src dest</span><br><span class="line">COPY [<span class="string">&quot;&lt;src&gt;&quot;</span>,... <span class="string">&quot;&lt;dest&gt;&quot;</span>]</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210107085709662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210107085647200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="10-VOLUME"><a href="#10-VOLUME" class="headerlink" title="10.   VOLUME"></a>10.   VOLUME</h3><p>容器数据卷，用于数据保存和持久化工作      </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VOLUME /data</span><br><span class="line"><span class="comment">//数组形式</span></span><br><span class="line">VOLUME [<span class="string">&quot;/data&quot;</span>]</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210107091224569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><font color='red'>启动Docker构建成的镜像，测试文件共享</font><br><img src="https://img-blog.csdnimg.cn/20210107091230318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="11-ENTRYPOINT"><a href="#11-ENTRYPOINT" class="headerlink" title="11.   ENTRYPOINT"></a>11.   ENTRYPOINT</h3><p>指定一个容器启动时要运行的命令，ENTRYPOINT指令，往往用于设置容器启动后的第一个命令，这对一个容器来说往往是固定的。<br><img src="https://img-blog.csdnimg.cn/20210107091311183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p> <img src="https://img-blog.csdnimg.cn/2021010709132349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="12-CMD"><a href="#12-CMD" class="headerlink" title="12.   CMD"></a>12.   CMD</h3><ol><li>用来为启动的容器指定执行的命令,在Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</li><li>Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</li><li>CMD指令，往往用于设置容器启动的第一个命令的默认参数，这对一个容器来说可以是变化的。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//命令形式</span></span><br><span class="line">CMD command param1 param2 </span><br><span class="line"><span class="comment">//数组形式</span></span><br><span class="line">CMD [<span class="string">&quot;executable&quot;</span>,<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>] </span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210107091333242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210107091339777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><font color='red'>cmd直接覆盖命令</font><br><img src="https://img-blog.csdnimg.cn/2021010709134577.png" alt="在这里插入图片描述"><br><font color='red'>entrypoint指定参数覆盖命令</font><br><img src="https://img-blog.csdnimg.cn/20210107091351382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><font color='red'>entrypoint和cmd配合使用</font><br><img src="https://img-blog.csdnimg.cn/20210107091410204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210107091400352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>​                </p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法板子</title>
      <link href="/2021/12/07/%E7%AE%97%E6%B3%95%E6%9D%BF%E5%AD%90/"/>
      <url>/2021/12/07/%E7%AE%97%E6%B3%95%E6%9D%BF%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h1 id="一-基础知识点"><a href="#一-基础知识点" class="headerlink" title="一.基础知识点"></a>一.基础知识点</h1><h2 id="1-最大公约数和最小公倍数"><a href="#1-最大公约数和最小公倍数" class="headerlink" title="1. 最大公约数和最小公倍数"></a>1. 最大公约数和最小公倍数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大公约数</span></span><br><span class="line"> gcd(<span class="type">int</span> a,<span class="type">int</span> b)&#123;</span><br><span class="line"> <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line"> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//最小公倍数</span></span><br><span class="line">lcm(<span class="type">int</span> a,<span class="type">int</span> b)&#123;</span><br><span class="line"><span class="keyword">return</span> a*b/gcd(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-优先队列"><a href="#2-优先队列" class="headerlink" title="2. 优先队列"></a>2. 优先队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认从小到大</span></span><br><span class="line">Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line"> <span class="comment">//直接修改这里从大到小</span></span><br><span class="line"><span class="keyword">return</span> o1-o2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-Arrays-sort-自定义降序和升序"><a href="#3-Arrays-sort-自定义降序和升序" class="headerlink" title="3. Arrays.sort() _自定义降序和升序"></a>3. Arrays.sort() _自定义降序和升序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr=<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line"><span class="comment">//升序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">    System.out.print(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">//降序</span></span><br><span class="line">Arrays.sort(arr,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o2-o1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="4-快速判断回文数"><a href="#4-快速判断回文数" class="headerlink" title="4.快速判断回文数"></a>4.快速判断回文数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断回文数</span></span><br><span class="line"> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String str)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">StringBuilder</span>(str).reverse().toString();</span><br><span class="line"><span class="keyword">return</span> str.equals(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-等差数列和等比数列求前N项和公式"><a href="#5-等差数列和等比数列求前N项和公式" class="headerlink" title="5. 等差数列和等比数列求前N项和公式"></a>5. 等差数列和等比数列求前N项和公式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">等差数列和公式</span><br><span class="line">Sn=n(a1+an)/<span class="number">2</span>=na1+n(n-<span class="number">1</span>)/<span class="number">2</span> d</span><br><span class="line">等比数列求和公式</span><br><span class="line">q≠<span class="number">1</span>时 Sn=a1(<span class="number">1</span>-q^n)/(<span class="number">1</span>-q)</span><br></pre></td></tr></table></figure><h2 id="6-复数乘法"><a href="#6-复数乘法" class="headerlink" title="6.复数乘法"></a>6.复数乘法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">复数乘法：(a+b*i)*(c+d*i)=(a*c-b*d)+(b*c+a*d)i</span><br></pre></td></tr></table></figure><h2 id="7-进制转换API"><a href="#7-进制转换API" class="headerlink" title="7.进制转换API"></a>7.进制转换API</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//十进制转换成n进制</span></span><br><span class="line">System.out.println(Integer.toString(<span class="number">132</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//n进制转换成十进制</span></span><br><span class="line">System.out.println(Integer.valueOf(<span class="string">&quot;3f3f3f3f&quot;</span>,<span class="number">16</span>));<span class="comment">//这里代表字符串使用16进制表示</span></span><br><span class="line"><span class="comment">//使用大数进行转换</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;3f3f3f3f&quot;</span>, <span class="number">16</span>));</span><br></pre></td></tr></table></figure><h2 id="8-取模的技巧（用于处理非常大的数据"><a href="#8-取模的技巧（用于处理非常大的数据" class="headerlink" title="8.  取模的技巧（用于处理非常大的数据"></a>8.  取模的技巧（用于处理非常大的数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(a * b)  % c  =  ((a % c) * (b % c) ) % c</span><br><span class="line"></span><br><span class="line">(a + b)  % c  =  ((a % c) + (b % c) ) % c</span><br></pre></td></tr></table></figure><h2 id="9-字符转数字互转换"><a href="#9-字符转数字互转换" class="headerlink" title="9.  字符转数字互转换"></a>9.  字符转数字互转换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> System.out.println(<span class="string">&#x27;9&#x27;</span>-<span class="string">&#x27;0&#x27;</span>);  <span class="comment">//将字符减去 &#x27;0&#x27; 的到的就是数字　　</span></span><br><span class="line"><span class="number">2.</span> System.out.println((<span class="type">char</span>)(<span class="number">1</span>+<span class="string">&#x27;a&#x27;</span>));<span class="comment">//数字转换为字符</span></span><br><span class="line"><span class="number">3.</span> Character.isLetter() <span class="comment">//判断字符是否为字母</span></span><br><span class="line"><span class="number">4.</span> System.out.println(Character.isDigit(<span class="string">&#x27;2&#x27;</span>)); <span class="comment">//是否是数字</span></span><br><span class="line"><span class="number">5.</span> System.out.println(Character.isLetter(<span class="string">&#x27;2&#x27;</span>));<span class="comment">//是否是字母</span></span><br><span class="line"><span class="number">6.</span> System.out.println(Character.isWhitespace(<span class="string">&#x27; &#x27;</span>));<span class="comment">//是否是空格</span></span><br><span class="line"><span class="number">7.</span> System.out.println(Character.isUpperCase(<span class="string">&#x27;2&#x27;</span>));<span class="comment">//是否是大</span></span><br></pre></td></tr></table></figure><h2 id="10-时间日期LocalDate"><a href="#10-时间日期LocalDate" class="headerlink" title="10.时间日期LocalDate"></a>10.时间日期LocalDate</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 时间日期_LocalDate &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询 直接修改年份日期等</span></span><br><span class="line">System.out.println(today.getYear()); <span class="comment">//2021</span></span><br><span class="line">System.out.println(today.getMonth()); <span class="comment">//APRIL 英文四月</span></span><br><span class="line">System.out.println(today.getMonthValue()); <span class="comment">//4月</span></span><br><span class="line">System.out.println(today.getDayOfWeek().getValue()); <span class="comment">//获取当前这周的第几天</span></span><br><span class="line">System.out.println(today.getDayOfMonth()); <span class="comment">//获取当前这个月的第几天</span></span><br><span class="line">System.out.println(today.getDayOfYear()); <span class="comment">//获取当前这年的第几天</span></span><br><span class="line">System.out.println(today.withYear(<span class="number">2022</span>));<span class="comment">//修改该日期的年份</span></span><br><span class="line">System.out.println(today.withMonth(<span class="number">5</span>));<span class="comment">//修改该日期的月份</span></span><br><span class="line">System.out.println(today.withDayOfMonth(<span class="number">18</span>));<span class="comment">//修改该日期的月份中的第几天</span></span><br><span class="line">System.out.println(today.withDayOfYear(<span class="number">108</span>));<span class="comment">//修改该日期的年份中的第几天</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断 比较</span></span><br><span class="line">System.out.println(today.isLeapYear()); <span class="comment">//判断闰年-366  平年-365  </span></span><br><span class="line">System.out.println(today.lengthOfYear());<span class="comment">//该年份的长度</span></span><br><span class="line">System.out.println(today.lengthOfMonth());<span class="comment">//该月份的长度</span></span><br><span class="line">System.out.println(today.isEqual(LocalDate.ofYearDay(<span class="number">2021</span>, <span class="number">104</span>)));<span class="comment">//比较两个年份是否相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在原有的基础上增加年份</span></span><br><span class="line">System.out.println(today.plusYears(<span class="number">5</span>));</span><br><span class="line">System.out.println(today.plusMonths(<span class="number">5</span>)); <span class="comment">//直接在月份上操作</span></span><br><span class="line">System.out.println(today.plusWeeks(<span class="number">1</span>)); <span class="comment">//加一周 7天</span></span><br><span class="line">System.out.println(today.plusDays(<span class="number">20</span>)); <span class="comment">//加天数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在原有的基础上减少年份</span></span><br><span class="line">System.out.println(today.minusYears(<span class="number">5</span>));</span><br><span class="line">System.out.println(today.minusMonths(<span class="number">5</span>)); <span class="comment">//直接在月份上操作</span></span><br><span class="line">System.out.println(today.minusWeeks(<span class="number">1</span>)); <span class="comment">//加一周 7天</span></span><br><span class="line">System.out.println(today.minusDays(<span class="number">20</span>)); <span class="comment">//加天数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//LocalDate和String之间的转换</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">fmt</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> today.format(fmt);</span><br><span class="line">System.out.println(dateStr);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;2019-03-03&quot;</span>;</span><br><span class="line">        <span class="comment">//进行转换 </span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.parse(str, fmt);</span><br><span class="line">        System.out.println(date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算两个日期相差多少天</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">end</span> <span class="operator">=</span> LocalDate.of(<span class="number">2021</span>, <span class="number">4</span>, <span class="number">18</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(today.toEpochDay()); <span class="comment">//计算当前日期到1970-01-01的天数</span></span><br><span class="line">        System.out.println(end.toEpochDay());</span><br><span class="line">        System.out.println(end.toEpochDay()-today.toEpochDay());<span class="comment">//不包含起始日期</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(LocalDate.ofEpochDay(<span class="number">12</span>));</span><br><span class="line">        System.out.println(LocalDate.parse(<span class="string">&quot;2019-07-08&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-图G的顶点数n和边数e的关系"><a href="#11-图G的顶点数n和边数e的关系" class="headerlink" title="11. 图G的顶点数n和边数e的关系"></a>11. 图G的顶点数n和边数e的关系</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、若G是无向图，则边的范围<span class="number">0</span>≤e≤n(n-<span class="number">1</span>)/<span class="number">2</span>。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一个无向图包含 <span class="number">2020</span> 条边，如果图中没有自环和重边，请问最少包含多少个结点？</span><br><span class="line">　　</span><br><span class="line">　　答案： <span class="number">65</span>（无向图最多有n（n-<span class="number">1</span>）/<span class="number">2</span>条边）。</span><br></pre></td></tr></table></figure><h2 id="12-读取数据模板"><a href="#12-读取数据模板" class="headerlink" title="12. 读取数据模板"></a>12. 读取数据模板</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入</span></span><br><span class="line">BufferedReader sc= <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">String strs[] = sc.readLine().Split(<span class="string">&quot; &quot;</span>); <span class="comment">// 使用Split通过空格分割读入的一行字符串，存在s2中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">nums[i] = Integer.parseInt(strs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">out.write(c);</span><br><span class="line">out.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">out.flush();</span><br></pre></td></tr></table></figure><h2 id="13-大数模板"><a href="#13-大数模板" class="headerlink" title="13.大数模板"></a>13.大数模板</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.使用构造函数初始化</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;123456789101112131415&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123456.123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">BigInteger.max(BigInteger)  最大值</span><br><span class="line">BigInteger.min(BigInteger)  最小值</span><br><span class="line">valueOf(); <span class="comment">//将参数转换为指定的类型 </span></span><br><span class="line">add();<span class="comment">//相加 </span></span><br><span class="line">subtract(); <span class="comment">//相减 </span></span><br><span class="line">multiply(); <span class="comment">//相乘 </span></span><br><span class="line">divide(); <span class="comment">//相除取整 </span></span><br><span class="line">remainder(); <span class="comment">//取余 </span></span><br><span class="line">pow(); <span class="comment">//乘方，a.pow(b)=a^b </span></span><br><span class="line">BigInteger(String, <span class="type">int</span> index); <span class="comment">//可以把一个index进制的字符串,转化为10进制的BigInteger;</span></span><br><span class="line">BigInteger.compareTo(BigInteger);<span class="comment">//比较大小 1 0 -1 </span></span><br><span class="line">BigInteger.mod(BigInteger); <span class="comment">//取余</span></span><br><span class="line">BigInteger.gcd(BigInteger); <span class="comment">//最大公约数 </span></span><br><span class="line">c = a.modPow(b, mod); <span class="comment">//(a^b)%mod</span></span><br><span class="line">abs(); <span class="comment">//绝对值 </span></span><br><span class="line">negate();<span class="comment">// 取反数 </span></span><br><span class="line">equals(); <span class="comment">//是否相等 </span></span><br></pre></td></tr></table></figure><h2 id="14-数字各个位的和"><a href="#14-数字各个位的和" class="headerlink" title="14. 数字各个位的和"></a>14. 数字各个位的和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&gt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> temp=i%<span class="number">10</span>;</span><br><span class="line">res+=temp;</span><br><span class="line">i/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-子串的截取substring-hashset去重"><a href="#15-子串的截取substring-hashset去重" class="headerlink" title="15. 子串的截取substring()_hashset去重"></a>15. 子串的截取substring()_hashset去重</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">String str=<span class="string">&quot;0100110001010001&quot;</span>;</span><br><span class="line"><span class="type">int</span> n=str.length();</span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;=n; i++) &#123;  <span class="comment">//每一种可能，加入set里面</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> str.substring(i, j);   <span class="comment">//截取字符串从i到j</span></span><br><span class="line">set.add(a);                       <span class="comment">//返回</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16-字符串API模板使用"><a href="#16-字符串API模板使用" class="headerlink" title="16. 字符串API模板使用"></a>16. 字符串API模板使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1.</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(i); <span class="comment">//将int转为String</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> charAt(<span class="type">int</span> i);<span class="comment">//返回索引i处的字符</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> toCharArray();<span class="comment">//返回此字符串的字符数组</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> split(String regex); <span class="comment">// 根据正则表达式拆分</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> s.indexOf(<span class="string">&#x27;2&#x27;</span>)!=-<span class="number">1</span> <span class="comment">//判断字符串中是否存在该字符</span></span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> replaceAll(String s1,String s2);<span class="comment">//用s2替换目标字符串中出现的所有s1</span></span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> toUpperCase(); <span class="comment">//将此字符串中的所有字母都换为大写</span></span><br><span class="line"></span><br><span class="line"><span class="number">8.</span> toLowerCase()<span class="comment">//将此字符串中的所有字母都换为小写</span></span><br><span class="line"></span><br><span class="line"><span class="number">9.</span> indexOf(<span class="type">int</span> ch);<span class="comment">// 返回指定字符在此字符串中第一次出现的索引</span></span><br><span class="line"></span><br><span class="line"><span class="number">10.</span> lastIndexOf(<span class="type">int</span> ch);<span class="comment">//返回指定字符在此字符串最后一次出现的索引</span></span><br></pre></td></tr></table></figure><h2 id="17-判断闰年"><a href="#17-判断闰年" class="headerlink" title="17. 判断闰年"></a>17. 判断闰年</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//闰年2月29天  一年366 平年28 365</span></span><br><span class="line"><span class="comment">//判断闰年的方法：能被4整除，但不能被100整除；或者能被400整除的年份是闰年。</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">today2</span> <span class="operator">=</span> LocalDate.of(<span class="number">2000</span>, <span class="number">12</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(today2.isLeapYear()) <span class="comment">//jdk1.8特性</span></span><br><span class="line">    (y%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;y%<span class="number">100</span>!=<span class="number">0</span>)||(y%<span class="number">400</span>==<span class="number">0</span>);<span class="comment">//使用原始判断</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="18-前缀和"><a href="#18-前缀和" class="headerlink" title="18. 前缀和"></a>18. 前缀和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">_795_</span>前缀和 &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 前缀和 Si为数组的前i项和</span></span><br><span class="line"><span class="comment"> * S[i]=a[1]+a[2]+a[3]+...a[i]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//求[l,r]中的和，就是S[r]-S[l-1]  l,r并不是下标 而是第几位</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line"><span class="comment">//s[i] 代表arr的前i项和</span></span><br><span class="line"><span class="type">int</span>[] s=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">arr[i]=sc.nextInt();</span><br><span class="line">s[i]=s[i-<span class="number">1</span>]+arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(m--&gt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">System.out.println(s[r]-s[l-<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-二维数组前缀和"><a href="#19-二维数组前缀和" class="headerlink" title="19. 二维数组前缀和"></a>19. 二维数组前缀和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">_796_</span>子矩阵的和_二维数组前缀和 &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这题得自己画个图 好理解</span></span><br><span class="line"><span class="comment"> * 主要是左边的前缀和+上面的前缀和-两次重复的部分前缀和左上角</span></span><br><span class="line"><span class="comment"> * 二维数组前缀和 S[i,j]=S[i-1,j]+S[i,j-1]-S[i-1,j-1]+a[i,j]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="type">int</span>[][] arr=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">arr[i][j]=sc.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组前缀和 S[i,j]=S[i-1,j]+S[i,j-1]-S[i-1,j-1]+a[i,j]</span></span><br><span class="line"><span class="type">int</span>[][] s=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">s[i][j]=s[i-<span class="number">1</span>][j]+s[i][j-<span class="number">1</span>]-s[i-<span class="number">1</span>][j-<span class="number">1</span>]+arr[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求(x1,y1) (x2,y2)子矩阵的和  画图 画图</span></span><br><span class="line"><span class="comment">//就是S[x2,y2]-S[x2,y1-1]-S[x1-1,y2]+S[x1-1,y1-1]</span></span><br><span class="line"><span class="comment">//坐标的输入并不是按下标来的 而是第几个</span></span><br><span class="line"><span class="keyword">while</span>(q--&gt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> x1=sc.nextInt();</span><br><span class="line"><span class="type">int</span> y1=sc.nextInt();</span><br><span class="line"><span class="type">int</span> x2=sc.nextInt();</span><br><span class="line"><span class="type">int</span> y2=sc.nextInt();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res=s[x2][y2]-s[x2][y1-<span class="number">1</span>]-s[x1-<span class="number">1</span>][y2]+s[x1-<span class="number">1</span>][y1-<span class="number">1</span>];</span><br><span class="line">System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="20-差分数组"><a href="#20-差分数组" class="headerlink" title="20. 差分数组"></a>20. 差分数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">_797_</span>差分 &#123;</span><br><span class="line"><span class="comment">//输入一个长度为 n的整数序列。</span></span><br><span class="line"><span class="comment">//接下来输入 m个操作，每个操作包含三个整数 l,r,c，表示将序列中 [l,r] 之间的每个数加上 c。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[] b=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * a[0],a[1]...a[n]是b[0],b[1]....b[n]的前缀和数组</span></span><br><span class="line"><span class="comment"> * 反过来说 b数组是a数组的差分数组</span></span><br><span class="line"><span class="comment"> *构造差分数组b 很简单</span></span><br><span class="line"><span class="comment"> * b[1]=a[1]</span></span><br><span class="line"><span class="comment"> * b[2]=a[2]-a[1]</span></span><br><span class="line"><span class="comment"> * b[3]=a[3]-a[2]</span></span><br><span class="line"><span class="comment"> * .....</span></span><br><span class="line"><span class="comment"> * b[n]=a[n]-a[n-1]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">String[] s = bf.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(s[<span class="number">0</span>]);</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> Integer.parseInt(s[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">String[] sArr = bf.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">arr[i]=Integer.parseInt(sArr[i-<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已知前缀和数组 求差分数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="comment">//相当于在i下标位置插入arr[i]这个数</span></span><br><span class="line">insert(i,i,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m--&gt;<span class="number">0</span>) &#123;</span><br><span class="line">String[] split = bf.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> Integer.parseInt(split[<span class="number">0</span>]);</span><br><span class="line"><span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> Integer.parseInt(split[<span class="number">1</span>]);</span><br><span class="line"><span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> Integer.parseInt(split[<span class="number">2</span>]);</span><br><span class="line">insert(l,r,val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求b数组的前缀和 就是a数组最终的结果</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">arr[i]=arr[i-<span class="number">1</span>]+b[i];</span><br><span class="line">System.out.print(arr[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">bf.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在 a数组的[l,r]区域+c</span></span><br><span class="line"><span class="comment"> * 相当于差分数组 b[l]+c,b[r+1]-c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> val)</span> &#123;</span><br><span class="line">b[l]+=val;</span><br><span class="line">b[r+<span class="number">1</span>]-=val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="21-常用数据结构"><a href="#21-常用数据结构" class="headerlink" title="21.常用数据结构"></a>21.常用数据结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//集合数组</span></span><br><span class="line">    List[] arr=<span class="keyword">new</span> <span class="title class_">ArrayList</span>[T+<span class="number">1</span>]; <span class="comment">//存储每一个时刻的店铺id订单</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组存储26个字母的个数</span></span><br><span class="line"><span class="type">char</span>[] c=s.toCharArray();</span><br><span class="line"><span class="type">int</span> cnt[]=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;c.length; i++) &#123;</span><br><span class="line">cnt[c[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="22-浮点数二分"><a href="#22-浮点数二分" class="headerlink" title="22. 浮点数二分"></a>22. 浮点数二分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3 4</span></span><br><span class="line"><span class="comment">//3 5 4</span></span><br><span class="line"><span class="comment">//2.50</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Acwing_680_</span>剪绳子 &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> N=<span class="number">100000</span>;</span><br><span class="line"><span class="comment">//存储每个绳子的长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> nums[]=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"> n = sc.nextInt();</span><br><span class="line"> m = sc.nextInt();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">nums[i]=sc.nextInt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0&lt;Li&lt;1e9 绳子最大长度也就是1e9</span></span><br><span class="line"><span class="type">double</span> l=<span class="number">0</span>,r=<span class="number">1e9</span>;</span><br><span class="line"><span class="comment">//浮点数二分法 //精度比求精度高两位</span></span><br><span class="line"><span class="keyword">while</span>(r-l&gt;<span class="number">1e-4</span>) &#123; </span><br><span class="line"><span class="type">double</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid)) &#123;</span><br><span class="line">l=mid;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">r=mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">&quot;%.2f&quot;</span>,l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">double</span> mid)</span> &#123;</span><br><span class="line"><span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="comment">//使用二分出来的长度进行判断 可以剪得数量</span></span><br><span class="line">s+=nums[i]/mid;</span><br><span class="line"><span class="keyword">if</span>(s&gt;=m) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="23-数的三次方根二分"><a href="#23-数的三次方根二分" class="headerlink" title="23. 数的三次方根二分"></a>23. 数的三次方根二分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1000.00</span></span><br><span class="line"><span class="comment">输出样例：</span></span><br><span class="line"><span class="comment">10.000000</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">_790_</span>数的三次方根_二分 &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">double</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextDouble();</span><br><span class="line"><span class="type">double</span> l=-<span class="number">10000</span>,r=<span class="number">10000</span>;</span><br><span class="line"><span class="keyword">while</span>(r-l&gt;<span class="number">1e-8</span>) &#123; <span class="comment">//精度比求精度高两位</span></span><br><span class="line"><span class="type">double</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(mid*mid*mid&gt;=n) &#123;</span><br><span class="line">r=mid;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">l=mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">&quot;%.6f&quot;</span>,l);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="24-分巧克力二分"><a href="#24-分巧克力二分" class="headerlink" title="24. 分巧克力二分"></a>24. 分巧克力二分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">_1227_</span>分巧克力_二分 &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> N=<span class="number">100000</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[] h=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[] w=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> n,k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">n=sc.nextInt();  <span class="comment">//n块巧克力</span></span><br><span class="line">k=sc.nextInt();</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化 高度和宽度</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">h[i]=sc.nextInt();</span><br><span class="line">w[i]=sc.nextInt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分，注意r不能写成1e5，因为在java中1e5属于浮点数，就需要强制类型转化</span></span><br><span class="line"><span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">100000</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r) &#123;</span><br><span class="line"><span class="type">int</span> mid=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="comment">//若mid都符合 直接往右边走 数值更大</span></span><br><span class="line"><span class="keyword">if</span>(check(mid)) &#123;</span><br><span class="line">l=mid;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//否则mid不符合 走左边 数值更小</span></span><br><span class="line">r=mid-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出r和l都是一样的 最后l=r跳出循环</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二分枚举全部可以的边</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> mid)</span> &#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//枚举n块巧克力</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="comment">// (h[i]/mid)*(w[i]/mid)  mid边长这个就是可以切的数量</span></span><br><span class="line">res+=(h[i]/mid)*(w[i]/mid); <span class="comment">//res就是n块巧克力可以切的和 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若大于res数量大于小朋友数量k 直接return true</span></span><br><span class="line"><span class="keyword">return</span> res&gt;=k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二-全排列-DFS"><a href="#二-全排列-DFS" class="headerlink" title="二. 全排列_DFS"></a>二. 全排列_DFS</h1><h2 id="1-DFS-凑算式-不带重复元素的全排列"><a href="#1-DFS-凑算式-不带重复元素的全排列" class="headerlink" title="1. DFS_凑算式_不带重复元素的全排列"></a>1. DFS_凑算式_不带重复元素的全排列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若枚举数量小 直接for循环暴力破解</span></span><br><span class="line"><span class="comment">////1 2 3全排列 进行求和有重复的 3*2*1=6种是重复的 res/6 取一种  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DFS_</span>凑算式 &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> vis[]=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> a[] =<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">9</span>];</span><br><span class="line"><span class="comment">//全排列1~9数字 不能重复使用 vis数组进行标记</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(num==<span class="number">9</span>) &#123; <span class="comment">//当个数达到9个以后进行判断</span></span><br><span class="line"><span class="keyword">if</span>(check(arr))&#123; <span class="comment">//排列后判断的条件根据题目来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排列1~9数字 不能重复使用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">9</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(vis[i]==<span class="number">0</span>) &#123;</span><br><span class="line">vis[i]=<span class="number">1</span>;</span><br><span class="line">a[num]=i;</span><br><span class="line">dfs(num+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//a[num]=0; //这个不写也行 下一次赋值直接覆盖</span></span><br><span class="line">vis[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1~9数字可以重复使用没必要进行标记</span></span><br><span class="line"><span class="comment">//for (int i = 1; i &lt;=9; i++) &#123;</span></span><br><span class="line"><span class="comment">//a[num]=i;</span></span><br><span class="line"><span class="comment">//dfs(num+1);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">dfs(<span class="number">0</span>); <span class="comment">//从0开始存储</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-DFS-求全排列的子集-重复-不重复元素"><a href="#2-DFS-求全排列的子集-重复-不重复元素" class="headerlink" title="2. DFS_求全排列的子集_(重复||不重复元素)"></a>2. DFS_求全排列的子集_(重复||不重复元素)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 子集_不带重复元素的 &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[] a= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//m代表第几个元素 sub代表子集合列表  res代表结果集列表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> m,List&lt;Integer&gt; sub,List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(sub));</span><br><span class="line"><span class="comment">//注意这里从m开始变化 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>m; i &lt;a.length; i++) &#123;</span><br><span class="line"><span class="comment">//if(i&gt;m&amp;&amp;a[i-1]==a[i])continue; //主要是加这个条件进行区分重复元素</span></span><br><span class="line">sub.add(a[i]);<span class="comment">//子集添加当前层的元素</span></span><br><span class="line">dfs(i+<span class="number">1</span>,sub,res);<span class="comment">//dfs下一个元素</span></span><br><span class="line">sub.remove(sub.size()-<span class="number">1</span>);<span class="comment">//回溯</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-DFS全排列-交换数组顺序排列"><a href="#3-DFS全排列-交换数组顺序排列" class="headerlink" title="3 .DFS全排列_交换数组顺序排列"></a>3 .DFS全排列_交换数组顺序排列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 六角填数 &#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(m&gt;=<span class="number">9</span>) &#123;</span><br><span class="line">ans++;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">System.out.print(a[i]+<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=m;i&lt;<span class="number">9</span>;i++) &#123;</span><br><span class="line">swap(i,m);</span><br><span class="line">dfs(m+<span class="number">1</span>);</span><br><span class="line">swap(i,m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换位置</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i];</span><br><span class="line">a[i] = a[j];</span><br><span class="line">a[j] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">dfs(<span class="number">0</span>);</span><br><span class="line">System.out.println(ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-数论篇"><a href="#三-数论篇" class="headerlink" title="三. 数论篇"></a>三. 数论篇</h1><h2 id="1-倍筛法打表N以内的质数-数组标记法"><a href="#1-倍筛法打表N以内的质数-数组标记法" class="headerlink" title="1. 倍筛法打表N以内的质数__数组标记法"></a>1. 倍筛法打表N以内的质数__数组标记法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> N=<span class="number">100000005</span>;</span><br><span class="line"><span class="type">int</span> []st=<span class="keyword">new</span> <span class="title class_">int</span>[N]; <span class="comment">//使用数组记录 0为质数 1为合数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123; <span class="comment">//2就是质数</span></span><br><span class="line"><span class="keyword">if</span>(st[i]==<span class="number">0</span>) &#123;<span class="comment">//是素数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>*i;j&lt;=n;j+=i) &#123;<span class="comment">//筛去i的倍数</span></span><br><span class="line">st[j]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-试除法求约数-约数都是成对的-使用List集合进行存储-排序"><a href="#2-试除法求约数-约数都是成对的-使用List集合进行存储-排序" class="headerlink" title="2. 试除法求约数_约数都是成对的_使用List集合进行存储(排序)"></a>2. 试除法求约数_约数都是成对的_使用List集合进行存储(排序)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">_869_</span>试除法求约数 &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="keyword">while</span>(n--!=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> a=sc.nextInt();</span><br><span class="line">isyueshu(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">isyueshu</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"> List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> <span class="comment">//使用集合将约数全部存起来 再排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=Math.sqrt(n);i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(n%i==<span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//将i添加进去</span></span><br><span class="line">list.add(i);</span><br><span class="line"><span class="comment">//约数都是成对的,所以n/i也是它的约数</span></span><br><span class="line"><span class="keyword">if</span>(n/i!=i) list.add(n/i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Collections.sort(list);</span><br><span class="line"><span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">System.out.print(integer+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=4>  如果 N&#x3D;a1^k1 * a2 ^ k2 * … an ^ kn<br>  约数个数： (k1+1) * (k2+1) * … (kn+1)<br>   约数之和： (a1^0 + a1^1 + … + a1^k1) * … * (an^0 + an^1 + … + an^kn)</p></blockquote><h2 id="3-约数的个数-分解质因数-HashMap存储-全部-指数-1-的乘积"><a href="#3-约数的个数-分解质因数-HashMap存储-全部-指数-1-的乘积" class="headerlink" title="3.  约数的个数_分解质因数(HashMap存储)__全部(指数+1)的乘积"></a>3.  约数的个数_分解质因数(HashMap存储)__全部(指数+1)的乘积</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">_870_</span>约数的个数 &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">static</span> HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> <span class="type">long</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">/* 基本思想：</span></span><br><span class="line"><span class="comment"> *  如果 N=a1^k1 * a2 ^ k2 * ... an ^ kn</span></span><br><span class="line"><span class="comment"> *  约数个数： (k1+1) * (k2+1) * ... (kn+1)</span></span><br><span class="line"><span class="comment"> *  约数之和： (a1^0 + a1^1 + ... + a1^k1) * ... * (an^0 + an^1 + ... + an^kn)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//给定 n 个正整数 ai，请你输出这些数的乘积的约数个数，答案对 109+7 取模</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> n=sc.nextInt();</span><br><span class="line"><span class="keyword">while</span>(n--!=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> a=sc.nextInt();</span><br><span class="line">getNum(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> a: map.values()) &#123;</span><br><span class="line">res=(res*(a+<span class="number">1</span>))%mod;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getNum</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="comment">//将传进来的数进行约数分解</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=Math.sqrt(n);i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(n%i==<span class="number">0</span>) &#123;</span><br><span class="line">map.put(i, map.getOrDefault(i, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">n/=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后分解完 还剩n大于1 直接添加到map集合中</span></span><br><span class="line"><span class="keyword">if</span>(n&gt;<span class="number">1</span>) &#123;</span><br><span class="line">map.put(n, map.getOrDefault(n, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="3-约数的个数-不用hashMap存储-直接计算出来"><a href="#3-约数的个数-不用hashMap存储-直接计算出来" class="headerlink" title="3. 约数的个数_不用hashMap存储 直接计算出来"></a>3. 约数的个数_不用hashMap存储 直接计算出来</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">factors</span><span class="params">(<span class="type">long</span> n)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>, now;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i * i &lt;= n; i++) &#123;<span class="comment">//首先找到小于根号n的所有质数，</span></span><br><span class="line">           now = <span class="number">1</span>; <span class="comment">//起始位是1 后面不用加</span></span><br><span class="line">           <span class="keyword">while</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">               n /= i;</span><br><span class="line">               now++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (now &gt; <span class="number">1</span>)</span><br><span class="line">               res *= now;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> n &gt; <span class="number">1</span>? res *<span class="number">2</span> : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-约数之和-分解质因数-HashMap存储-全部（底数从0到指数k的和）乘积"><a href="#4-约数之和-分解质因数-HashMap存储-全部（底数从0到指数k的和）乘积" class="headerlink" title="4. 约数之和__分解质因数(HashMap存储)__全部（底数从0到指数k的和）乘积"></a>4. 约数之和__分解质因数(HashMap存储)__全部（底数从0到指数k的和）乘积</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">_871_</span>约数之和 &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">static</span> HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> <span class="type">long</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">/* 基本思想：</span></span><br><span class="line"><span class="comment"> *  如果 N=a1^k1 * a2 ^ k2 * ... an ^ kn</span></span><br><span class="line"><span class="comment"> *  约数个数： (k1+1) * (k2+1) * ... (kn+1)</span></span><br><span class="line"><span class="comment"> *  约数之和： (a1^0 + a1^1 + ... + a1^k1) * ... * (an^0 + an^1 + ... + an^kn)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 给定 n 个正整数 ai，请你输出这些数的乘积的约数之和，答案对 109+7 取模。</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> n=sc.nextInt();</span><br><span class="line"><span class="keyword">while</span>(n--!=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> a=sc.nextInt();</span><br><span class="line">getNum(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//约数之和： (a1^0 + a1^1 + ... + a1^k1) * ... * (an^0 + an^1 + ... + an^kn)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> a:map.keySet()) &#123;</span><br><span class="line"><span class="type">long</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> k=map.get(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++) &#123;</span><br><span class="line"><span class="type">long</span> pow=<span class="number">1</span>;<span class="type">int</span> tmp=i;</span><br><span class="line"><span class="keyword">while</span>(tmp--&gt;<span class="number">0</span>) &#123;</span><br><span class="line">pow=pow*a%mod;</span><br><span class="line">&#125;</span><br><span class="line">sum=(sum+pow)%mod;</span><br><span class="line">&#125;</span><br><span class="line">res=res*sum%mod;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getNum</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=Math.sqrt(n);i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(n%i==<span class="number">0</span>) &#123;</span><br><span class="line">map.put(i, map.getOrDefault(i, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">n/=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n&gt;<span class="number">1</span>) &#123;</span><br><span class="line">map.put(n, map.getOrDefault(n, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-快速幂-计算a的n次方-要求n-gt-x3D-0-使用Java中的大数BigInteger也可以"><a href="#5-快速幂-计算a的n次方-要求n-gt-x3D-0-使用Java中的大数BigInteger也可以" class="headerlink" title="5.  快速幂_计算a的n次方(要求n&gt;&#x3D;0)__使用Java中的大数BigInteger也可以"></a>5.  快速幂_计算a的n次方(要求n&gt;&#x3D;0)__使用Java中的大数BigInteger也可以</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先a^n中可以设n=2^t1+2^t2+…+2^tk(二进制) 即将b转换为二进制表示</span></span><br><span class="line"><span class="keyword">public</span> class 快速幂 &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> mod=<span class="number">1921</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="title function_">quickPow</span><span class="params">(<span class="type">long</span> a,<span class="type">long</span> n)</span> &#123;</span><br><span class="line"><span class="type">long</span> ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(n&gt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//判断n二进制最右边一位是否为1</span></span><br><span class="line"><span class="keyword">if</span>((n&amp;<span class="number">1</span>)==<span class="number">1</span>) &#123;</span><br><span class="line">ans=ans*a%mod; <span class="comment">//结果集ans再乘以a</span></span><br><span class="line">&#125;</span><br><span class="line">a=a*a%mod;  <span class="comment">//a值改变乘以a</span></span><br><span class="line">n&gt;&gt;=<span class="number">1</span>; <span class="comment">//n向右移一位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-快速幂求逆元"><a href="#6-快速幂求逆元" class="headerlink" title="6. 快速幂求逆元"></a>6. 快速幂求逆元</h2><p><img src="https://img-blog.csdnimg.cn/20210512171402359.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">      b的逆元 b^(−1) mod (m) m是取余的数值</span></span><br><span class="line"><span class="comment">   当b于m互质时，b的乘法逆元为b^(m-2)</span></span><br><span class="line"><span class="comment">   当b为m的倍数时，b的逆元不存在b*x %m==0 b乘任意一个x % m一定等于0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> a=sc.nextInt();</span><br><span class="line"><span class="type">int</span> m=sc.nextInt();</span><br><span class="line"><span class="type">long</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a%m!=<span class="number">0</span>) &#123;<span class="comment">// 判断a是否是m的倍数</span></span><br><span class="line"><span class="type">int</span> k=m-<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(k!=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>((k&amp;<span class="number">1</span>)==<span class="number">1</span>) &#123;</span><br><span class="line">res=res*a%m;</span><br><span class="line">&#125;</span><br><span class="line">k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//这里a*a小心超出边界</span></span><br><span class="line">a=(<span class="type">int</span>)((<span class="type">long</span>)a*a%m);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(res);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-求组合数①-动态规划-数据范围N-x3D-2000-预处理"><a href="#7-求组合数①-动态规划-数据范围N-x3D-2000-预处理" class="headerlink" title="7. 求组合数①_动态规划_数据范围N&#x3D;2000_预处理"></a>7. 求组合数①_动态规划_数据范围N&#x3D;2000_预处理</h2><p><img src="https://img-blog.csdnimg.cn/20210512171049371.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> N=<span class="number">2010</span>,INF=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span>[][] C=<span class="keyword">new</span> <span class="title class_">int</span>[N][N]; <span class="comment">//使用二维矩阵存储全部的实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; a &lt;=<span class="number">2000</span>; a++) &#123;</span><br><span class="line">C[a][<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//初始化从a中挑0个为1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span><span class="number">1</span>; b &lt;=a; b++) &#123; <span class="comment">//0的方案写过了  b直接从1开始</span></span><br><span class="line"><span class="comment">//直接转化为dp</span></span><br><span class="line"><span class="comment">//1.不选锤子 在剩下的a-1个里选b个</span></span><br><span class="line"><span class="comment">//2.选锤子 在剩下的a-1个里面选b-1个</span></span><br><span class="line">C[a][b]=(C[a-<span class="number">1</span>][b]+C[a-<span class="number">1</span>][b-<span class="number">1</span>])%INF;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-求组合数②-组合公式-快速幂逆元-预处理"><a href="#8-求组合数②-组合公式-快速幂逆元-预处理" class="headerlink" title="8. 求组合数②_组合公式_快速幂逆元_预处理"></a>8. 求组合数②_组合公式_快速幂逆元_预处理</h2><p><img src="https://img-blog.csdnimg.cn/20210512171035755.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">_886_</span>求组合数_快速幂求逆元 &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> N=<span class="number">100010</span>,p=(<span class="type">int</span>)<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[] fact=<span class="keyword">new</span> <span class="title class_">int</span>[N],infact=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> Integer.parseInt(br.readLine());</span><br><span class="line">fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预处理</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;N; i++) &#123;</span><br><span class="line"><span class="comment">//求i的阶乘 等于前面的fact[i-1]阶乘*i</span></span><br><span class="line">fact[i]=(<span class="type">int</span>)((<span class="type">long</span>)fact[i-<span class="number">1</span>]*i%p);  </span><br><span class="line"><span class="comment">//求i的逆元阶乘 等于前面infact[i-1]阶乘的逆元*当前i的逆元</span></span><br><span class="line"><span class="comment">//其中 p 是质数</span></span><br><span class="line">infact[i]=(<span class="type">int</span>)((<span class="type">long</span>)infact[i-<span class="number">1</span>]*qmi(i,p-<span class="number">2</span>,p)%p); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里是多组数据输入</span></span><br><span class="line"><span class="keyword">while</span>(t--&gt;<span class="number">0</span>) &#123;</span><br><span class="line">String[] s = br.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="type">int</span> a=Integer.parseInt(s[<span class="number">0</span>]);</span><br><span class="line"><span class="type">int</span> b=Integer.parseInt(s[<span class="number">1</span>]);</span><br><span class="line"><span class="type">int</span> res=(<span class="type">int</span>)((<span class="type">long</span>)fact[a]*infact[a-b]%p*infact[b]%p);</span><br><span class="line">System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快速幂预处理 a^k%p  将k拆成二进制 </span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">qmi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> k,<span class="type">int</span> p)</span> &#123;</span><br><span class="line"><span class="type">long</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(k&gt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>((k&amp;<span class="number">1</span>)!=<span class="number">0</span>)res=res*a%p;</span><br><span class="line">a=(<span class="type">int</span>)((<span class="type">long</span>)a*a%p);</span><br><span class="line">k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">int</span>)res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-求组合数②-组合公式化简-快速幂逆元-预处理"><a href="#8-求组合数②-组合公式化简-快速幂逆元-预处理" class="headerlink" title="8. 求组合数②_组合公式化简_快速幂逆元_预处理"></a>8. 求组合数②_组合公式化简_快速幂逆元_预处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p 为质数</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> p=<span class="number">1000003</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快熟幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="title function_">qmi</span><span class="params">(<span class="type">long</span> a,<span class="type">long</span> k)</span> &#123;</span><br><span class="line"><span class="type">long</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(k!=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>((k&amp;<span class="number">1</span>)==<span class="number">1</span>) res=res*a%p;</span><br><span class="line">k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">a=a*a%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求组合数化简公式 快速幂逆元</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="title function_">C</span><span class="params">(<span class="type">long</span> a,<span class="type">long</span> b)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(b &gt; a) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> a,j = b; j &gt;= <span class="number">1</span>;i --,j --)</span><br><span class="line">       &#123;</span><br><span class="line">           res = res * i % p;</span><br><span class="line">           res = res * qmi(j,p - <span class="number">2</span>) % p;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="10-求组合数③-lucas定理-递归分解-化简后的组合公式"><a href="#10-求组合数③-lucas定理-递归分解-化简后的组合公式" class="headerlink" title="10. 求组合数③_lucas定理_递归分解__化简后的组合公式"></a>10. 求组合数③_lucas定理_递归分解__化简后的组合公式</h2><p><img src="https://img-blog.csdnimg.cn/20210512172432700.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> n=sc.nextInt();</span><br><span class="line"><span class="type">long</span> a,b,p;</span><br><span class="line"><span class="keyword">while</span>(n--&gt;<span class="number">0</span>) &#123;</span><br><span class="line">a=sc.nextLong();</span><br><span class="line">b=sc.nextLong();</span><br><span class="line">p=sc.nextLong();</span><br><span class="line">System.out.println(lucas(a,b,p));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快速幂求次方</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="title function_">quickPower</span><span class="params">(<span class="type">long</span> a,<span class="type">long</span> b,<span class="type">long</span> p)</span> &#123;</span><br><span class="line"><span class="type">long</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b&gt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>((b&amp;<span class="number">1</span>)==<span class="number">1</span>) &#123;</span><br><span class="line">res=res*a%p;</span><br><span class="line">&#125;</span><br><span class="line">a=a*a%p;</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求组合数 化简后的组合公式</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="title function_">c</span><span class="params">(<span class="type">long</span> a,<span class="type">long</span> b,<span class="type">long</span> p)</span> &#123;</span><br><span class="line"><span class="type">long</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//a只要前面b个乘积</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>,j=a;i&lt;=b;i++,j--) &#123;</span><br><span class="line"> <span class="comment">//a*(a-1)*(a-2)....*(a-b+1)  约分约掉(a-b)!的阶乘</span></span><br><span class="line">res=res*j%p;</span><br><span class="line"><span class="comment">//求b的阶乘的逆元 从0到b逆元的乘积</span></span><br><span class="line">res=res*quickPower(i, p-<span class="number">2</span>, p)%p; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据lucas公式递归将a b的值缩小</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="title function_">lucas</span><span class="params">(<span class="type">long</span> a,<span class="type">long</span> b,<span class="type">long</span> p)</span> &#123;</span><br><span class="line"><span class="comment">//当a和b都小于p 不再分解</span></span><br><span class="line"><span class="keyword">if</span>(a&lt;p&amp;&amp;b&lt;p) &#123;</span><br><span class="line"><span class="keyword">return</span> c(a, b, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lucas(a/p, b/p, p)*c(a%p, b%p, p)%p; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="四-图论篇"><a href="#四-图论篇" class="headerlink" title="四. 图论篇"></a>四. 图论篇</h1><blockquote><p>n个点，m条边，m约等于n2叫做稠密图，用邻接矩阵存储；</p></blockquote><h2 id="1-Dijkstra求最短路模板-邻接矩阵-边权均为正值"><a href="#1-Dijkstra求最短路模板-邻接矩阵-边权均为正值" class="headerlink" title="1.Dijkstra求最短路模板_邻接矩阵_边权均为正值"></a>1.Dijkstra求最短路模板_邻接矩阵_边权均为正值</h2><p>1 号点到 n 号点的最短距离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> m,n;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[][] g=<span class="keyword">new</span> <span class="title class_">int</span>[N][N]; <span class="comment">////为稠密阵所以用邻接矩阵存储</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[] dist=<span class="keyword">new</span> <span class="title class_">int</span>[N]; <span class="comment">//存储每个点到起点的最短距离</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span>[] st=<span class="keyword">new</span> <span class="title class_">boolean</span>[N]; <span class="comment">//用于记录该点的最短距离是否已经确定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"> n = sc.nextInt();</span><br><span class="line"> m=sc.nextInt();</span><br><span class="line"> <span class="comment">//初始化邻接矩阵 全取最大值</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"> Arrays.fill(g[i],<span class="number">0x3f3f3f3f</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//所有距离都填充最大值</span></span><br><span class="line">Arrays.fill(dist, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line"> dist[<span class="number">1</span>]=<span class="number">0</span>;  <span class="comment">//节点从1开始 自己的距离设置为0</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">while</span>(m--&gt;<span class="number">0</span>) &#123;</span><br><span class="line"> <span class="type">int</span> a=sc.nextInt();</span><br><span class="line"> <span class="type">int</span> b=sc.nextInt();</span><br><span class="line"> <span class="type">int</span> c=sc.nextInt();</span><br><span class="line"><span class="comment">//如果有重边，保留距离最短的那条边</span></span><br><span class="line"> g[a][b]=Math.min(g[a][b], c);</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.println(dijkstra());</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dijkstra</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环n遍，每次确定一个点的最短路</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;n; i++) &#123;</span><br><span class="line"><span class="type">int</span> t=-<span class="number">1</span>;<span class="comment">//表示还没有最短的点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;  <span class="comment">//遍历下所有点，寻找路径最短的点</span></span><br><span class="line"><span class="keyword">if</span>(!st[j]&amp;&amp;(t==-<span class="number">1</span>||dist[t]&gt;dist[j])) &#123;</span><br><span class="line">t=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(t == n) <span class="keyword">break</span>;   <span class="comment">//结点n已经确定最短路，结束程序</span></span><br><span class="line"><span class="comment">//循环后找到了最短的点，为 t </span></span><br><span class="line"><span class="comment">//标记已经访问过</span></span><br><span class="line">st[t]=<span class="literal">true</span>;</span><br><span class="line"> <span class="comment">//最后拿到t这个节点 更新t到下一个节点j的值+dist[t]和dist[j]比较 </span></span><br><span class="line"> <span class="comment">//这里和Prim算法就不一致了dist[j]=Math.min(dist[j], g[t][j]);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">1</span>; j &lt;=n; j++) &#123;</span><br><span class="line">dist[j]=Math.min(dist[j], dist[t]+g[t][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Floyd求最短路-三个for循环-邻接矩阵-边权可能为负数"><a href="#2-Floyd求最短路-三个for循环-邻接矩阵-边权可能为负数" class="headerlink" title="2. Floyd求最短路 三个for循环_邻接矩阵_边权可能为负数"></a>2. Floyd求最短路 三个for循环_邻接矩阵_边权可能为负数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> N=<span class="number">210</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> n,m,q;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[][] d=<span class="keyword">new</span> <span class="title class_">int</span>[N][N]; <span class="comment">//使用邻接矩阵对图进行存储</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">n=sc.nextInt();m=sc.nextInt();q=sc.nextInt();</span><br><span class="line"><span class="comment">//初始化i到j的最短距离</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>; i &lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">1</span>; j &lt;=n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i==j) &#123;</span><br><span class="line">d[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">d[i][j]=INF;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化a到b的距离 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;m; i++) &#123;</span><br><span class="line"><span class="type">int</span> a=sc.nextInt(),b=sc.nextInt(),w=sc.nextInt();</span><br><span class="line"><span class="comment">//若出现重复的 直接取最小值 有向图</span></span><br><span class="line">d[a][b]=Math.min(d[a][b],w);</span><br><span class="line">&#125;</span><br><span class="line">Floyd();</span><br><span class="line"><span class="keyword">while</span>(q--&gt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> a=sc.nextInt(),b=sc.nextInt();</span><br><span class="line"><span class="comment">//有负权边存</span></span><br><span class="line"><span class="keyword">if</span>(d[a][b]&gt;INF/<span class="number">2</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(d[a][b]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Floyd</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">d[i][j]=Math.min(d[i][j], d[i][k]+d[k][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-spfa求最短路-邻接表-边权可能为负数"><a href="#3-spfa求最短路-邻接表-边权可能为负数" class="headerlink" title="3. spfa求最短路_邻接表_边权可能为负数"></a>3. spfa求最短路_邻接表_边权可能为负数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 要想松弛后面的点，必须要更新过当前的点，如果这个点都没有更新过，那么更新后面的点也是无效的</span></span><br><span class="line"><span class="comment"> 适用范围：只要没有负环，都可以使用。</span></span><br><span class="line"><span class="comment">    spfa也能解决权值为正的图的最短距离问题，且一般情况下比Dijkstra算法还好</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 时间复杂度：一般情况 O(m)</span></span><br><span class="line"><span class="comment"> 1. 初始化dist[1]=0; dist[其他点] = 正无穷</span></span><br><span class="line"><span class="comment"> 2. 队列不空</span></span><br><span class="line"><span class="comment">    1. 只有这个点被更新后，其他与它相连的点才会被更新</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> h[]=<span class="keyword">new</span> <span class="title class_">int</span>[N],e[]=<span class="keyword">new</span> <span class="title class_">int</span>[N],ne[]=<span class="keyword">new</span> <span class="title class_">int</span>[N],w[]=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> idx;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[] dist=<span class="keyword">new</span> <span class="title class_">int</span>[N]; <span class="comment">//每个节点到起点的距离</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span>[] st=<span class="keyword">new</span> <span class="title class_">boolean</span>[N]; <span class="comment">//st 用来记录哪些点现在在队列里面，如果在里面不需要重复添加</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">n=sc.nextInt();</span><br><span class="line">m=sc.nextInt();</span><br><span class="line">Arrays.fill(h, -<span class="number">1</span>); <span class="comment">//初始头节点为-1</span></span><br><span class="line">        <span class="keyword">while</span> (m-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> sc.nextInt(), b = sc.nextInt(), c = sc.nextInt();</span><br><span class="line">            add(a, b, c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> spfa();</span><br><span class="line">        <span class="keyword">if</span> (res == -<span class="number">1</span>) System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表建图的模板</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span> &#123;</span><br><span class="line">e[idx]=b;</span><br><span class="line">ne[idx]=h[a];</span><br><span class="line">w[idx]=c;</span><br><span class="line">h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">spfa</span><span class="params">()</span> &#123;</span><br><span class="line">Arrays.fill(dist, INF); <span class="comment">// 初始化距离为INF</span></span><br><span class="line">Queue&lt;Integer&gt; q=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">q.offer(<span class="number">1</span>); </span><br><span class="line">dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!q.isEmpty()) &#123;  <span class="comment">// 队列里面存储的是被更新过的节点，</span></span><br><span class="line"><span class="type">int</span> t=q.poll();</span><br><span class="line">st[t]=<span class="literal">false</span>;  <span class="comment">// 标志为false，让这个点可以再次加入队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重边不会被影响到，dist数组里面最后肯定是存储最小的</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=h[t];i!=-<span class="number">1</span>;i=ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> j=e[i];</span><br><span class="line"><span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i]) &#123;</span><br><span class="line">dist[j]=dist[t]+w[i];</span><br><span class="line"><span class="keyword">if</span>(!st[j]) &#123; <span class="comment">// 如果这个点没有加入队列，这里是防止点重复被加入。</span></span><br><span class="line">q.offer(j);</span><br><span class="line">st[j]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 如果这个点不可达，就一定不会被更新，</span></span><br><span class="line"><span class="keyword">if</span>(dist[n]==INF) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Prim最小生成树"><a href="#4-Prim最小生成树" class="headerlink" title="4. Prim最小生成树"></a>4. Prim最小生成树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Prim是更新不在集合中的点 离集合S的距离</span></span><br><span class="line"><span class="comment"> * dist[i]距离设置为无穷大</span></span><br><span class="line"><span class="comment">dist[1]=0</span></span><br><span class="line"><span class="comment"> * for i in 0..n-1</span></span><br><span class="line"><span class="comment">    找到不在s集合中，距离s集合最近的点t</span></span><br><span class="line"><span class="comment">    将这个点t放入集合中</span></span><br><span class="line"><span class="comment">    利用这个点t， 更新不在集合中的点</span></span><br><span class="line"><span class="comment">dist[j] = min(dist[j], g[t][j])</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> N=<span class="number">510</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> g[][]=<span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> dist[]=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> st[]=<span class="keyword">new</span> <span class="title class_">boolean</span>[N];</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="comment">//初始化邻接矩阵和集合距离</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;N; i++) &#123;</span><br><span class="line">dist[i]=INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;N; j++) &#123;</span><br><span class="line">g[i][j]=INF;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">n=sc.nextInt();m=sc.nextInt();</span><br><span class="line"><span class="keyword">while</span>(m--&gt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> a=sc.nextInt(),b=sc.nextInt(),c=sc.nextInt();</span><br><span class="line"><span class="comment">//重边取最小值</span></span><br><span class="line">g[a][b]=g[b][a]=Math.min(g[b][a], c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> t=prim();</span><br><span class="line"><span class="comment">//有点不连通的时候，不存在最小生成树</span></span><br><span class="line">System.out.println(t==INF?<span class="string">&quot;impossible&quot;</span> :t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">prim</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;n; i++) &#123; <span class="comment">//遍历n个点</span></span><br><span class="line"><span class="type">int</span> t=-<span class="number">1</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line"><span class="comment">//找到不在s集合中，距离s集合最近的点t</span></span><br><span class="line"><span class="keyword">if</span>(!st[j]&amp;&amp;(t==-<span class="number">1</span>||dist[t]&gt;dist[j])) &#123;</span><br><span class="line">t=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不是第一个取出的节点，并且当前节点的距离为INF,则表示没有和集合中点相连的边。</span></span><br><span class="line"><span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;dist[t]==INF) &#123;</span><br><span class="line"><span class="keyword">return</span> INF;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//写在前面，如果一个节点本身出现负环，下面这句更新后，会影响结果，</span></span><br><span class="line"> <span class="comment">//将这个点t放入集合中</span></span><br><span class="line"><span class="keyword">if</span>(i!=<span class="number">0</span>) &#123;</span><br><span class="line">ans+=dist[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置为访问过</span></span><br><span class="line">st[t]=<span class="literal">true</span>;</span><br><span class="line"><span class="comment">//利用这个点t， 更新不在集合中的点</span></span><br><span class="line"><span class="comment">//更新当前最短边权点t到集合的距离(保留最小的值，如果比之前最短t到集合的距离还小，更新)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">1</span>; j &lt;=n; j++) &#123;</span><br><span class="line">dist[j]=Math.min(dist[j], g[t][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Kruskal算法求最小生成树"><a href="#5-Kruskal算法求最小生成树" class="headerlink" title="5. Kruskal算法求最小生成树"></a>5. Kruskal算法求最小生成树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">        <span class="type">int</span> x;  </span><br><span class="line">        <span class="type">int</span> y;    </span><br><span class="line">        <span class="type">int</span> w;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> w)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.x = x;   </span><br><span class="line">            <span class="built_in">this</span>.y = y;   </span><br><span class="line">            <span class="built_in">this</span>.w = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> n,m,cnt;</span><br><span class="line"><span class="keyword">static</span> Edge[] edges;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[] p;<span class="comment">//存储节点的父节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">String[] s = br.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">n = Integer.parseInt(s[<span class="number">0</span>]);</span><br><span class="line">m = Integer.parseInt(s[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//初始化数组</span></span><br><span class="line">edges=<span class="keyword">new</span> <span class="title class_">Edge</span>[m];</span><br><span class="line">p=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line"><span class="comment">//并查集初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">p[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输入数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;m; i++) &#123;</span><br><span class="line">String[] s2 = br.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> Integer.parseInt(s2[<span class="number">0</span>]);</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> Integer.parseInt(s2[<span class="number">1</span>]);</span><br><span class="line"><span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> Integer.parseInt(s2[<span class="number">2</span>]);</span><br><span class="line"><span class="type">Edge</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Edge</span>(x,y,w);</span><br><span class="line">edges[i]=e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将所有边按权重从小到大排序</span></span><br><span class="line">Arrays.sort(edges,(a,b)-&gt;a.w-b.w);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//枚举每条边a b 权重w</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;m; i++) &#123; <span class="comment">//m条边</span></span><br><span class="line">Edge e=edges[i];</span><br><span class="line"><span class="comment">//使用并查集模板, 比较两个集合的祖宗节点是否相同</span></span><br><span class="line"><span class="type">int</span> fx=find(e.x);</span><br><span class="line"><span class="type">int</span> fy=find(e.y);</span><br><span class="line"></span><br><span class="line"><span class="comment">//若两个集合不连通，将它们合并</span></span><br><span class="line"><span class="keyword">if</span>(fx!=fy) &#123;</span><br><span class="line"><span class="comment">//fx的父节点为fy</span></span><br><span class="line">p[fx]=fy;</span><br><span class="line"><span class="comment">//结果集+w</span></span><br><span class="line">res+=e.w;</span><br><span class="line"><span class="comment">//数量+1</span></span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//m条边查询完毕</span></span><br><span class="line"><span class="keyword">if</span>(cnt&lt;n-<span class="number">1</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并查集根据父节点递归向上查找祖宗节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(p[x]!=x) &#123;</span><br><span class="line">p[x]=find(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五-DP篇"><a href="#五-DP篇" class="headerlink" title="五. DP篇"></a>五. DP篇</h1><h2 id="1-金字塔DP-最路径的最大和-掌握"><a href="#1-金字塔DP-最路径的最大和-掌握" class="headerlink" title="1. 金字塔DP_最路径的最大和____掌握"></a>1. 金字塔DP_最路径的最大和____掌握</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从上往下递推</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>; i &lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">1</span>; j &lt;=i; j++) &#123;</span><br><span class="line">arr[i][j]=sc.nextInt();</span><br><span class="line">arr[i][j]+=Math.max(arr[i-<span class="number">1</span>][j], arr[i-<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-迷宫DP-走下或走右-掌握"><a href="#15-迷宫DP-走下或走右-掌握" class="headerlink" title="15. 迷宫DP_走下或走右____掌握"></a>15. 迷宫DP_走下或走右____掌握</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">_1015_</span>摘花生_dp &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="type">int</span> <span class="variable">T</span> <span class="operator">=</span> Integer.parseInt(br.readLine());</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(T--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">String[] s = br.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(s[<span class="number">0</span>]),m=Integer.parseInt(s[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[][] g=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">s=br.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">g[i][j]=Integer.parseInt(s[j-<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>]; <span class="comment">///状态表示：d(i,j)表示从(1,1)到(i,j)最多摘到的花生数量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="comment">//只需要比较向上走来 向右走来的最大值</span></span><br><span class="line">dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>])+g[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(dp[n][m]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-最长上升子序列正向和反向求解-DP-掌握"><a href="#3-最长上升子序列正向和反向求解-DP-掌握" class="headerlink" title="3. 最长上升子序列正向和反向求解_DP_掌握"></a>3. 最长上升子序列正向和反向求解_DP_掌握</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">_1017_</span>最长上升子序列正向和反向求解 &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[] a=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">K</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="keyword">while</span>(K--&gt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> n=sc.nextInt();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>; i &lt;=n; i++) &#123;</span><br><span class="line">a[i]=sc.nextInt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正向求解LIS 上升 </span></span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>; i &lt;=n; i++) &#123;</span><br><span class="line"><span class="comment">//初始化自己也是一个</span></span><br><span class="line">dp[i]=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//枚举i前面的数 判断是否小于a[i] 并更新dp[i]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">1</span>; j &lt;i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(a[j]&lt;a[i]) &#123;</span><br><span class="line">dp[i]=Math.max(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">res=Math.max(res, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反向求解LIS 下降</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>n;i&gt;=<span class="number">1</span>; i--) &#123; <span class="comment">//从后往前</span></span><br><span class="line">dp[i]=<span class="number">1</span>;<span class="comment">// 本身</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span>n;j&gt;i; j--) &#123;<span class="comment">//在i的后面进行查找,若出现小于该值的</span></span><br><span class="line"><span class="keyword">if</span>(a[j]&lt;a[i]) &#123;</span><br><span class="line">dp[i]=Math.max(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">res=Math.max(res, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-大盗阿福-DP-熟悉"><a href="#15-大盗阿福-DP-熟悉" class="headerlink" title="15. 大盗阿福_DP_熟悉"></a>15. 大盗阿福_DP_熟悉</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">_1049_</span>大盗阿福_dp &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * f[i][0] 代表的是不偷第i家店铺能得到的最多现金数量；</span></span><br><span class="line"><span class="comment"> * f[i][1] 代表的是偷第i家店铺能得到的最多现金数量。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * f[i][0] = max(f[i - 1][0], f[i - 1][1]);</span></span><br><span class="line"><span class="comment">f[i][1] = f[i - 1][0] + w[i];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">初始化：f[0][0] = 0,f[0][1] = -INF</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> N=<span class="number">100010</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[] w=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[][] f=<span class="keyword">new</span> <span class="title class_">int</span>[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">T</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="keyword">while</span>(T--&gt;<span class="number">0</span>) &#123;</span><br><span class="line">n=sc.nextInt();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>; i &lt;=n; i++) &#123;</span><br><span class="line">w[i]=sc.nextInt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">1</span>]=-INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>; i &lt;=n; i++) &#123;</span><br><span class="line">f[i][<span class="number">0</span>]=Math.max(f[i-<span class="number">1</span>][<span class="number">0</span>], f[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">f[i][<span class="number">1</span>]=f[i-<span class="number">1</span>][<span class="number">0</span>]+w[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Math.max(f[n][<span class="number">0</span>],f[n][<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-01背包DP-最大价值-掌握"><a href="#5-01背包DP-最大价值-掌握" class="headerlink" title="5. 01背包DP_最大价值_掌握"></a>5. 01背包DP_最大价值_掌握</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> N=sc.nextInt(); <span class="comment">//物品种数</span></span><br><span class="line"><span class="type">int</span> V=sc.nextInt(); <span class="comment">//背包容积</span></span><br><span class="line"><span class="type">int</span>[] v=<span class="keyword">new</span> <span class="title class_">int</span>[N+<span class="number">1</span>]; <span class="comment">//体积</span></span><br><span class="line"><span class="type">int</span>[] w=<span class="keyword">new</span> <span class="title class_">int</span>[N+<span class="number">1</span>]; <span class="comment">//价值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) &#123;</span><br><span class="line">v[i]=sc.nextInt();</span><br><span class="line">w[i]=sc.nextInt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[V+<span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) &#123;<span class="comment">//遍历每一个可以使用的数量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=V;j&gt;=v[i];j--) &#123;<span class="comment">// 容量从大到小</span></span><br><span class="line"><span class="comment">//只能使用一次 所以不用k</span></span><br><span class="line">dp[j]=Math.max(dp[j], dp[j-v[i]]+w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(dp[V]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-完全背包-物品无限使用-掌握"><a href="#6-完全背包-物品无限使用-掌握" class="headerlink" title="6.完全背包_物品无限使用_掌握"></a>6.完全背包_物品无限使用_掌握</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> N=sc.nextInt();</span><br><span class="line"><span class="type">int</span> V=sc.nextInt();</span><br><span class="line"><span class="type">int</span>[] v=<span class="keyword">new</span> <span class="title class_">int</span>[N+<span class="number">1</span>]; <span class="comment">//体积</span></span><br><span class="line"><span class="type">int</span>[] w=<span class="keyword">new</span> <span class="title class_">int</span>[N+<span class="number">1</span>]; <span class="comment">//价值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) &#123;</span><br><span class="line">v[i]=sc.nextInt();</span><br><span class="line">w[i]=sc.nextInt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[V+<span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) &#123;<span class="comment">//遍历每一个可以使用的数量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=V;j&gt;=v[i];j--) &#123;<span class="comment">// 容量从大到小</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=j/v[i];k++) &#123;<span class="comment">//次数</span></span><br><span class="line">dp[j]=Math.max(dp[j], dp[j-k*v[i]]+k*w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">System.out.println(dp[V]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-多重背包问题-第-i-种物品最多有-si-件-掌握"><a href="#7-多重背包问题-第-i-种物品最多有-si-件-掌握" class="headerlink" title="7.多重背包问题_第 i 种物品最多有 si 件_掌握"></a>7.多重背包问题_第 i 种物品最多有 si 件_掌握</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="comment">// 01背包变形 和完全背包一样玩法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="type">int</span> <span class="variable">V</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="type">int</span>[] v=<span class="keyword">new</span> <span class="title class_">int</span>[N+<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span>[] w=<span class="keyword">new</span> <span class="title class_">int</span>[N+<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span>[] s=<span class="keyword">new</span> <span class="title class_">int</span>[N+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) &#123;</span><br><span class="line">v[i]=sc.nextInt();</span><br><span class="line">w[i]=sc.nextInt();</span><br><span class="line">s[i]=sc.nextInt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[V+<span class="number">1</span>];  <span class="comment">//dp[i]表示容量为i的最大价值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) &#123; <span class="comment">//遍历每一个可以使用的数量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=V;j&gt;=v[i];j--) &#123; <span class="comment">// 容量从大到小</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=s[i]&amp;&amp;k&lt;=j/v[i];k++) &#123;<span class="comment">//次数</span></span><br><span class="line"><span class="comment">//状态表达式 每次可以选k个体积为v的数量</span></span><br><span class="line">dp[j]=Math.max(dp[j], dp[j-k*v[i]]+k*w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(dp[V]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-数字三角形DP-从下到上-最大值-掌握"><a href="#8-数字三角形DP-从下到上-最大值-掌握" class="headerlink" title="8.数字三角形DP_从下到上_最大值_掌握"></a>8.数字三角形DP_从下到上_最大值_掌握</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[][] a=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">510</span>][<span class="number">510</span>];</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++) &#123;</span><br><span class="line">a[i][j]=sc.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从下到上dp</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++) &#123;</span><br><span class="line">a[i][j]=Math.max(a[i+<span class="number">1</span>][j+<span class="number">1</span>],a[i+<span class="number">1</span>][j])+a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(a[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>子串：原序列中必须连续的一段<br>子序列：原序列中可以不连续的一段</p></blockquote><h2 id="9-最长上升子序列DP"><a href="#9-最长上升子序列DP" class="headerlink" title="9. 最长上升子序列DP"></a>9. 最长上升子序列DP</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">1010</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= n;i++) a[i] = scan.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i] = <span class="number">1</span>;<span class="comment">//初始化每个dp[i]=1 至少本身就是一个</span></span><br><span class="line">            <span class="comment">//从起始位置开始找小于当前a[i]结尾数的最大上升序列长度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; i;j++)</span><br><span class="line">                <span class="keyword">if</span>(a[j] &lt; a[i])</span><br><span class="line">                    f[i] = Math.max(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            res = Math.max(res, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-最长公共子序列"><a href="#10-最长公共子序列" class="headerlink" title="10.最长公共子序列"></a>10.最长公共子序列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  所有在A[1…i−1]中出现过且在B[1…j]中也出现过的子序列，最大长度为f[i−1][j]</span></span><br><span class="line"><span class="comment">所有在A[1…i]中出现过且在B[1…j−1]中也出现过的子序列，最大长度为f[i][j−1]</span></span><br><span class="line"><span class="comment">当A[i]==B[j]时,划分多一个子集 所有在A[1…i−1]中出现过且在B[1…j−1]中也出现过的子序列，</span></span><br><span class="line"><span class="comment">最大长度为f[i−1][j−1]+1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">1010</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">char</span>[] a = <span class="keyword">new</span> <span class="title class_">char</span>[N];</span><br><span class="line">        <span class="type">char</span>[] b = <span class="keyword">new</span> <span class="title class_">char</span>[N];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];<span class="comment">//所有在A[1…i]中出现过且在B[1…j]中也出现过的子序列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123; <span class="comment">//a</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=m; j++)&#123; <span class="comment">//b</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);<span class="comment">//每次更新01和10的情况</span></span><br><span class="line">                <span class="keyword">if</span>(a[i] == b[j])&#123;<span class="comment">//如果两个字符相等，取最大值</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(dp[n][m]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="11-杨辉三角"><a href="#11-杨辉三角" class="headerlink" title="11. 杨辉三角"></a>11. 杨辉三角</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 杨辉三角 &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 杨辉三角形的行数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="comment">// 最左上角的值为1</span></span><br><span class="line">        arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 每进入一次循环，对杨辉三角形的一行的两条边置为 1</span></span><br><span class="line">            arr[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            arr[i][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当 i &gt; 1 的时候才进入该循环</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">                arr[i][j] = arr[i-<span class="number">1</span>][j-<span class="number">1</span>] + arr[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出杨辉三角形</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                System.out.print(arr[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadPoolExecutor</title>
      <link href="/2021/09/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2021/09/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="一-Java中有哪些方法获取多线程"><a href="#一-Java中有哪些方法获取多线程" class="headerlink" title="一. Java中有哪些方法获取多线程"></a>一. Java中有哪些方法获取多线程</h1><pre><code>  1.  实现Runnable接口  2.  实现Callable接口  3.  实例化Thread类  4.  使用线程池获取</code></pre><h2 id="①-实现Runnable接口"><a href="#①-实现Runnable接口" class="headerlink" title="①. 实现Runnable接口"></a>①. 实现Runnable接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现Runnable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="①-实现Callable接口"><a href="#①-实现Callable接口" class="headerlink" title="①. 实现Callable接口"></a>①. 实现Callable接口</h2><ul><li>实现Callable接口，也需要实现call方法，但是这个时候我们还需要有返回值，这个Callable接口的应用场景一般就在于批处理业务，比如转账的时候，需要给一会返回结果的状态码回来，代表本次操作成功还是失败</li></ul><p><img src="https://img-blog.csdnimg.cn/20210710211729424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Callable有返回值</span></span><br><span class="line"><span class="comment"> * 批量处理的时候，需要带返回值的接口（例如支付失败的时候，需要返回错误状态）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;come in Callable&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>最后我们需要做的就是通过Thread线程， 将MyThread2实现Callable接口的类包装起来</p></li><li><p>这里需要用到的是FutureTask类，他实现了Runnable接口，并且还需要传递一个实现Callable接口的类作为构造函数</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xizi.callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in Callable&quot;</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line">FutureTask&lt;Integer&gt; futureTask2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask2, <span class="string">&quot;B&quot;</span>).start();<span class="comment">//多个线程执行 一个FutureTask的时候，只会计算一次</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断futureTask是否计算完成</span></span><br><span class="line">        <span class="keyword">while</span>(!futureTask.isDone()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出FutureTask的返回值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;result FutureTask &quot;</span> + futureTask.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;result FutureTask2 &quot;</span> + futureTask2.get());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210710211556751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> 总结</p></blockquote><ol><li>多个线程执行 一个FutureTask的时候，只会计算一次</li><li>如果我们要两个线程同时计算任务的话，那么需要定义两个futureTask</li></ol><h1 id="二-ThreadPoolExecutor"><a href="#二-ThreadPoolExecutor" class="headerlink" title="二. ThreadPoolExecutor"></a>二. ThreadPoolExecutor</h1><h2 id="①-为什么用线程池"><a href="#①-为什么用线程池" class="headerlink" title="①. 为什么用线程池"></a>①. 为什么用线程池</h2><ul><li><p>线程池做的主要工作就是控制运行的线程的数量，处理过程中，将任务放入到队列中，然后线程创建后，启动这些任务，如果线程数量超过了最大数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。</p></li><li><p>它的主要特点为：<strong>线程复用、控制最大并发数、管理线程</strong>。</p></li><li><p>线程池中的任务是放入到阻塞队列中的。</p></li></ul><h2 id="②-线程池的好处"><a href="#②-线程池的好处" class="headerlink" title="②. 线程池的好处"></a>②. 线程池的好处</h2><blockquote><p><font color='red' size=4>多核处理的好处是：省略的上下文的切换开销</p></blockquote><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程，降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无线创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h2 id="③-架构说明"><a href="#③-架构说明" class="headerlink" title="③. 架构说明"></a>③. 架构说明</h2><ul><li>Java中线程池是通过Executor框架实现的，该框架中用到了Executor，Executors（代表工具类），ExecutorService，ThreadPoolExecutor这几个类。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210710212203608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="④-创建线程池"><a href="#④-创建线程池" class="headerlink" title="④. 创建线程池"></a>④. 创建线程池</h2><h3 id="1-Executors-newFixedThreadPool-int-i-：创建一个拥有-i-个线程的线程池"><a href="#1-Executors-newFixedThreadPool-int-i-：创建一个拥有-i-个线程的线程池" class="headerlink" title="1. Executors.newFixedThreadPool(int i) ：创建一个拥有 i 个线程的线程池"></a>1. Executors.newFixedThreadPool(int i) ：创建一个拥有 i 个线程的线程池</h3><ul><li>执行长期的任务，性能好很多</li><li>创建一个定长线程池，可控制线程数最大并发数，超出的线程会在队列中等待</li></ul><h3 id="2-Executors-newSingleThreadExecutor：创建一个只有1个线程的-单线程池"><a href="#2-Executors-newSingleThreadExecutor：创建一个只有1个线程的-单线程池" class="headerlink" title="2. Executors.newSingleThreadExecutor：创建一个只有1个线程的 单线程池"></a>2. Executors.newSingleThreadExecutor：创建一个只有1个线程的 单线程池</h3><ul><li>一个任务一个任务执行的场景</li><li>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行</li></ul><h3 id="3-Executors-newCacheThreadPool-创建一个可扩容的线程池"><a href="#3-Executors-newCacheThreadPool-创建一个可扩容的线程池" class="headerlink" title="3. Executors.newCacheThreadPool(); 创建一个可扩容的线程池"></a>3. Executors.newCacheThreadPool(); 创建一个可扩容的线程池</h3><ul><li>执行很多短期异步的小程序或者负载教轻的服务器</li><li>创建一个可缓存线程池，如果线程长度超过处理需要，可灵活回收空闲线程，如无可回收，则新建新线程</li></ul><h3 id="4-Executors-newScheduledThreadPool-int-corePoolSize-：线程池支持定时以及周期性执行任务"><a href="#4-Executors-newScheduledThreadPool-int-corePoolSize-：线程池支持定时以及周期性执行任务" class="headerlink" title="4.  Executors.newScheduledThreadPool(int corePoolSize)：线程池支持定时以及周期性执行任务"></a>4.  Executors.newScheduledThreadPool(int corePoolSize)：线程池支持定时以及周期性执行任务</h3><ul><li>创建一个corePoolSize为传入参数，最大线程数为整形的最大数的线程池</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一池5个处理线程（用池化技术，一定要记得关闭）</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个只有一个线程的线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个拥有N个线程的线程池，根据调度创建合适的线程</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newCacheThreadPool();</span><br></pre></td></tr></table></figure><h3 id="5-模拟10个用户来办理业务，每个用户就是一个来自外部请求线程"><a href="#5-模拟10个用户来办理业务，每个用户就是一个来自外部请求线程" class="headerlink" title="5. 模拟10个用户来办理业务，每个用户就是一个来自外部请求线程"></a>5. 模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xizi.TreadPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xizizzz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-7-10下午 01:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPoolDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Array  Arrays(辅助工具类)</span></span><br><span class="line">        <span class="comment">// Collection Collections(辅助工具类)</span></span><br><span class="line">        <span class="comment">// Executor Executors(辅助工具类)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一池5个处理线程（用池化技术，一定要记得关闭）</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//一池一线程</span></span><br><span class="line"><span class="comment">//        ExecutorService threadPool = Executors.newFixedThreadPool(1);</span></span><br><span class="line">        <span class="comment">//一池N线程</span></span><br><span class="line"><span class="comment">//        ExecutorService threadPool = Executors.newCachedThreadPool();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 循环十次，模拟业务办理，让5个线程处理这10个请求</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">tempInt</span> <span class="operator">=</span> i;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 给用户:&quot;</span> + tempInt + <span class="string">&quot; 办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=4> 一池5个处理线程 ExecutorService threadPool &#x3D; Executors.newFixedThreadPool(5);</p></blockquote><p><img src="https://img-blog.csdnimg.cn/202107102129029.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4>创建一个只有一个线程的线程池，ExecutorService threadPool &#x3D; Executors.newSingleThreadExecutor();</p></blockquote><p><img src="https://img-blog.csdnimg.cn/2021071021302331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> 创建一个拥有N个线程的线程池，ExecutorService threadPool &#x3D; Executors.newCacheThreadPool();</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210710213207176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="⑤-底层实现"><a href="#⑤-底层实现" class="headerlink" title="⑤. 底层实现"></a>⑤. 底层实现</h2><ul><li><p>我们通过查看源码，点击了Executors.newSingleThreadExecutor 和 Executors.newFixedThreadPool能够发现底层都是使用了ThreadPoolExecutor</p></li><li><p>我们可以看到线程池的内部，还使用到了LinkedBlockingQueue 链表阻塞队列</p></li><li><p>同时在查看Executors.newCacheThreadPool 看到底层用的是 SynchronousBlockingQueue阻塞队列</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210710213612403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210710213651593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210710213542167.png" alt="在这里插入图片描述"></p><h2 id="⑥-线程池的重要参数"><a href="#⑥-线程池的重要参数" class="headerlink" title="⑥. 线程池的重要参数"></a>⑥. 线程池的重要参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                             <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                             TimeUnit unit,</span></span><br><span class="line"><span class="params">                             BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                             ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                             RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210710213901468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> 线程池在创建的时候，一共有7大参数</p></blockquote><h3 id="1-corePoolSize：核心线程数，线程池中的常驻核心线程数"><a href="#1-corePoolSize：核心线程数，线程池中的常驻核心线程数" class="headerlink" title="1. corePoolSize：核心线程数，线程池中的常驻核心线程数"></a>1. corePoolSize：核心线程数，线程池中的常驻核心线程数</h3><ul><li>在创建线程池后，当有请求任务来之后，就会安排池中的线程去执行请求任务，近似理解为今日当值线程</li><li>当线程池中的线程数目达到corePoolSize后，就会把到达线程放到缓存队列中</li></ul><h3 id="2-maximumPoolSize：线程池能够容纳同时执行的最大线程数，此值必须大于等于1"><a href="#2-maximumPoolSize：线程池能够容纳同时执行的最大线程数，此值必须大于等于1" class="headerlink" title="2. maximumPoolSize：线程池能够容纳同时执行的最大线程数，此值必须大于等于1"></a>2. maximumPoolSize：线程池能够容纳同时执行的最大线程数，此值必须大于等于1</h3><ul><li>相当有扩容后的线程数，这个线程池能容纳的最多线程数</li></ul><h3 id="3-keepAliveTime：多余的空闲线程存活时间"><a href="#3-keepAliveTime：多余的空闲线程存活时间" class="headerlink" title="3. keepAliveTime：多余的空闲线程存活时间"></a>3. keepAliveTime：多余的空闲线程存活时间</h3><ul><li>当线程池数量超过corePoolSize时，当空闲时间达到keepAliveTime值时，多余的空闲线程会被销毁，直到只剩下corePoolSize个线程为止<br>- 默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用</li></ul><h3 id="4-unit：keepAliveTime的单位"><a href="#4-unit：keepAliveTime的单位" class="headerlink" title="4.  unit：keepAliveTime的单位"></a>4.  unit：keepAliveTime的单位</h3><h3 id="5-workQueue：任务队列，被提交的但未被执行的任务"><a href="#5-workQueue：任务队列，被提交的但未被执行的任务" class="headerlink" title="5.  workQueue：任务队列，被提交的但未被执行的任务"></a>5.  workQueue：任务队列，被提交的但未被执行的任务</h3><ul><li>LinkedBlockingQueue：链表阻塞队列</li><li>SynchronousBlockingQueue：同步阻塞队列</li></ul><h3 id="6-threadFactory：表示生成线程池中工作线程的线程工厂"><a href="#6-threadFactory：表示生成线程池中工作线程的线程工厂" class="headerlink" title="6.  threadFactory：表示生成线程池中工作线程的线程工厂"></a>6.  threadFactory：表示生成线程池中工作线程的线程工厂</h3><ul><li>用于创建线程池 一般用默认即可</li></ul><h3 id="7-handler：拒绝策略"><a href="#7-handler：拒绝策略" class="headerlink" title="7.  handler：拒绝策略"></a>7.  handler：拒绝策略</h3><ul><li>表示当队列满了并且工作线程大于线程池的最大线程数（maximumPoolSize3）时，如何来拒绝请求执行的Runnable的策略</li></ul><h2 id="⑦-拒绝策略"><a href="#⑦-拒绝策略" class="headerlink" title="⑦. 拒绝策略"></a>⑦. 拒绝策略</h2><blockquote><p><font color='red' size=4>以下所有拒绝策略都实现了RejectedExecutionHandler接口</p></blockquote><ul><li>AbortPolicy：默认，直接抛出RejectedExcutionException异常，阻止系统正常运行</li><li>DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常，如果运行任务丢失，这是一种好方案</li><li>CallerRunsPolicy：该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者</li><li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务</li></ul><blockquote><p><font color='red' size=4> 当营业窗口和阻塞队列中都满了时候，就需要设置拒绝策略</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210710214443938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="⑧-线程池底层工作原理"><a href="#⑧-线程池底层工作原理" class="headerlink" title="⑧. 线程池底层工作原理"></a>⑧. 线程池底层工作原理</h2><p><img src="https://img-blog.csdnimg.cn/20210710214521848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> 线程池工作过程</p></blockquote><ol><li><p>在创建了线程池后，等待提交过来的任务请求</p></li><li><p>当调用execute()方法添加一个请求任务时，线程池会做出如下判断</p></li><li><p>如果正在运行的线程池数量小于corePoolSize，那么马上创建线程运行这个任务</p></li><li><p>如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列</p></li><li><p>如果这时候队列满了，并且正在运行的线程数量还小于maximumPoolSize，那么还是创建非核心线程运行这个任务；</p></li><li><p>如果队列满了并且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行</p></li><li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行</p></li><li><p>当一个线程无事可做操作一定的时间(keepAliveTime)时，线程池会判断：</p></li><li><p>如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉</p></li><li><p>所以线程池的所有任务完成后，它会最终收缩到corePoolSize的大小</p></li></ol><blockquote><p><font color='red' size=4>  以顾客去银行办理业务为例，谈谈线程池的底层工作原理</p></blockquote><ol><li>最开始假设来了两个顾客，因为corePoolSize为2，因此这两个顾客直接能够去窗口办理</li><li>后面又来了三个顾客，因为corePool已经被顾客占用了，因此只有去候客区，也就是阻塞队列中等待</li><li>后面的人又陆陆续续来了，候客区可能不够用了，因此需要申请增加处理请求的窗口，这里的窗口指的是线程池中的线程数，以此来解决线程不够用的问题</li><li>假设受理窗口已经达到最大数，并且请求数还是不断递增，此时候客区和线程池都已经满了，为了防止大量请求冲垮线程池，已经需要开启拒绝策略</li><li>临时增加的线程会因为超过了最大存活时间，就会销毁，最后从最大数削减到核心数</li></ol><h2 id="⑨-为什么不用默认创建的线程池？"><a href="#⑨-为什么不用默认创建的线程池？" class="headerlink" title="⑨. 为什么不用默认创建的线程池？"></a>⑨. 为什么不用默认创建的线程池？</h2><blockquote><p><font color='red' size=4>  线程池创建的方法有：固定数的，单一的，可变的，那么在实际开发中，应该使用哪个？</p></blockquote><ul><li><p>我们一个都不用，在生产环境中是使用自己自定义的</p></li><li><p>为什么不用 Executors 中JDK提供的？</p></li></ul><blockquote><p><font color='red' size=4>  根据阿里巴巴手册：并发控制这章</p></blockquote><ul><li>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程</li><li>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题，如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题</li><li>线程池不允许使用Executors去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险<blockquote><p><font color='red' size=4>  Executors返回的线程池对象弊端如下：</p></blockquote></li><li>FixedThreadPool和SingleThreadPool：运行的请求队列长度为：Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM</li><li>CacheThreadPool和ScheduledThreadPool: 运行的请求队列长度为：Integer.MAX_VALUE，线程数上限太大导致OOM</li></ul><h2 id="⑩-手写线程池"><a href="#⑩-手写线程池" class="headerlink" title="⑩. 手写线程池"></a>⑩. 手写线程池</h2><h3 id="1-采用默认拒绝策略AbortPolicy"><a href="#1-采用默认拒绝策略AbortPolicy" class="headerlink" title="1. 采用默认拒绝策略AbortPolicy"></a>1. 采用默认拒绝策略AbortPolicy</h3><ol start="2"><li>从上面我们知道，因为默认的Executors创建的线程池，底层都是使用LinkBlockingQueue作为阻塞队列的，而LinkBlockingQueue虽然是有界的，但是它的界限是 Integer.MAX_VALUE 大概有20多亿，可以相当是无界的了，因此我们要使用ThreadPoolExecutor自己手动创建线程池，然后指定阻塞队列的大小</li></ol><blockquote><p><font color='red' size=4>下面我们创建了一个 核心线程数为2，最大线程数为5，并且阻塞队列数为3的线程池，然后使用for循环，模拟10个用户来进行请求</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xizi.TreadPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xizizzz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-7-10下午 01:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool_AbortPolicy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 手写线程池</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">corePoolSize</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">maximumPoolSize</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">keepAliveTime</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义线程池，只改变了LinkBlockingQueue的队列大小</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                corePoolSize,</span><br><span class="line">                maximumPoolSize,</span><br><span class="line">                keepAliveTime,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line">        <span class="comment">//设置的拒绝策略是默认的AbortPolicy，也就是抛异常的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 循环十次，模拟业务办理，让5个线程处理这10个请求</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">tempInt</span> <span class="operator">=</span> i;</span><br><span class="line">                executorService.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 给用户:&quot;</span> + tempInt + <span class="string">&quot; 办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=4>但是在用户执行到第九个的时候，触发了异常，程序中断</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210710215445371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>这是因为触发了拒绝策略，而我们设置的拒绝策略是默认的AbortPolicy，也就是抛异常的</p></li><li><p>触发条件是，请求的线程大于 阻塞队列大小 + 最大线程数 &#x3D; 8 的时候，也就是说第9个线程来获取线程池中的线程时，就会抛出异常从而报错退出。</p></li></ul><h3 id="2-采用CallerRunsPolicy拒绝策略"><a href="#2-采用CallerRunsPolicy拒绝策略" class="headerlink" title="2.  采用CallerRunsPolicy拒绝策略"></a>2.  采用CallerRunsPolicy拒绝策略</h3><ul><li>当我们更好其它的拒绝策略时，采用CallerRunsPolicy拒绝策略，也称为回退策略，就是把任务丢回原来的请求开启线程着，我们看运行结果</li></ul><p><img src="https://img-blog.csdnimg.cn/20210710215641501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>我们发现，输出的结果里面出现了main线程，因为线程池出发了拒绝策略，把任务回退到main线程，然后main线程对任务进行处理</li></ul><h3 id="3-采用-DiscardPolicy-拒绝策略"><a href="#3-采用-DiscardPolicy-拒绝策略" class="headerlink" title="3. 采用 DiscardPolicy 拒绝策略"></a>3. 采用 DiscardPolicy 拒绝策略</h3><ul><li>采用DiscardPolicy拒绝策略会，线程池会自动把后面的任务都直接丢弃，也不报异常，当任务无关紧要的时候，可以采用这个方式</li></ul><p><img src="https://img-blog.csdnimg.cn/20210710215715966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="4-采用DiscardOldestPolicy拒绝策略"><a href="#4-采用DiscardOldestPolicy拒绝策略" class="headerlink" title="4. 采用DiscardOldestPolicy拒绝策略"></a>4. 采用DiscardOldestPolicy拒绝策略</h3><p><img src="https://img-blog.csdnimg.cn/20210710215931677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="三-线程池的合理参数"><a href="#三-线程池的合理参数" class="headerlink" title="三. 线程池的合理参数"></a>三. 线程池的合理参数</h1><ul><li><p>生产环境中如何配置 <strong>corePoolSize 和 maximumPoolSize</strong></p></li><li><p>这个是根据具体业务来配置的，分为<strong>CPU密集型和IO密集型</strong></p></li></ul><h2 id="①-CPU密集型"><a href="#①-CPU密集型" class="headerlink" title="①. CPU密集型"></a>①. CPU密集型</h2><ul><li><p>CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行</p></li><li><p>CPU密集任务只有在真正的多核CPU上才可能得到加速（通过多线程）</p></li><li><p>而在单核CPU上，无论你开几个模拟的多线程该任务都不可能得到加速，因为CPU总的运算能力就那些。</p></li></ul><blockquote><p><font color='red' size=4>CPU密集型任务配置尽可能少的线程数量： 一般公式：CPU核数 + 1个线程数</p></blockquote><h2 id="②-IO密集型"><a href="#②-IO密集型" class="headerlink" title="②. IO密集型"></a>②. IO密集型</h2><ul><li><p>由于IO密集型任务线程并不是一直在执行任务，则可能多的线程，如 CPU核数 * 2</p></li><li><p>IO密集型，即该任务需要大量的IO操作，即大量的阻塞</p></li><li><p>在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力花费在等待上</p></li><li><p>所以IO密集型任务中使用多线程可以大大的加速程序的运行，即使在单核CPU上，这种加速主要就是利用了被浪费掉的阻塞时间。</p></li><li><p>IO密集时，大部分线程都被阻塞，故需要多配置线程数：</p></li></ul><blockquote><p><font color='red' size=4> 参考公式：CPU核数 &#x2F; (1 - 阻塞系数) 阻塞系数在0.8 ~ 0.9左右</p></blockquote><ul><li>例如：8核CPU：8&#x2F; (1 - 0.9) &#x3D; 80个线程数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-索引相关优化</title>
      <link href="/2021/09/06/MySQL-%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96/"/>
      <url>/2021/09/06/MySQL-%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="一-验证索引提升查询效率"><a href="#一-验证索引提升查询效率" class="headerlink" title="一. 验证索引提升查询效率"></a>一. 验证索引提升查询效率</h1><blockquote><p><font color='red' size=4> 根据ID 和name 进行精确查询查询 </p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210716214616446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="二-索引的使用-准备环境"><a href="#二-索引的使用-准备环境" class="headerlink" title="二. 索引的使用_准备环境"></a>二. 索引的使用_准备环境</h1><blockquote><p><font color='red' size=4> 创建联合索引</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210716214958795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_seller_name_sta_addr <span class="keyword">on</span> tb_seller(name,status,address);</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=4> 创建表和插入数据</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210716215147184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `tb_seller` (</span><br><span class="line">`sellerid` <span class="type">varchar</span> (<span class="number">100</span>),</span><br><span class="line">`name` <span class="type">varchar</span> (<span class="number">100</span>),</span><br><span class="line">`nickname` <span class="type">varchar</span> (<span class="number">50</span>),</span><br><span class="line">`password` <span class="type">varchar</span> (<span class="number">60</span>),</span><br><span class="line">`status` <span class="type">varchar</span> (<span class="number">1</span>),</span><br><span class="line">`address` <span class="type">varchar</span> (<span class="number">100</span>),</span><br><span class="line">`createtime` datetime,</span><br><span class="line">    <span class="keyword">primary</span> key(`sellerid`)</span><br><span class="line">)engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8mb4; </span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;alibaba&#x27;</span>,<span class="string">&#x27;阿里巴巴&#x27;</span>,<span class="string">&#x27;阿里小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;baidu&#x27;</span>,<span class="string">&#x27;百度科技有限公司&#x27;</span>,<span class="string">&#x27;百度小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;huawei&#x27;</span>,<span class="string">&#x27;华为科技有限公司&#x27;</span>,<span class="string">&#x27;华为小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;itcast&#x27;</span>,<span class="string">&#x27;传智播客教育科技有限公司&#x27;</span>,<span class="string">&#x27;传智播客&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;itheima&#x27;</span>,<span class="string">&#x27;黑马程序员&#x27;</span>,<span class="string">&#x27;黑马程序员&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;luoji&#x27;</span>,<span class="string">&#x27;罗技科技有限公司&#x27;</span>,<span class="string">&#x27;罗技小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;oppo&#x27;</span>,<span class="string">&#x27;OPPO科技有限公司&#x27;</span>,<span class="string">&#x27;OPPO官方旗舰店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;ourpalm&#x27;</span>,<span class="string">&#x27;掌趣科技股份有限公司&#x27;</span>,<span class="string">&#x27;掌趣小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;qiandu&#x27;</span>,<span class="string">&#x27;千度科技&#x27;</span>,<span class="string">&#x27;千度小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;sina&#x27;</span>,<span class="string">&#x27;新浪科技有限公司&#x27;</span>,<span class="string">&#x27;新浪官方旗舰店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;xiaomi&#x27;</span>,<span class="string">&#x27;小米科技&#x27;</span>,<span class="string">&#x27;小米官方旗舰店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;西安市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;yijia&#x27;</span>,<span class="string">&#x27;宜家家居&#x27;</span>,<span class="string">&#x27;宜家家居旗舰店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="三-避免索引失效"><a href="#三-避免索引失效" class="headerlink" title="三. 避免索引失效"></a>三. 避免索引失效</h1><h2 id="①-全值匹配-，对索引中所有列都指定具体值"><a href="#①-全值匹配-，对索引中所有列都指定具体值" class="headerlink" title="①. 全值匹配 ，对索引中所有列都指定具体值"></a>①. 全值匹配 ，对索引中所有列都指定具体值</h2><ul><li>该情况下，索引生效，执行效率高。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;北京市&#x27;</span>\G;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716215026690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="②-最左前缀法则-走索引"><a href="#②-最左前缀法则-走索引" class="headerlink" title="②. 最左前缀法则_走索引"></a>②. 最左前缀法则_走索引</h2><ul><li>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。</li></ul><blockquote><p><font color='red' size=4> 匹配最左前缀法则，走索引：</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716215323663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2021071621532888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span> <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;北京市&#x27;</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716215336240.png" alt="在这里插入图片描述"></p><h2 id="③-违反最左前缀法则-，-索引失效"><a href="#③-违反最左前缀法则-，-索引失效" class="headerlink" title="③.  违反最左前缀法则 ， 索引失效"></a>③.  违反最左前缀法则 ， 索引失效</h2><blockquote><p><font color='red' size=4> 违法最左前缀法则 ， 索引失效</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> status<span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;北京市&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716215330593.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210716215612168.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210716215615712.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> 如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span><span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;北京市&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716215339672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="④-范围查询右边的列，不能使用索引"><a href="#④-范围查询右边的列，不能使用索引" class="headerlink" title="④. 范围查询右边的列，不能使用索引"></a>④. 范围查询右边的列，不能使用索引</h2><blockquote><p><font color='red' size=4> 范围查询右边的列，不能使用索引 </p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span> <span class="keyword">and</span> status<span class="operator">&gt;</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;北京市&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716215619884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="⑤-不要在索引列上进行运算操作，-索引将失效"><a href="#⑤-不要在索引列上进行运算操作，-索引将失效" class="headerlink" title="⑤. 不要在索引列上进行运算操作， 索引将失效"></a>⑤. 不要在索引列上进行运算操作， 索引将失效</h2><blockquote><p><font color='red' size=4> 不要在索引列上进行运算操作， 索引将失效</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="built_in">substring</span>(name,<span class="number">3</span>,<span class="number">2</span>)<span class="operator">=</span><span class="string">&#x27;科技&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716220058143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="⑥-字符串不加单引号，造成索引失效"><a href="#⑥-字符串不加单引号，造成索引失效" class="headerlink" title="⑥. 字符串不加单引号，造成索引失效"></a>⑥. 字符串不加单引号，造成索引失效</h2><blockquote><p><font color='red' size=4>字符串不加单引号，造成索引失效</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/202107162201379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="⑦-尽量使用覆盖索引，避免select"><a href="#⑦-尽量使用覆盖索引，避免select" class="headerlink" title="⑦.  尽量使用覆盖索引，避免select  *"></a>⑦.  尽量使用覆盖索引，避免select  *</h2><ul><li>尽量使用覆盖索引（只访问索引的查询（索引列完全包含查询列）），减少select * 。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210716220323922.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> name,status,address <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716220329803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210716220343608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210716220353464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="⑧-如果查询列，超出索引列，也会降低性能。"><a href="#⑧-如果查询列，超出索引列，也会降低性能。" class="headerlink" title="⑧.  如果查询列，超出索引列，也会降低性能。"></a>⑧.  如果查询列，超出索引列，也会降低性能。</h2><blockquote><p><font color='red' size=4> 如果查询列，超出索引列，也会降低性能。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210716220515112.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210716220526315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> index ：使用覆盖索引的时候就会出现</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">where</span>：在查找使用索引的情况下，需要回表去查询所需的数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> index <span class="keyword">condition</span>：查找使用了索引，但是需要回表查询数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> index ; <span class="keyword">using</span> <span class="keyword">where</span>：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据</span><br></pre></td></tr></table></figure><h2 id="⑨-用or分割开的条件"><a href="#⑨-用or分割开的条件" class="headerlink" title="⑨.  用or分割开的条件"></a>⑨.  用or分割开的条件</h2><blockquote><p><font color='red' size=4>用or分割开的条件</p></blockquote><ul><li><p>如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</p></li><li><p>示例，name字段是索引列 ， 而nickname不是索引列，中间是or进行连接是不走索引的</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span> <span class="keyword">or</span> nickname<span class="operator">=</span><span class="string">&#x27;小米官方旗舰店&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716220600689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="⑩-以-开头的Like模糊查询，索引失效"><a href="#⑩-以-开头的Like模糊查询，索引失效" class="headerlink" title="⑩. 以%开头的Like模糊查询，索引失效"></a>⑩. 以%开头的Like模糊查询，索引失效</h2><blockquote><p><font color='red' size=4> 以%开头的Like模糊查询，索引失效</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> name,status <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%小米%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> name,status <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%小米&#x27;</span>;</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> name,status <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;小米%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716220710567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210716220714826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210716220728100.png" alt="在这里插入图片描述"></p><h2 id="十一-如果MySQL评估使用索引比全表更慢，则不使用索引"><a href="#十一-如果MySQL评估使用索引比全表更慢，则不使用索引" class="headerlink" title="十一. 如果MySQL评估使用索引比全表更慢，则不使用索引"></a>十一. 如果MySQL评估使用索引比全表更慢，则不使用索引</h2><blockquote><p><font color='red' size=4> 如果MySQL评估使用索引比全表更慢，则不使用索引</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> tb_seller;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">create</span> index idx_seller_address <span class="keyword">on</span> tb_seller(address);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716220834579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/202107162208110.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210716220916178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210716220923329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="十二-is-null，-is-not-null，-gt-有时索引失效。"><a href="#十二-is-null，-is-not-null，-gt-有时索引失效。" class="headerlink" title="十二.  is  null， is not null，&gt;有时索引失效。"></a>十二.  is  null， is not null，&gt;有时索引失效。</h2><blockquote><p><font color='red' size=4> is  NULL ， is NOT NULL  &gt;有时索引失效。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span>  <span class="keyword">from</span> tb_seller <span class="keyword">where</span> address <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span>  <span class="keyword">from</span> tb_seller <span class="keyword">where</span> address <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716220935222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="十三-in-走索引，-not-in-索引失效"><a href="#十三-in-走索引，-not-in-索引失效" class="headerlink" title="十三.  in 走索引， not in 索引失效"></a>十三.  in 走索引， not in 索引失效</h2><blockquote><p><font color='red' size=4>  in 走索引， not in 索引失效</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210716221053258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span>  <span class="keyword">from</span> tb_seller <span class="keyword">where</span> sellerid <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;oppo&#x27;</span>,<span class="string">&#x27;xiaomi&#x27;</span>,<span class="string">&#x27;sina&#x27;</span>);</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span>  <span class="keyword">from</span> tb_seller <span class="keyword">where</span> sellerid <span class="keyword">in</span> (<span class="string">&#x27;oppo&#x27;</span>,<span class="string">&#x27;xiaomi&#x27;</span>,<span class="string">&#x27;sina&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="十四-单列索引和复合索引"><a href="#十四-单列索引和复合索引" class="headerlink" title="十四. 单列索引和复合索引"></a>十四. 单列索引和复合索引</h2><ul><li>尽量使用复合索引，而少使用单列索引 。</li></ul><blockquote><p><font color='red' size=4> 创建复合索引进行测试</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_name_sta_address <span class="keyword">on</span> tb_seller(name, status, address);</span><br><span class="line"></span><br><span class="line">就相当于创建了三个索引 ： </span><br><span class="line">name</span><br><span class="line">name <span class="operator">+</span> status</span><br><span class="line">name <span class="operator">+</span> status <span class="operator">+</span> address</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716222147511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> index idx_seller_name_sta_addr  <span class="keyword">on</span> tb_seller;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716222201401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> 创建单列索引进行测试</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_seller_name <span class="keyword">on</span> tb_seller(name);</span><br><span class="line"><span class="keyword">create</span> index idx_seller_status <span class="keyword">on</span> tb_seller(status);</span><br><span class="line"><span class="keyword">create</span> index idx_seller_address <span class="keyword">on</span> tb_seller(address);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716222239213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4>数据库会选择一个最优的索引（辨识度最高索引）来使用，并不会使用全部索引 。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;西安市&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716222354116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210716222411794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4>创建组合索引进行测试</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210716222430316.png" alt="在这里插入图片描述"></p><h1 id="四-查看索引使用情况"><a href="#四-查看索引使用情况" class="headerlink" title="四. 查看索引使用情况"></a>四. 查看索引使用情况</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Handler_read%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Handler_read%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210716222451119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210716222715876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap-Jdk1.8</title>
      <link href="/2021/09/04/ConcurrentHashMap---JDK1.8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/09/04/ConcurrentHashMap---JDK1.8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="一-ConcurrentHashMap源码分析—Jdk1-8"><a href="#一-ConcurrentHashMap源码分析—Jdk1-8" class="headerlink" title="一. ConcurrentHashMap源码分析—Jdk1.8"></a>一. ConcurrentHashMap源码分析—Jdk1.8</h1><h2 id="①-ConcurrentHashMap底层数据结构"><a href="#①-ConcurrentHashMap底层数据结构" class="headerlink" title="①. ConcurrentHashMap底层数据结构"></a>①. ConcurrentHashMap底层数据结构</h2><ul><li>ConcurrentHashMap相比HashMap而言，是多线程安全的，其底层数据与HashMap的数据结构相同</li></ul><blockquote><p><font color='red' size=4> 数组+链表+红黑树来实现的，使用了CAS的方式和Synchronized加锁来保证线程的安全。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210305212440663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="②-ConcurrentHashMap基本属性"><a href="#②-ConcurrentHashMap基本属性" class="headerlink" title="②. ConcurrentHashMap基本属性"></a>②. ConcurrentHashMap基本属性</h2><ul><li>对于ConcurrentHashMap而言，添加了Unsafe实例，主要用于反射获取对象相应的字段。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210516143800250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//版本号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7249069246763182397L</span>;</span><br><span class="line"><span class="comment">// node数组最大容量：2^30=1073741824</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 默认初始值，必须是2的幂数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="comment">//数组可能最大值，需要与toArray（）相关方法关联</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="comment">//并发级别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 链表转红黑树阀值,&gt; 8 链表转换为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="comment">//树转链表阀值，小于等于6（tranfer时，lc、hc=0两个计数器分别++记录原bin、新binTreeNode数量，&lt;=UNTREEIFY_THRESHOLD 则untreeify(lo)）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TRANSFER_STRIDE</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">RESIZE_STAMP_BITS</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 2^15-1，help resize的最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_RESIZERS</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 32-16=16，sizeCtl中记录size大小的偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESIZE_STAMP_SHIFT</span> <span class="operator">=</span> <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"><span class="comment">// forwarding nodes的hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOVED</span>     <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 树根节点的hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEBIN</span>   <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line"><span class="comment">// ReservationNode的hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESERVED</span>  <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"><span class="comment">// 可用处理器数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"><span class="comment">//存放node的数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">/*控制标识符，用来控制table的初始化和扩容的操作，不同的值有不同的含义</span></span><br><span class="line"><span class="comment"> *当为负数时：-1代表正在初始化，-N代表有N-1个线程正在 进行扩容</span></span><br><span class="line"><span class="comment"> *当为0时：代表当时的table还没有被初始化</span></span><br><span class="line"><span class="comment"> *当为正数时：表示初始化或者下一次进行扩容的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;</span><br></pre></td></tr></table></figure><h2 id="③-ConcurrentHashMap的Node节点"><a href="#③-ConcurrentHashMap的Node节点" class="headerlink" title="③. ConcurrentHashMap的Node节点"></a>③. ConcurrentHashMap的Node节点</h2><ul><li>Node是ConcurrentHashMap存储结构的基本单元，继承于HashMap中的Entry，用于存储数据</li><li>Node是最核心的内部类，它包装了key-value键值对，所有插入ConcurrentHashMap的数据都包装在这里面。它与HashMap中的定义很相似，但是但是有一些差别它对value和next属性设置了volatile同步锁，它不允许调用setValue方法直接改变Node的value域，它增加了find方法辅助map.get()方法。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210516144035183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">//链表的数据结构</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;    <span class="comment">//key的hash值</span></span><br><span class="line">    <span class="keyword">final</span> K key;       <span class="comment">//key</span></span><br><span class="line">    <span class="comment">//val和next都会在扩容时发生变化，所以加上volatile来保持可见性和禁止重排序</span></span><br><span class="line">    <span class="keyword">volatile</span> V val;   <span class="comment">//get操作全程不需要加锁是因为Node的成员val是用volatile修饰</span></span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;  <span class="comment">//表示链表中的下一个节点，数组用volatile修饰主要是保证在数组扩容的时候保证可见性</span></span><br><span class="line">    Node(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.hash = hash;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>       &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>     &#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>   &#123; <span class="keyword">return</span> key.hashCode() ^ val.hashCode(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + val; &#125;</span><br><span class="line">    <span class="comment">//不允许更新value </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V value)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        Object k, v, u; Map.Entry&lt;?,?&gt; e;</span><br><span class="line">        <span class="keyword">return</span> ((o <span class="keyword">instanceof</span> Map.Entry) &amp;&amp;</span><br><span class="line">                (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                (v = e.getValue()) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                (k == key || k.equals(key)) &amp;&amp;</span><br><span class="line">                (v == (u = val) || v.equals(u)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用于map中的get（）方法，子类重写</span></span><br><span class="line">    Node&lt;K,V&gt; <span class="title function_">find</span><span class="params">(<span class="type">int</span> h, Object k)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                K ek;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != <span class="literal">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="④-ConcurrentHashMap的红黑树TreeNode节点"><a href="#④-ConcurrentHashMap的红黑树TreeNode节点" class="headerlink" title="④.ConcurrentHashMap的红黑树TreeNode节点"></a>④.ConcurrentHashMap的红黑树TreeNode节点</h2><ul><li>TreeNode继承与Node，但是数据结构换成了二叉树结构，它是红黑树的数据的存储结构，用于红黑树中存储数据，当链表的节点数大于8时会转换成红黑树的结构，他就是通过TreeNode作为存储结构代替Node来转换成黑红树</li></ul><p><img src="https://img-blog.csdnimg.cn/20210516144153446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">//树形结构的属性定义</span></span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="type">boolean</span> red; <span class="comment">//标志红黑树的红节点</span></span><br><span class="line">    TreeNode(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next,</span><br><span class="line">             TreeNode&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, val, next);</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;K,V&gt; <span class="title function_">find</span><span class="params">(<span class="type">int</span> h, Object k)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findTreeNode(h, k, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据key查找 从根节点开始找出相应的TreeNode，</span></span><br><span class="line">    <span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">findTreeNode</span><span class="params">(<span class="type">int</span> h, Object k, Class&lt;?&gt; kc)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="literal">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">do</span>  &#123;</span><br><span class="line">                <span class="type">int</span> ph, dir; K pk; TreeNode&lt;K,V&gt; q;</span><br><span class="line">                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (pk != <span class="literal">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="literal">null</span>)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="literal">null</span>)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="literal">null</span> ||</span><br><span class="line">                          (kc = comparableClassFor(k)) != <span class="literal">null</span>) &amp;&amp;</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                    p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.findTreeNode(h, k, kc)) != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = pl;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑤-ConcurrentHashMap的TreeBin存储树形结构的容器"><a href="#⑤-ConcurrentHashMap的TreeBin存储树形结构的容器" class="headerlink" title="⑤. ConcurrentHashMap的TreeBin存储树形结构的容器"></a>⑤. ConcurrentHashMap的TreeBin存储树形结构的容器</h2><ul><li>TreeBin就是封装TreeNode的容器，它提供转换黑红树的一些条件和锁的控制</li></ul><p><img src="https://img-blog.csdnimg.cn/20210516144356109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeBin</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">//指向TreeNode列表和根节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root;</span><br><span class="line">    <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> lockState;</span><br><span class="line">    <span class="comment">// 读写锁状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WRITER</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 获取写锁的状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WAITER</span> <span class="operator">=</span> <span class="number">2</span>; <span class="comment">// 等待写锁的状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">READER</span> <span class="operator">=</span> <span class="number">4</span>; <span class="comment">// 增加数据时读锁的状态</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化红黑树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TreeBin(TreeNode&lt;K,V&gt; b) &#123;</span><br><span class="line">        <span class="built_in">super</span>(TREEBIN, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.first = b;</span><br><span class="line">        TreeNode&lt;K,V&gt; r = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = b, next; x != <span class="literal">null</span>; x = next) &#123;</span><br><span class="line">            next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">            x.left = x.right = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">                x.parent = <span class="literal">null</span>;</span><br><span class="line">                x.red = <span class="literal">false</span>;</span><br><span class="line">                r = x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> x.key;</span><br><span class="line">                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> x.hash;</span><br><span class="line">                Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = r;;) &#123;</span><br><span class="line">                    <span class="type">int</span> dir, ph;</span><br><span class="line">                    <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key;</span><br><span class="line">                    <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                        dir = -<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                        dir = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                              (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                             (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                        dir = tieBreakOrder(k, pk);</span><br><span class="line">                        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                    <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        x.parent = xp;</span><br><span class="line">                        <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                            xp.left = x;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            xp.right = x;</span><br><span class="line">                        r = balanceInsertion(r, x);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.root = r;</span><br><span class="line">        <span class="keyword">assert</span> <span class="title function_">checkInvariants</span><span class="params">(root)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑥-ConcurrentHashMap构造函数"><a href="#⑥-ConcurrentHashMap构造函数" class="headerlink" title="⑥. ConcurrentHashMap构造函数"></a>⑥. ConcurrentHashMap构造函数</h2><p><img src="https://img-blog.csdnimg.cn/20210516144801218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该构造函数用于创建一个带有默认初始容量 (16)、加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该构造函数用于创建一个带有指定初始容量、默认加载因子 (0.75) 和 concurrencyLevel (16) 的新的空映射</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 参数的有效性检查</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="comment">//2.table初始化的长度(如果不指定默认情况下为16)。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该构造函数用于构造一个与给定映射具有相同映射关系的新映射</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该构造函数用于创建一个带有指定初始容量、加载因子和默认 concurrencyLevel (1) 的新的空映射。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该构造函数用于创建一个带有指定初始容量、加载因子和并发级别的新的空映射</span></span><br><span class="line"><span class="comment">// concurrencyLevel 表示能够同时更新ConccurentHashMap且不产生锁竞争的最大线程数。</span></span><br><span class="line"><span class="comment">// 默认值为16 即允许16个线程并发可能不会产生竞争</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,<span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="comment">//计算出容器的大小 初始化长度/加载因子+1</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">long</span>)(<span class="number">1.0</span> + (<span class="type">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> (size &gt;= (<span class="type">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="type">int</span>)size);</span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑦-ConcurrentHashMap的节点put流程"><a href="#⑦-ConcurrentHashMap的节点put流程" class="headerlink" title="⑦. ConcurrentHashMap的节点put流程"></a>⑦. ConcurrentHashMap的节点put流程</h2><h3 id="1-putVal-方法"><a href="#1-putVal-方法" class="headerlink" title="1. putVal()方法"></a>1. putVal()方法</h3><p><img src="https://img-blog.csdnimg.cn/2021051614500430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line"> <span class="comment">//K,V都不能为空，否则的话跑出异常</span></span><br><span class="line">       <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">//取得key的hash值</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());  </span><br><span class="line">    <span class="comment">//用来计算在这个节点总共有多少个元素，用来控制扩容或者转移为树  </span></span><br><span class="line">       <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;    </span><br><span class="line">       <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;    <span class="comment">//</span></span><br><span class="line">           Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">           <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)   </span><br><span class="line">    <span class="comment">//第一次put的时候table没有初始化，则初始化table </span></span><br><span class="line">               tab = initTable();    </span><br><span class="line">    <span class="comment">//否则通过哈希计算出一个表中的位置因为n是数组的长度，所以(n-1)&amp;hash肯定不会出现数组越界</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;  </span><br><span class="line">    <span class="comment">//如果这个位置没有元素的话，则通过cas的方式尝试添加，注意这个时候是没有加锁的  </span></span><br><span class="line">               <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,        </span><br><span class="line">               <span class="comment">//创建一个Node添加到数组中区，null表示的是下一个节点为空</span></span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))        </span><br><span class="line">                   <span class="keyword">break</span>;                   </span><br><span class="line">           &#125;</span><br><span class="line">    <span class="comment">//如果检测到某个节点的hash值是MOVED，则表示正在进行数组扩张的数据复制阶段，</span></span><br><span class="line">    <span class="comment">//则当前线程也会参与去复制，通过允许多线程复制的功能，一次来减少数组的复制所带来的性能损失</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)    </span><br><span class="line">               tab = helpTransfer(tab, f);</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * 如果在这个位置有元素的话，就采用synchronized的方式加锁，</span></span><br><span class="line"><span class="comment">                *     如果是链表的话(hash大于0)，就对这个链表的所有元素进行遍历，</span></span><br><span class="line"><span class="comment">                *         如果找到了key和key的hash值都一样的节点，则把它的值替换到</span></span><br><span class="line"><span class="comment">                *         如果没找到的话，则添加在链表的最后面</span></span><br><span class="line"><span class="comment">                *  否则，是树的话，则调用putTreeVal方法添加到树中去</span></span><br><span class="line"><span class="comment">                *  </span></span><br><span class="line"><span class="comment">                *  在添加完之后，会对该节点上关联的的数目进行判断，</span></span><br><span class="line"><span class="comment">                *  如果在8个以上的话，则会调用treeifyBin方法，来尝试转化为树，或者是扩容</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">               <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">               <span class="comment">//再次取出要存储的位置的元素，跟前面取出来的比较</span></span><br><span class="line">                   <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;      </span><br><span class="line">               <span class="comment">//取出来的元素的hash值大于0，当转换为树之后，hash值为-2  </span></span><br><span class="line">                       <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;                </span><br><span class="line">                           binCount = <span class="number">1</span>;            </span><br><span class="line">                      <span class="comment">//遍历这个链表</span></span><br><span class="line">                           <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;    </span><br><span class="line">                               K ek;</span><br><span class="line">                      <span class="comment">//要存的元素的hash，key跟要存储的位置的节点的相同的时候，替换掉该节点的value即可</span></span><br><span class="line">                               <span class="keyword">if</span> (e.hash == hash &amp;&amp;        </span><br><span class="line">                                   ((ek = e.key) == key ||</span><br><span class="line">                                    (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                   oldVal = e.val;</span><br><span class="line">                      <span class="comment">//当使用putIfAbsent的时候，只有在这个key没有设置值得时候才设置</span></span><br><span class="line">                                   <span class="keyword">if</span> (!onlyIfAbsent)        </span><br><span class="line">                                       e.val = value;</span><br><span class="line">                                   <span class="keyword">break</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                               Node&lt;K,V&gt; pred = e;</span><br><span class="line">                      <span class="comment">//如果不是同样的hash，同样的key的时候，则判断该节点的下一个节点是否为空，</span></span><br><span class="line">                               <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;    </span><br><span class="line">                      <span class="comment">//为空的话把这个要加入的节点设置为当前节点的下一个节点</span></span><br><span class="line">                                   pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,        </span><br><span class="line">                                                             value, <span class="literal">null</span>);</span><br><span class="line">                                   <span class="keyword">break</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">//表示已经转化成红黑树类型了</span></span><br><span class="line">                       <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;    </span><br><span class="line">                           Node&lt;K,V&gt; p;</span><br><span class="line">                           binCount = <span class="number">2</span>;</span><br><span class="line">                       <span class="comment">//调用putTreeVal方法，将该元素添加到树中去</span></span><br><span class="line">                           <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,    </span><br><span class="line">                                                          value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                               oldVal = p.val;</span><br><span class="line">                               <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                   p.val = value;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//当在同一个节点的数目达到8个的时候，则扩张数组或将给节点的数据转为tree</span></span><br><span class="line">                   <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)    </span><br><span class="line">                       treeifyBin(tab, i);    </span><br><span class="line">                   <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                       <span class="keyword">return</span> oldVal;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="comment">//计数</span></span><br><span class="line">       addCount(<span class="number">1L</span>, binCount);   </span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">（<span class="number">1</span>）如果桶数组未初始化，则初始化；</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）如果待插入的元素所在的桶为空，则尝试把此元素直接插入到桶的第一个位置；</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）如果正在扩容，则当前线程一起加入到扩容的过程中；</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）如果待插入的元素所在的桶不为空且不在迁移元素，则锁住这个桶（分段锁）；</span><br><span class="line"></span><br><span class="line">（<span class="number">5</span>）如果当前桶中元素以链表方式存储，则在链表中寻找该元素或者插入元素；</span><br><span class="line"></span><br><span class="line">（<span class="number">6</span>）如果当前桶中元素以红黑树方式存储，则在红黑树中寻找该元素或者插入元素；</span><br><span class="line"></span><br><span class="line">（<span class="number">7</span>）如果元素存在，则返回旧值；</span><br><span class="line"></span><br><span class="line">（<span class="number">8</span>）如果元素不存在，整个Map的元素个数加<span class="number">1</span>，并检查是否需要扩容；</span><br><span class="line"></span><br><span class="line">添加元素操作中使用的锁主要有（自旋锁 + CAS + <span class="keyword">synchronized</span> + 分段锁）。</span><br></pre></td></tr></table></figure><h3 id="2-initTable-方法初始化数组"><a href="#2-initTable-方法初始化数组" class="headerlink" title="2. initTable() 方法初始化数组"></a>2. initTable() 方法初始化数组</h3><ul><li>对于table的大小，会根据sizeCtl的值进行设置，如果没有设置szieCtl的值，那么默认生成的table大小为16，否则，会根据sizeCtl的大小设置table大小。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210516145130263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="comment">//空的table才能进入初始化操作</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//sizeCtl&lt;0表示其他线程已经在初始化了或者扩容了，挂起当前线程</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>) </span><br><span class="line">            Thread.yield(); </span><br><span class="line">    <span class="comment">//CAS操作SIZECTL为-1，表示初始化状态</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="comment">//初始化</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//记录下次扩容的大小</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-tabAt-方法"><a href="#3-tabAt-方法" class="headerlink" title="3. tabAt() 方法"></a>3. tabAt() 方法</h3><ul><li>此函数返回table数组中下标为i的结点，可以看到是通过Unsafe对象通过反射获取的，getObjectVolatile的第二项参数为下标为i的偏移地址。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210719165505101.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取索引i处Node</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="title function_">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-casTabAt-方法"><a href="#4-casTabAt-方法" class="headerlink" title="4. casTabAt() 方法"></a>4. casTabAt() 方法</h3><ul><li>此函数用于比较table数组下标为i的结点是否为c，若为c，则用v交换操作。否则，不进行交换操作。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210719165611956.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用CAS算法设置i位置上的Node节点（将c和table[i]比较，相同则插入v）。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i,</span></span><br><span class="line"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-helpTransfer-方法"><a href="#5-helpTransfer-方法" class="headerlink" title="5. helpTransfer() 方法"></a>5. helpTransfer() 方法</h3><ul><li><p>此函数用于在扩容时将table表中的结点转移到nextTable中。</p></li><li><p>如果取出来的节点的hash值是MOVED(-1)的话，则表示当前正在对这个数组进行扩容</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210516145242230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *帮助从旧的table的元素复制到新的table中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="literal">null</span>) &#123; </span><br><span class="line">        <span class="comment">//新的table nextTba已经存在前提下才能帮助扩容</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(tab.length);</span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">//调用扩容方法</span></span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-treeifyBin-方法-链表转红黑树"><a href="#6-treeifyBin-方法-链表转红黑树" class="headerlink" title="6. treeifyBin() 方法 链表转红黑树"></a>6. treeifyBin() 方法 链表转红黑树</h3><ul><li>此函数用于将桶中的数据结构转化为红黑树，其中，值得注意的是，当table的长度未达到阈值时，会进行一次扩容操作，该操作会使得触发treeifyBin操作的某个桶中的所有元素进行一次重新分配，这样可以避免某个桶中的结点数量太大。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表转红黑树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; b; <span class="type">int</span> n, sc;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//若length&lt;64,直接tryPresize,两倍table.length;不转树</span></span><br><span class="line">            <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">                <span class="comment">//扩容函数为：tryPresize</span></span><br><span class="line">                tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//只有当tab.length &gt;= 64, ConcurrentHashMap才会使用红黑树。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="literal">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (b) &#123; <span class="comment">// 对桶中第一个结点进行加锁</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;  <span class="comment">// 第一个结点没有变化</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">// 遍历桶中所有结点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="comment">// 新生一个TreeNode结点</span></span><br><span class="line">                            TreeNode&lt;K,V&gt; p =<span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;(e.hash, e.key, e.val,<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((p.prev = tl) == <span class="literal">null</span>)  <span class="comment">// 该结点前驱为空</span></span><br><span class="line">                                <span class="comment">// 设置p为头结点</span></span><br><span class="line">                                hd = p;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                <span class="comment">// 尾节点的next域赋值为p</span></span><br><span class="line">                                tl.next = p;</span><br><span class="line">                            <span class="comment">// 尾节点赋值为p</span></span><br><span class="line">                            tl = p;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 设置table表中下标为index的值为hd</span></span><br><span class="line">                        setTabAt(tab, index, <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hd));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-transfer-扩容方法"><a href="#7-transfer-扩容方法" class="headerlink" title="7. transfer() 扩容方法"></a>7. transfer() 扩容方法</h3><ul><li>ConcurrentHashMap扩容是允许多个线程并发进行扩容的，首先构造一个两倍于当前数据长度的数组，然后计算每个线程处理的槽的空间，然后通过死循环依次递减的方式对每个槽位进行判断知道有实际值的槽位，通过将槽位的每个节点分成2个链表将高位逻辑与计算为1的链表插入到i+n的位置，同时将旧的节点设置为占位符然后继续向前推进扩容操作。<br><img src="https://img-blog.csdnimg.cn/20210305220929894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><p><img src="https://img-blog.csdnimg.cn/20210516145342988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tab.length, stride;</span><br><span class="line">        <span class="comment">// 每核处理的量小于16，则强制赋值16</span></span><br><span class="line">        <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">            stride = MIN_TRANSFER_STRIDE; </span><br><span class="line">        <span class="keyword">if</span> (nextTab == <span class="literal">null</span>) &#123;            </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="comment">//构建一个nextTable对象，其容量为原来容量的两倍</span></span><br><span class="line">                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];        </span><br><span class="line">                nextTab = nt;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      </span><br><span class="line">                sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nextTable = nextTab;</span><br><span class="line">            transferIndex = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextn</span> <span class="operator">=</span> nextTab.length;</span><br><span class="line">        <span class="comment">// 连接点指针，用于标志位（fwd的hash值为-1，fwd.nextTable=nextTab）</span></span><br><span class="line">        ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);</span><br><span class="line">        <span class="comment">// 当advance == true时，表明该节点已经处理过了</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">advance</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">finishing</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="type">int</span> fh;</span><br><span class="line">            <span class="comment">// 控制 --i ,遍历原hash表中的节点</span></span><br><span class="line">            <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">                <span class="type">int</span> nextIndex, nextBound;</span><br><span class="line">                <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                    advance = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    i = -<span class="number">1</span>;</span><br><span class="line">                    advance = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 用CAS计算得到的transferIndex</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                        (<span class="built_in">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                                nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                        nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                    bound = nextBound;</span><br><span class="line">                    i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                    advance = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">                <span class="type">int</span> sc;</span><br><span class="line">                <span class="comment">// 已经完成所有节点复制了</span></span><br><span class="line">                <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                    nextTable = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">// table 指向nextTable</span></span><br><span class="line">                    table = nextTab;        </span><br><span class="line">                    <span class="comment">// sizeCtl阈值为原来的1.5倍</span></span><br><span class="line">                    sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);     </span><br><span class="line">                    <span class="keyword">return</span>;     <span class="comment">// 跳出死循环，</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// CAS 更扩容阈值，在这里面sizectl值减一，说明新加入一个线程参与到扩容操作</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    finishing = advance = <span class="literal">true</span>;</span><br><span class="line">                    i = n; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历的节点为null，则放入到ForwardingNode 指针节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="literal">null</span>)</span><br><span class="line">                advance = casTabAt(tab, i, <span class="literal">null</span>, fwd);</span><br><span class="line">            <span class="comment">// f.hash == -1 表示遍历到了ForwardingNode节点，意味着该节点已经处理过了</span></span><br><span class="line">            <span class="comment">// 这里是控制并发扩容的核心</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                advance = <span class="literal">true</span>; <span class="comment">// already processed</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 节点加锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="comment">// 节点复制工作</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                        <span class="comment">// fh &gt;= 0 ,表示为链表节点</span></span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 构造两个链表  一个是原链表  另一个是原链表的反序排列</span></span><br><span class="line">                            <span class="type">int</span> <span class="variable">runBit</span> <span class="operator">=</span> fh &amp; n;</span><br><span class="line">                            Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">                                <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> p.hash &amp; n;</span><br><span class="line">                                <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                    runBit = b;</span><br><span class="line">                                    lastRun = p;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                                ln = lastRun;</span><br><span class="line">                                hn = <span class="literal">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                hn = lastRun;</span><br><span class="line">                                ln = <span class="literal">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                                <span class="type">int</span> <span class="variable">ph</span> <span class="operator">=</span> p.hash; <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key; <span class="type">V</span> <span class="variable">pv</span> <span class="operator">=</span> p.val;</span><br><span class="line">                                <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                    ln = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hn = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 在nextTable i 位置处插上链表</span></span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            <span class="comment">// 在nextTable i + n 位置处插上链表</span></span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            <span class="comment">// 在table i 位置处插上ForwardingNode 表示该节点已经处理过了</span></span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            <span class="comment">// advance = true 可以执行--i动作，遍历节点</span></span><br><span class="line">                            advance = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果是TreeBin，则按照红黑树进行处理，处理逻辑与上面一致</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; lo = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                            TreeNode&lt;K,V&gt; hi = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> e.hash;</span><br><span class="line">                                TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;</span><br><span class="line">                                        (h, e.key, e.val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                                        lo = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        loTail.next = p;</span><br><span class="line">                                    loTail = p;</span><br><span class="line">                                    ++lc;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                                        hi = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        hiTail.next = p;</span><br><span class="line">                                    hiTail = p;</span><br><span class="line">                                    ++hc;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 扩容后树节点个数若&lt;=6，将树转链表</span></span><br><span class="line">                            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                                    (hc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;</span><br><span class="line">                            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                                    (lc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;</span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="8-addCount-方法-计算size"><a href="#8-addCount-方法-计算size" class="headerlink" title="8. addCount() 方法 计算size"></a>8. addCount() 方法 计算size</h3><ul><li>ConcurrentHashMap的size方法是读取baseCount和CounterCell数据的总数量，因为是并发的也不一定正确；</li><li>此函数主要完成binCount的值加1的操作。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210516145437727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addCount</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> check)</span> &#123;</span><br><span class="line">    CounterCell[] as; <span class="type">long</span> b, s;</span><br><span class="line">    <span class="comment">//更新baseCount，table的数量，counterCells表示元素个数的变化</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="literal">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="built_in">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="type">long</span> v; <span class="type">int</span> m;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//如果多个线程都在执行，则CAS失败，执行fullAddCount，全部加入count</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//check&gt;=0表示需要进行扩容操作</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="type">int</span> n, sc;</span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前线程发起库哦哦让操作，nextTable=null</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="literal">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="9-putVal-流程总结"><a href="#9-putVal-流程总结" class="headerlink" title="9. putVal() 流程总结"></a>9. putVal() 流程总结</h3><ul><li><p>① 判断存储的key、value是否为空，若为空，则抛出异常，否则，进入步骤②</p></li><li><p>② 计算key的hash值，随后进入无限循环，该无限循环可以确保成功插入数据，若table表为空或者长度为0，则初始化table表，否则，进入步骤③</p></li><li><p>③ 根据key的hash值取出table表中的结点元素，若取出的结点为空（该桶为空），则使用CAS将key、value、hash值生成的结点放入桶中。否则，进入步骤④</p></li><li><p>④ 若该结点的的hash值为MOVED，则对该桶中的结点进行转移，否则，进入步骤⑤</p></li><li><p>⑤ 对桶中的第一个结点（即table表中的结点）进行加锁，对该桶进行遍历，桶中的结点的hash值与key值与给定的hash值和key值相等，则根据标识选择是否进行更新操作（用给定的value值替换该结点的value值），若遍历完桶仍没有找到hash值与key值和指定的hash值与key值相等的结点，则直接新生一个结点并赋值为之前最后一个结点的下一个结点。进入步骤⑥</p></li><li><p>⑥ 若binCount值达到红黑树转化的阈值，则将桶中的结构转化为红黑树存储，最后，增加binCount的值。</p></li></ul><h2 id="⑧-ConcurrentHashMap的get-操作"><a href="#⑧-ConcurrentHashMap的get-操作" class="headerlink" title="⑧. ConcurrentHashMap的get()操作"></a>⑧. ConcurrentHashMap的get()操作</h2><ul><li>get函数根据key的hash值来计算在哪个桶中，再遍历桶，查找元素，若找到则返回该结点，否则，返回null。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210516150024421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*get支持并发操作，</span></span><br><span class="line"><span class="comment">    * 当key为null的时候回抛出NullPointerException的异常</span></span><br><span class="line"><span class="comment">    * get操作通过首先计算key的hash值来确定该元素放在数组的哪个位置</span></span><br><span class="line"><span class="comment">    * 然后遍历该位置的所有节点</span></span><br><span class="line"><span class="comment">    * 如果不存在的话返回null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//获取值get(key)</span></span><br><span class="line">   <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">       <span class="comment">//两次hash计算出hash值</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">       <span class="comment">//通过首先计算key的hash值来确定该元素放在tab[i]数组的哪个位置</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">           (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">//检查头结点 key相等hash值相等 直接返回</span></span><br><span class="line">           <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">               <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                   <span class="keyword">return</span> e.val;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//table[i]为一颗树</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">           <span class="comment">////链表,遍历寻找即可</span></span><br><span class="line">           <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                   ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                   <span class="keyword">return</span> e.val;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果不存在的话返回null</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="二-ConcurrentHashMap常见问题"><a href="#二-ConcurrentHashMap常见问题" class="headerlink" title="二. ConcurrentHashMap常见问题"></a>二. ConcurrentHashMap常见问题</h1><blockquote><p><font color='red'>ConcurrentHashMap迭代器是强一致性还是弱一致性？HashMap呢？</p></blockquote><ul><li><p>弱一致性，hashmap强一直性。</p></li><li><p>ConcurrentHashMap可以支持在迭代过程中，向map添加新元素，而HashMap则抛出了ConcurrentModificationException，</p></li><li><p>ConcurrentHashMap的弱一致性主要表现在他的一些视图和迭代器上，通过迭代器遍历元素的时候如果之前的元素发生修改是不会抛出fail-fast异常的，后面的元素如果修改了会体现在迭代器遍历的结果上。</p></li><li><p>因为HashMap包含一个修改计数器，当你调用他的next()方法来获取下一个元素时，迭代器将会用到这个计数器。</p></li></ul><blockquote><p><font color='red'> ConcurrentHashMap1.7和1.8的区别：</p></blockquote><ul><li><p>JDK1.8的实现降低锁的粒度，JDK1.7锁的粒度是基于Segment的，包含多个HashEntry，而JDK1.8锁的粒度就是Node</p></li><li><p>数据结构：JDK1.7 Segment+HashEntry；JDK1.8 数组+链表+红黑树+CAS+synchronized</p></li></ul><h1 id="三-图解扩容流程"><a href="#三-图解扩容流程" class="headerlink" title="三. 图解扩容流程"></a>三. 图解扩容流程</h1>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis-AOF</title>
      <link href="/2021/09/01/Redis%E6%8C%81%E4%B9%85%E5%8C%96-AOF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2021/09/01/Redis%E6%8C%81%E4%B9%85%E5%8C%96-AOF%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="一-AOF简介"><a href="#一-AOF简介" class="headerlink" title="一. AOF简介"></a>一. AOF简介</h1><ul><li>与内存快照保存当前内存中的数据所不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。即每执行一个命令，就会把该命令写到日志文件里。</li></ul><h1 id="二-AOF-配置"><a href="#二-AOF-配置" class="headerlink" title="二. AOF 配置"></a>二. AOF 配置</h1><h2 id="①-appendonly：默认值为no"><a href="#①-appendonly：默认值为no" class="headerlink" title="①. appendonly：默认值为no"></a>①. appendonly：默认值为no</h2><ul><li>也就是说redis 默认使用的是rdb方式持久化，如果想要开启 AOF 持久化方式，需要将 appendonly 修改为 yes。</li></ul><h2 id="②-appendfilename-：aof文件名"><a href="#②-appendfilename-：aof文件名" class="headerlink" title="②. appendfilename ：aof文件名"></a>②. appendfilename ：aof文件名</h2><ul><li>默认是”appendonly.aof”</li></ul><h2 id="③、appendfsync：aof持久化策略的配置"><a href="#③、appendfsync：aof持久化策略的配置" class="headerlink" title="③、appendfsync：aof持久化策略的配置"></a>③、appendfsync：aof持久化策略的配置</h2><ul><li><p><strong>no</strong> 表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快，但是不太安全；</p></li><li><p><strong>always</strong> 表示每次写入都执行fsync，以保证数据同步到磁盘，效率很低；</p></li><li><p><strong>everysec</strong> 表示每秒执行一次fsync，可能会导致丢失这1s数据。通常选择 everysec ，兼顾安全性和效率。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210709081426460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="④、no-appendfsync-on-rewrite：默认值为no。"><a href="#④、no-appendfsync-on-rewrite：默认值为no。" class="headerlink" title="④、no-appendfsync-on-rewrite：默认值为no。"></a>④、no-appendfsync-on-rewrite：默认值为no。</h2><ul><li>在aof重写或者写入rdb文件的时候，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync会造成阻塞过长时间，no-appendfsync-on-rewrite字段设置为默认设置为no。如果对延迟要求很高的应用，这个字段可以设置为yes，否则还是设置为no，这样对持久化特性来说这是更安全的选择。   设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yes。Linux的默认fsync策略是30秒。可能丢失30秒数据。</li></ul><h2 id="⑤、auto-aof-rewrite-percentage：默认值为100。"><a href="#⑤、auto-aof-rewrite-percentage：默认值为100。" class="headerlink" title="⑤、auto-aof-rewrite-percentage：默认值为100。"></a>⑤、auto-aof-rewrite-percentage：默认值为100。</h2><ul><li>aof自动重写配置，当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候，Redis能够调用bgrewriteaof对日志文件进行重写。当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程。</li></ul><h2 id="⑥、auto-aof-rewrite-min-size：64mb。"><a href="#⑥、auto-aof-rewrite-min-size：64mb。" class="headerlink" title="⑥、auto-aof-rewrite-min-size：64mb。"></a>⑥、auto-aof-rewrite-min-size：64mb。</h2><ul><li>设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写。</li></ul><h2 id="⑦、aof-load-truncated：默认值为-yes。"><a href="#⑦、aof-load-truncated：默认值为-yes。" class="headerlink" title="⑦、aof-load-truncated：默认值为 yes。"></a>⑦、aof-load-truncated：默认值为 yes。</h2><ul><li>aof文件可能在尾部是不完整的，当redis启动的时候，aof文件的数据被载入内存。重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data&#x3D;ordered选项，出现这种现象  redis宕机或者异常终止不会造成尾部不完整现象，可以选择让redis退出，或者导入尽可能多的数据。如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复AOF文件才可以。</li></ul><h1 id="三-AOF执行后写日志"><a href="#三-AOF执行后写日志" class="headerlink" title="三. AOF执行后写日志"></a>三. AOF执行后写日志</h1><p><img src="https://img-blog.csdnimg.cn/20210709081024340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>这样做的好处就是不会阻塞当前操作，也可以避免额外的检查开销，如果是在命令执行前进行写日志的操作，一旦命令语法是错误的，不进行检查的话就会导致写入到日志文件中的命令是错误的，在使用日志文件恢复数据的时候就会出错。而在命令执行后在进行日志的写入则不会有这个问题。</p></li><li><p>但是也存在两个问题，</p><ul><li><p>AOF 虽然避免了对当前命令的阻塞，但却可能会给下一个操作带来阻塞风险。因为，AOF 日志是在主进程中执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了</p></li><li><p>如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。如果此时 Redis 是用作缓存，还可以从后端数据库重新读入数据进行恢复，但是，如果 Redis 是直接用作数据库的话，此时，因为命令没有记入日志，所以就无法用日志进行恢复了。</p></li></ul></li></ul><h1 id="四-AOF-缓冲区"><a href="#四-AOF-缓冲区" class="headerlink" title="四. AOF 缓冲区"></a>四. AOF 缓冲区</h1><ul><li>Redis在执行完命令进行持久化的时候，并非直接写入磁盘日志文件，而是先写入AOF缓冲区内，之后再通过某种策略写到磁盘。</li></ul><p><img src="https://img-blog.csdnimg.cn/2021070908124280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="五-AOF-重写"><a href="#五-AOF-重写" class="headerlink" title="五.  AOF 重写"></a>五.  AOF 重写</h1><ul><li>由于AOF持久化是Redis不断将写命令记录到 AOF 文件中，随着Redis不断的进行，AOF 的文件会越来越大，文件越大，占用服务器内存越大以及 AOF 恢复要求时间越长。为了解决这个问题，Redis新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。可以使用命令 bgrewriteaof 来重写。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210709081625773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>如果不进行 AOF 文件重写，那么 AOF 文件将保存四条 SADD 命令，如果使用AOF 重写，那么AOF 文件中将只会保留下面一条命令：sadd animals “dog “ “tiger “ “panda “ “lion “ “cat “。</p></li><li><p><strong>也就是说 AOF 文件重写并不是对原文件进行重新整理，而是直接读取服务器现有的键值对，然后用一条命令去代替之前记录这个键值对的多条命令，生成一个新的文件后去替换原来的 AOF 文件。</strong></p></li><li><p>AOF 文件重写触发机制：通过 redis.conf 配置文件中的 auto-aof-rewrite-percentage：默认值为100，以及auto-aof-rewrite-min-size：64mb 配置，也就是说默认Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。</p></li><li><p>我们知道 Redis 是单线程工作，如果 重写 AOF 需要比较长的时间，那么在重写 AOF 期间，Redis将长时间无法处理其他的命令，这显然是不能忍受的。Redis为了克服这个问题，解决办法是将 AOF 重写程序放到子程序中进行，这样有两个好处：</p><ul><li>①、子进程进行 AOF 重写期间，服务器进程（父进程）可以继续处理其他命令。</li><li>②、子进程带有父进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</li></ul></li><li><p>为了解决这个数据状态不一致的问题，Redis 服务器设置了一个 <strong>AOF 重写缓冲区</strong>，这个缓冲区是在创建子进程后开始使用，当Redis服务器执行一个写命令之后，就会将这个写命令也发送到 AOF 重写缓冲区。当子进程完成 AOF 重写之后，就会给父进程发送一个信号，父进程接收此信号后，就会调用函数将 AOF 重写缓冲区的内容都写到新的 AOF 文件中。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210709082056784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>在子进程执行AOF重写期间。服务器进程需要执行以下3个动作：</p><ul><li>执行客户端命令</li><li>执行后追加到AOF缓冲区</li><li>执行后追加到AOF重写缓冲区</li></ul></li><li><p>子进程完成AOF重写后，它向父进程发送一个信号，父进程收到信号后会调用一个信号处理函数，该函数把AOF重写缓冲区的命令追加到新AOF文件中然后替换掉现有AOF文件。父进程处理完毕后可以继续接受客户端命令调用，可以看出在AOF后台重写过程中只有这个信号处理函数会阻塞服务器进程。</p></li></ul><h1 id="六-AOF文件恢复"><a href="#六-AOF文件恢复" class="headerlink" title="六. AOF文件恢复"></a>六. AOF文件恢复</h1><ul><li><p>在Redis 服务器重启后，会优先去载入AOF日志文件。因为AOF文件里面包含了重建数据库状态所需的所有写命令,所以服务器重新执行一遍AOF文件里面保存的写命令,就可以还原服务器关闭之前的数据库状态。</p></li><li><p>而由于Redis命令只能在客户端上下文中执行，Redis会创建一个没有网络连接的伪客户端来执行AOF文件中的内容。</p></li></ul><h1 id="七-AOF的优缺点"><a href="#七-AOF的优缺点" class="headerlink" title="七. AOF的优缺点"></a>七. AOF的优缺点</h1><blockquote><p><font color='red' size=4>优点：</p></blockquote><ul><li><p>①、AOF 持久化的方法提供了多种的同步频率，即使使用默认的同步频率每秒同步一次，Redis 最多也就丢失 1 秒的数据而已。</p></li><li><p>②、AOF 文件使用 Redis 命令追加的形式来构造，因此，即使 Redis 只能向 AOF 文件写入命令的片断，使用 redis-check-aof 工具也很容易修正 AOF 文件。</p></li><li><p>③、AOF 文件的格式可读性较强，这也为使用者提供了更灵活的处理方式。例如，如果我们不小心错用了 FLUSHALL 命令，在重写还没进行时，我们可以手工将最后的 FLUSHALL 命令去掉，然后再使用 AOF 来恢复数据。</p></li></ul><blockquote><p><font color='red' size=4>缺点：</p></blockquote><ul><li><p>①、对于具有相同数据的的 Redis，AOF 文件通常会比 RDB文件体积更大。</p></li><li><p>②、虽然 AOF 提供了多种同步的频率，默认情况下，每秒同步一次的频率也具有较高的性能。但在 Redis 的负载较高时，RDB 比 AOF 具好更好的性能保证。</p></li><li><p>③、RDB 使用快照的形式来持久化整个 Redis 数据，而 AOF 只是将每次执行的命令追加到 AOF 文件中，因此从理论上说，RDB 比 AOF 方式更健壮。官方文档也指出，AOF 的确也存在一些 BUG，这些 BUG 在 RDB 没有存在。</p></li></ul><blockquote><p><font color='red' size=4>那么对于 AOF 和 RDB 两种持久化方式，我们应该如何选择呢？</p></blockquote><ul><li>如果可以忍受一小段时间内数据的丢失，毫无疑问使用 RDB 是最好的，定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，而且使用 RDB 还可以避免 AOF 一些隐藏的 bug；否则就使用 AOF 重写。但是一般情况下建议不要单独使用某一种持久化机制，而是应该两种一起用，在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。Redis后期官方可能都有将两种持久化方式整合为一种持久化模型。</li></ul><h1 id="八-RDB-AOF混合持久化"><a href="#八-RDB-AOF混合持久化" class="headerlink" title="八. RDB-AOF混合持久化"></a>八. RDB-AOF混合持久化</h1><ul><li><p>在Redis4.0之后，新增了RDB-AOF混合持久化方式。这种方式结合了RDB和AOF的优点，既能快速加载又能避免丢失过多的数据。</p></li><li><p>具体配置为：aof-use-rdb-preamble: 设置为yes表示开启，设置为no表示禁用。</p></li><li><p>当开启混合持久化时，主进程先fork出子进程将现有内存副本全量以RDB方式写入aof文件中，然后将缓冲区中的增量命令以AOF方式写入aof文件中，写入完成后通知主进程更新相关信息，并将新的含有 RDB和AOF两种格式的aof文件替换旧的aof文件。</p></li><li><p>简单来说：混合持久化方式产生的文件一部分是RDB格式，一部分是AOF格式。</p></li><li><p>这种方式优点我们很好理解，缺点就是不能兼容Redis4.0之前版本的备份文件了</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis-RDB</title>
      <link href="/2021/09/01/Redis%E6%8C%81%E4%B9%85%E5%8C%96-RDB%20%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2021/09/01/Redis%E6%8C%81%E4%B9%85%E5%8C%96-RDB%20%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="一-RDB-简介"><a href="#一-RDB-简介" class="headerlink" title="一. RDB 简介"></a>一. RDB 简介</h1><ul><li>RDB是Redis用来进行持久化的一种方式，是把当前内存中的数据集快照写入磁盘，也就是 Snapshot 快照（数据库中所有键值对数据）。恢复时是将快照文件直接读到内存里。</li></ul><h1 id="二-触发方式"><a href="#二-触发方式" class="headerlink" title="二. 触发方式"></a>二. 触发方式</h1><h2 id="①-自动触发"><a href="#①-自动触发" class="headerlink" title="①. 自动触发"></a>①. 自动触发</h2><p><img src="https://img-blog.csdnimg.cn/20210707230116598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="1-save"><a href="#1-save" class="headerlink" title="1. save"></a>1. save</h3><ul><li><p>这里是用来配置触发 Redis的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave（这个命令下面会介绍，手动触发RDB持久化的命令）</p></li><li><p>默认如下配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span>：表示<span class="number">900</span> 秒内如果至少有 <span class="number">1</span> 个 key 的值变化，则保存</span><br><span class="line">save <span class="number">300</span> <span class="number">10</span>：表示<span class="number">300</span> 秒内如果至少有 <span class="number">10</span> 个 key 的值变化，则保存</span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span>：表示<span class="number">60</span> 秒内如果至少有 <span class="number">10000</span> 个 key 的值变化，则保存</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-stop-writes-on-bgsave-error"><a href="#2-stop-writes-on-bgsave-error" class="headerlink" title="2. stop-writes-on-bgsave-error"></a>2. stop-writes-on-bgsave-error</h3><ul><li>默认值为yes。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了</li></ul><h3 id="3-rdbcompression"><a href="#3-rdbcompression" class="headerlink" title="3. rdbcompression"></a>3. rdbcompression</h3><ul><li>默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能，但是存储在磁盘上的快照会比较大。</li></ul><h3 id="4-rdbchecksum"><a href="#4-rdbchecksum" class="headerlink" title="4. rdbchecksum"></a>4. rdbchecksum</h3><ul><li>默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</li></ul><h3 id="5-dbfilename"><a href="#5-dbfilename" class="headerlink" title="5. dbfilename"></a>5. dbfilename</h3><ul><li>设置快照的文件名，默认是 dump.rdb</li></ul><h3 id="6-dir"><a href="#6-dir" class="headerlink" title="6. dir"></a>6. dir</h3><ul><li>设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。默认是和当前配置文件保存在同一目录。</li></ul><p>　　也就是说通过在配置文件中配置的 save 方式，当实际操作满足该配置形式时就会进行 RDB 持久化，将当前的内存快照保存在 dir 配置的目录中，文件名由配置的 dbfilename 决定。</p><h2 id="②-手动触发"><a href="#②-手动触发" class="headerlink" title="②. 手动触发"></a>②. 手动触发</h2><ul><li>手动触发Redis进行RDB持久化的命令有两种：</li></ul><h3 id="1-save-1"><a href="#1-save-1" class="headerlink" title="1. save"></a>1. save</h3><ul><li><p>该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。</p></li><li><p>显然该命令对于内存比较大的实例会造成长时间阻塞，这是致命的缺陷，为了解决此问题，Redis提供了第二种方式。</p></li></ul><h3 id="2-bgsave"><a href="#2-bgsave" class="headerlink" title="2. bgsave"></a>2. bgsave</h3><ul><li>bgsave命令会派生出一个子进程(而不是线程)，由子进程进行RDB文件创建，而父进程继续处理命令。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210707230621955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>基本上 Redis 内部所有的RDB操作都是采用 bgsave 命令。</li></ul><h1 id="三-RDB文件的载入"><a href="#三-RDB文件的载入" class="headerlink" title="三. RDB文件的载入"></a>三. RDB文件的载入</h1><ul><li><p>在Redis启动的时候，只要检测到RDB文件的存在，就会自动加载RDB文件。需要注意的是</p><ul><li><p>因为AOF文件的更新频率通常比RDB文件的更新频率高,所以口如果服务器开启了AOF持久化功能,那么服务器会优先使用AOF文件来还原数据库状态。</p></li><li><p>只有在AOF持久化功能处于关闭状态时,服务器才会使用RDB文件来还原数据库状态。</p></li></ul></li><li><p>Redis 服务器在载入 RDB 文件期间，会一直处于阻塞状态，直到载入工作完成为止。</p></li></ul><h1 id="四-停止-RDB-持久化"><a href="#四-停止-RDB-持久化" class="headerlink" title="四. 停止 RDB 持久化"></a>四. 停止 RDB 持久化</h1><ul><li><p>有些情况下，我们只想利用Redis的缓存功能，并不像使用 Redis 的持久化功能，那么这时候我们最好停掉 RDB 持久化。可以通过上面讲的在配置文件 redis.conf 中，可以注释掉所有的 save 行来停用保存功能或者直接一个空字符串来实现停用：<strong>save “ “</strong></p></li><li><p>也可以通过命令： <strong>redis-cli config set save “ “</strong></p></li></ul><h1 id="五-RDB-自动保存的原理"><a href="#五-RDB-自动保存的原理" class="headerlink" title="五. RDB 自动保存的原理"></a>五. RDB 自动保存的原理</h1><ul><li>Redis有个服务器状态结构：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisService</span>&#123;</span></span><br><span class="line">     <span class="comment">//1、记录保存save条件的数组</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparams</span>;</span></span><br><span class="line">     <span class="comment">//2、修改计数器</span></span><br><span class="line">     <span class="type">long</span> <span class="type">long</span> dirty;</span><br><span class="line">     <span class="comment">//3、上一次执行保存的时间</span></span><br><span class="line">     <span class="type">time_t</span> lastsave;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="①-数组-saveparam"><a href="#①-数组-saveparam" class="headerlink" title="①. 数组 saveparam"></a>①. 数组 saveparam</h2><ul><li>记录保存save条件的数组 saveparam，里面每个元素都是一个 saveparams 结构：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span>&#123;</span></span><br><span class="line">     <span class="comment">//秒数</span></span><br><span class="line">     <span class="type">time_t</span> seconds;</span><br><span class="line">     <span class="comment">//修改数</span></span><br><span class="line">     <span class="type">int</span> changes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>前面我们在 redis.conf 配置文件中进行了关于save 的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span>：表示<span class="number">900</span> 秒内如果至少有 <span class="number">1</span> 个 key 的值变化，则保存</span><br><span class="line">save <span class="number">300</span> <span class="number">10</span>：表示<span class="number">300</span> 秒内如果至少有 <span class="number">10</span> 个 key 的值变化，则保存</span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span>：表示<span class="number">60</span> 秒内如果至少有 <span class="number">10000</span> 个 key 的值变化，则保存</span><br></pre></td></tr></table></figure></li><li><p>那么服务器状态中的saveparam 数组将会是如下的样子：<br><img src="https://img-blog.csdnimg.cn/20210707232052810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><h2 id="②-dirty-计数器和lastsave-属性"><a href="#②-dirty-计数器和lastsave-属性" class="headerlink" title="②. dirty 计数器和lastsave 属性"></a>②. dirty 计数器和lastsave 属性</h2><ul><li><p>dirty 计数器记录距离上一次成功执行 save 命令或者 bgsave 命令之后，Redis服务器进行了多少次修改（包括写入、删除、更新等操作）。</p></li><li><p>lastsave 属性是一个时间戳，记录上一次成功执行 save 命令或者 bgsave 命令的时间。</p></li><li><p>通过这两个命令，当服务器成功执行一次修改操作，那么dirty 计数器就会加 1，而lastsave 属性记录上一次执行save或bgsave的时间，Redis 服务器还有一个周期性操作函数 severCron ,默认每隔 100 毫秒就会执行一次，该函数会遍历并检查 saveparams 数组中的所有保存条件，只要有一个条件被满足，那么就会执行 bgsave 命令。</p></li><li><p>执行完成之后，dirty 计数器更新为 0 ，lastsave 也更新为执行命令的完成时间。</p></li></ul><h1 id="六-内存快照的问题"><a href="#六-内存快照的问题" class="headerlink" title="六. 内存快照的问题"></a>六. 内存快照的问题</h1><h2 id="①-快照的时候数据可以修改吗"><a href="#①-快照的时候数据可以修改吗" class="headerlink" title="①. 快照的时候数据可以修改吗?"></a>①. 快照的时候数据可以修改吗?</h2><ul><li>比如在t时刻,我们对内存进行快照，此时我们希望的是记录下来t时刻内存中所有的数据，假设我们的RDB操作需要10s的时间，而t+2s我们执行了一个修改操作把Key1的值由A修改成了B，而此时RDB操作却还没有把Key1的值写入磁盘。在t+5s的时候读取到key1的值写入磁盘。那么此次快照记录的Key1的值就是B，而不是t时刻的A。这样就破坏了RDB文件的正确性。</li></ul><blockquote><p><font color='red' size> Redis解决方案</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210707233010402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>Redis 借助了操作系统提供的<strong>写时复制技术（Copy-On-Write</strong>, COW），可以让在执行快照的同时，正常处理写操作。</li><li>简单来说，bgsave fork子进程的时候，并不会完全复制主进程的内存数据，而是只复制必要的虚拟数据结构，并不为其分配真实的物理空间，它与父进程共享同一个物理内存空间。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。</li><li>此时，如果主线程对这些数据也都是读操作，那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据，此时会给子进程分配一块物理内存空间，把要修改的数据复制一份，生成该数据的副本到子进程的物理内存空间。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。</li></ul><h2 id="②-可以频繁进行快照操作吗"><a href="#②-可以频繁进行快照操作吗" class="headerlink" title="②. 可以频繁进行快照操作吗?"></a>②. 可以频繁进行快照操作吗?</h2><ul><li>一方面，持久化是一个写入磁盘的过程，频繁将全量数据写入磁盘，会给磁盘带来很大压力，频繁执行快照也容易导致前一个快照还没有执行完，后一个又开始了，这样多个快照竞争有限的磁盘带宽，容易造成恶性循环。</li></ul><ol><li><p>增量快照要求记住哪些数据上一次快照之后产生的。这就需要额外的元数据来记录这些信息，会引入额外的空间消耗。这对于内存资源宝贵的 Redis 来说，并不是一个很好的方案。</p></li><li><p>Redis 还提供了另外一种持久化方式——AOF(append to file)日志。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>G1垃圾回收器</title>
      <link href="/2021/08/29/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
      <url>/2021/08/29/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一-G1垃圾回收器介绍"><a href="#一-G1垃圾回收器介绍" class="headerlink" title="一. G1垃圾回收器介绍"></a>一. G1垃圾回收器介绍</h1><ul><li>Garbage First 简称 G1，是继 CMS 垃圾回收器之后，又一款并发的垃圾回收器。</li><li>在 JDK7 中被去掉 Experimental 标识，开始可以被正式使用</li><li>在 JDK9 中被 JVM 设置为默认的垃圾回收器。G1 是垃圾收集器发展史上的一个新的里程碑</li><li>它采用分区算法，基于 Region 的内存布局方式，对整个堆内存进行局部回收，既能回收新生代，也能回收老年代。</li><li>G1 垃圾回收器的目标是在期望的停顿时间内，尽可能地提高系统的吞吐量。</li></ul><h1 id="二-G1的使用"><a href="#二-G1的使用" class="headerlink" title="二. G1的使用"></a>二. G1的使用</h1><blockquote><p><font color='red' size=3;>-XX:+UseG1GC  -Xmx32g    -XX:MaxGCPauseMillis&#x3D;200</p></blockquote><ol><li>-XX:+UseG1GC为开启G1垃圾收集器</li><li>-Xmx32g 设计堆内存的最大内存为32G</li><li>-XX:MaxGCPauseMillis&#x3D;200设置GC的最大暂停时间为200ms。</li></ol><h1 id="三-G1的特点"><a href="#三-G1的特点" class="headerlink" title="三. G1的特点"></a>三. G1的特点</h1><h2 id="①-Region-分区产生"><a href="#①-Region-分区产生" class="headerlink" title="①. Region 分区产生"></a>①. Region 分区产生</h2><ul><li>G1将新生代，老年代的物理空间划分取消了，取而代之的是，G1算法将堆划分为若干个区域（Region），它仍然属于分代收集器。</li><li>虽然 G1 仍然遵循分代收集理论，但是 G1 不再坚持固定大小、固定数量的分代区域划分，而是将整个内存区域划分为若干个大小相等的独立小区域（Region），每个 Region 都能扮演 Eden、Survivor、Old 区。新生代和老年代的内存在物理上不再是连续的，而是逻辑上处于连续。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210427125826696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="③-对象分配策略"><a href="#③-对象分配策略" class="headerlink" title="③. 对象分配策略"></a>③. 对象分配策略</h2><pre><code>  1. TLAB(Thread Local Allocation Buffer)线程本地分配缓冲区  2. Eden区中分配  3. Humongous区分配</code></pre><blockquote><p><font color='red' size=3;>TLAB-(Thread Local Allocation Buffer, 线程本地分配缓存)</p></blockquote><ul><li>TLAB: TLAB是一个线程专用的内存分配区域, 虚拟机为线程分配空间, 针对于体积不大的对象, 会优先使用TLAB, 这个可以加速对象的分配, TLAB是默认开启的。</li><li>在Eden空间中，每一个线程都有一个固定的分区用于分配对象，即一个TLAB。分配对象时，线程之间不再需要进行任何的同步。</li><li>对TLAB空间中无法分配的对象，JVM会尝试在Eden空间中进行分配。如果Eden空间无法容纳该对象，就只能在老年代中进行分配空间。</li></ul><h2 id="④-Humongous巨型对象产生"><a href="#④-Humongous巨型对象产生" class="headerlink" title="④. Humongous巨型对象产生"></a>④. Humongous巨型对象产生</h2><ul><li><p>在 G1 中，新增了一个 H(Humongous) 区的概念，如果一个对象的大小超过了一个 Region 的 50%，那么该对象就会被直接存放进 H 区。如果一个 Region 无法存放下对象，那么就会采用连续的多个 Region 来存放该超大对象。</p></li><li><p>每个 Region 的大小可以通过参数 「-XX:G1HeapRegionSize」 设置，取值范围为 1MB~32MB，且为 2 的整数次幂。通常情况下，G1 会将堆内存划分为 2048 个 Region，如果我们指定堆内存的大小为 4G ，那么每个 Region 的大小为 2MB。</p></li></ul><h2 id="⑤-并发执行"><a href="#⑤-并发执行" class="headerlink" title="⑤. 并发执行"></a>⑤. 并发执行</h2><ul><li>在并发标记阶段，G1 的垃圾回收线程和用户线程，是并发执行的，那么 G1 是如何保证垃圾回收线程与用户线程互不干扰的呢？在 CMS 中，采用的是增量收集算法，而在 G1 中采用的原始快照算法（SATB）。</li></ul><h2 id="⑥-执行的流程"><a href="#⑥-执行的流程" class="headerlink" title="⑥. 执行的流程"></a>⑥. 执行的流程</h2><p><img src="https://img-blog.csdnimg.cn/20210427114847592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="1-初始标记-stop-the-word"><a href="#1-初始标记-stop-the-word" class="headerlink" title="1. 初始标记 (stop the word)"></a>1. 初始标记 (stop the word)</h3><ul><li>仅仅只是标记出 GC Roots 直接关联的对象（此时当前 Region 中的记忆集也会被当做是 GC Roots），并且还会修改 TAMS 指针，让下一阶段用户线程并发执行时，能够正确的在可用的 Region 中分配新对象。这一步会造成 STW，但是由于只标记和 GC Roots 直接相连的对象，所以暂停时间很短，具体暂停多长时间，和 GC Roots 的数量有关。另外由于该阶段是借用进行 Minor GC 时同步完成的，因此不会额外造成停顿。</li></ul><h3 id="2-并发标记"><a href="#2-并发标记" class="headerlink" title="2. 并发标记"></a>2. 并发标记</h3><ul><li>从上一步标记出的对象出发，遍历整个对象图，这一步耗时较长，但是由于是和用户线程并发执行，因此不会造成 STW。</li></ul><h3 id="3-最终标记-stop-the-word"><a href="#3-最终标记-stop-the-word" class="headerlink" title="3. 最终标记 (stop the word)"></a>3. 最终标记 (stop the word)</h3><ul><li>由于在并发标记阶段，垃圾回收线程和用户线程并发执行，因此在这一过程中，可能会由于用户线程改变了对象的引用关系，造成对象”消失“，因此还需要重新处理 SATB（原始快照）记录下在并发阶段有引用关系改动的对象，这一过程就是在最终标记阶段完成的，会造成 STW，否则如果用户线程还一直进行，就会不停地造成对象引用关系的改变，我们就得不停的处理 SATB 记录。虽然会造成 STW，但毕竟 SATB 记录的引用改变的对象不会特别多，因此耗时比并发标记阶段的耗时会少很多。在这一步中，如果发现当前 Region 中的所有对象都是垃圾对象，那么就会立即对当前 Region 进行回收</li></ul><h3 id="4-筛选回收-stop-the-word"><a href="#4-筛选回收-stop-the-word" class="headerlink" title="4. 筛选回收 (stop the word)"></a>4. 筛选回收 (stop the word)</h3><ul><li>负责更新 Region 的统计数据，根据每个 Region 的回收价值和成本进行排序，然后根据用户期望停顿的时间内来指定回收计划，可以选择多个 Region 构成回收集，然后采用复制算法，将 Region 中存活的对象复制到空闲的 Region 中，从而回收 Region。</li></ul><blockquote><p><font color='red' size=3;>G1 垃圾回收的 4 个阶段，只有并发标记阶段不会造成 STW，其他阶段都会产生 STW</p></blockquote><h1 id="四-三色标记算法"><a href="#四-三色标记算法" class="headerlink" title="四. 三色标记算法"></a>四. 三色标记算法</h1><ul><li>它是描述追踪式回收器的一种有用的方法，利用它可以推演回收器的正确性</li></ul><h2 id="①-对象分成三种类型"><a href="#①-对象分成三种类型" class="headerlink" title="①. 对象分成三种类型"></a>①. 对象分成三种类型</h2><ul><li>黑色: 根对象，或者该对象与它的子对象都被扫描</li><li>灰色: 对象本身被扫描,但还没扫描完该对象中的子对象</li><li>白色: 未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象</li></ul><h2 id="②-执行的流程"><a href="#②-执行的流程" class="headerlink" title="②. 执行的流程"></a>②. 执行的流程</h2><blockquote><p><font color='red' size=3;>1. 根对象被置为黑色，子对象被置为灰色。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/2021042712102050.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=3;>2. 继续由灰色遍历,将已扫描了子对象的对象置为黑色。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210427121105952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=3;>3. 遍历了所有可达的对象后，所有可达的对象都变成了黑色。不可达的对象即为白色，需要被清理。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210427121146481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="③-对象丢失问题解决方式"><a href="#③-对象丢失问题解决方式" class="headerlink" title="③. 对象丢失问题解决方式"></a>③. 对象丢失问题解决方式</h2><p><img src="https://img-blog.csdnimg.cn/20210427125501706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210427125519793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=3;>对象消失理论，只有同时满足才会发生对象消失</p></blockquote><ol><li>赋值器插入了一条或多条从黑色对象到白色对象的新引用；</li><li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用；</li></ol><blockquote><p><font color='red' size=3;>CMS——增量更新(Incremental Update)</p></blockquote><ul><li>采用IncrementalUpdate（增量更新）算法，在并发标记阶段时如果一个白色对象被一个黑色对象引用时，会将黑色对象重新标记为灰色，让垃圾收集器在重新标记阶段重新扫描。</li></ul><blockquote><p><font color='red' size=3;>G1——起始快照算法_STAB（snapshot-at-the-beginning）</p></blockquote><ul><li>原始快照要破坏的是第二个条件，采用SATB(snapshot-at-the-beginning)，在初始标记时做一个快照，当B和C之间的引用消失时要把这个引用推到GC的堆栈，保证C还能被GC扫描到，在最终标记阶段扫描STAB记录。</li></ul><h1 id="五-新生代-YGC"><a href="#五-新生代-YGC" class="headerlink" title="五. 新生代 YGC"></a>五. 新生代 YGC</h1><blockquote><p><font color='red' size=3;> 什么时候触发新生代 GC</p></blockquote><ul><li><p>Young GC主要是对Eden区进行GC，它在Eden空间耗尽时会被触发。在这种情况下，Eden空间的数据移动到Survivor空间中，如果Survivor空间不够，Eden空间的部分数据会直接晋升到年老代空间。Survivor区的数据移动到新的Survivor区中，也有部分数据晋升到老年代空间中。最终Eden空间的数据为空，GC停止工作，应用线程继续执行。</p></li><li><p>在 G1 中，Eden、Survivor、老年代的大小是在动态变化的。在初始时，新生代占整个堆内存的 5%，可以通过参数「G1NewSizePercent」设置，默认值为 5。</p></li><li><p>在 G1 中，虽然进行了 Region 分区，但是新生代依旧可以被分为 Eden 区和 Survivor 区，参数 SurvivorRatio 依旧表示 Eden&#x2F;Survivor 的比值。</p></li><li><p>随着系统的运行，Eden 区的对象越来越多，当达到 Eden 区的最大大小时，就会触发 Minor GC。新生代的最大大小默认为整个堆内存的 60%，可以通过参数「G1MaxNewSizePercent」控制，默认值为 60。</p></li></ul><blockquote><p><font color='red' size=3;> Young GC的回收过程如下：</p></blockquote><ol><li><p>根扫描,跟CMS类似，Stop the world，扫描GC Roots对象。</p></li><li><p>处理Dirty card,更新RSet.</p></li><li><p>扫描RSet,扫描RSet中所有old区对扫描到的young区或者survivor去的引用。</p></li><li><p>拷贝扫描出的存活的对象到survivor2&#x2F;old区</p></li><li><p>处理引用队列，软引用，弱引用，虚引用</p></li></ol><h1 id="六-混合回收（Mixed-GC）"><a href="#六-混合回收（Mixed-GC）" class="headerlink" title="六. 混合回收（Mixed GC）"></a>六. 混合回收（Mixed GC）</h1><blockquote><p><font color='red' size=3;> 什么时候触发混合 GC</p></blockquote><ul><li><p>在 G1 中，不存在单独回收老年代的行为，而是当要发生老年代的回收时，同时也会对新生代以及大对象进行回收，因此这个阶段称之为混合回收（Mixed GC）。</p></li><li><p>当老年代对堆内存的占比达到 45%时，就会触发混合回收。可以通过参数「InitiatingHeapOccupancyPercent」来设置当堆内存达到多少时，触发混合 GC，该参数的默认值为 45。</p></li><li><p>当触发混合 GC 时，会依次执行初始标记（在 Minor GC 时完成）、并发标记、最终标记、筛选回收这四个过程。最终会根据设置的最大停顿时间，来计算对哪些 Region 区域进行回收带来的收益最大。</p></li><li><p>在混合回收的过程中，由于使用的是复制算法，因此当一个 Region 中存活的对象过多的话，复制这个 Region 所耗费的时间就会较多，因此 G1 提供了一个参数，用来控制当存活对象占当前 Region 的比例超过多少后，就不会对该 Region 进行回收。该参数为「G1MixedGCLiveThresholdPercent」，默认值为 85%。</p></li></ul><h1 id="七-触发-Full-GC"><a href="#七-触发-Full-GC" class="headerlink" title="七.  触发 Full GC"></a>七.  触发 Full GC</h1><ul><li>在进行混合回收时，使用的是复制算法，如果当发现空闲的 Region 大小无法放得下存活对象的内存大小，那么这个时候使用复制算法就会失败，因此此时系统就不得不暂停应用程序，进行一次 Full GC。进行 Full GC 时采用的是单线程进行标记、清理和整理内存，这个过程是非常漫长的，因此应该尽量避免 Full GC 的触发。</li></ul><h1 id="八-G1的优缺点"><a href="#八-G1的优缺点" class="headerlink" title="八. G1的优缺点"></a>八. G1的优缺点</h1><blockquote><p><font color='red' size=3;>优点</p></blockquote><ul><li>G1 中可以指定最大停顿时间、对内存进行 Region 分区、按照收益动态进行垃圾回收。</li><li>使用分区算法, 不要求eden, 年轻代或老年代的空间都连续 </li><li>空间整理: 回收过程中, 会进行适当对象移动, 减少空间碎片 。</li><li>可预见性: G1可选取部分区域进行回收, 可以缩小回收范围, 减少全局停顿 </li><li>并行性: 回收期间, 可由多个线程同时工作, 有效利用多核cpu资源 </li><li>并发性: 与应用程序可交替执行, 部分工作可以和应用程序同时执行</li><li>CMS 则是采用的是标记-清除算法，会带来内存碎片，当连续内存不足以分配一个对象时，会产生 Full GC。</li></ul><blockquote><p><font color='red' size=3;>缺点</p></blockquote><ul><li>G1 的内存占用相对而言，比较大。</li><li>G1 对系统造成的负载较高</li></ul><blockquote><p><font color='red' size=3;>G1 并不能在任何场景下取代 CMS，「G1 更适合在大内存的机器中使用，CMS 更适合在小内存机器中使用</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMS垃圾回收器</title>
      <link href="/2021/08/19/CMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
      <url>/2021/08/19/CMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一-CMS介绍"><a href="#一-CMS介绍" class="headerlink" title="一. CMS介绍"></a>一. CMS介绍</h1><ol><li>JDK9 中，CMS 被标记为「Deprecated」，开始逐渐的淡出人们的视野，在目前最新的 JDK14 中，CMS 则是完全被移除了，成为了第一款被彻底遗弃的垃圾回收器。</li><li>CMS(Concurrent Mark-Sweep)是以牺牲吞吐量为代价来获得<strong>最短回收停顿时间</strong>的垃圾回收器。</li><li>在启动JVM参数加上-XX:+UseConcMarkSweepGC ，这个参数表示对于<strong>老年代</strong>的回收采用CMS。</li><li>CMS采用的基础算法是：标记—清除。</li></ol><h1 id="二-实现机制"><a href="#二-实现机制" class="headerlink" title="二. 实现机制"></a>二. 实现机制</h1><ul><li>根据GC的触发机制分为：周期性Old GC（被动）和主动Old GC</li></ul><h1 id="三-周期性Old-GC-CMS执行过程"><a href="#三-周期性Old-GC-CMS执行过程" class="headerlink" title="三. 周期性Old GC_CMS执行过程"></a>三. 周期性Old GC_CMS执行过程</h1><ul><li>周期性Old GC，执行的逻辑也叫Background Collect，对老年代进行回收，在GC日志中比较常见，由后台线程ConcurrentMarkSweepThread循环判断（默认2s）是否需要触发。</li></ul><blockquote><p><font color='red' size=3> 触发的条件</p></blockquote><ol><li>如果没有设置-XX:+UseCMSInitiatingOccupancyOnly，虚拟机会根据收集的数据决定是否触发。</li><li>老年代使用率达到阈值 CMSInitiatingOccupancyFraction，默认92%。</li><li>永久代的使用率达到阈值 CMSInitiatingPermOccupancyFraction，默认92%，前提是开启 CMSClassUnloadingEnabled。</li><li>新生代的晋升担保失败。老年代是否有足够的空间来容纳全部的新生代对象或历史平均晋升到老年代的对象，如果不够的话，就提早进行一次老年代的回收，防止下次进行YGC(对新生代堆进行gc)的时候发生晋升失败。</li></ol><p><img src="https://img-blog.csdnimg.cn/64aa740652d54acd9af3b424eacc82e9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pCs56CW5pCs56CW5pCs56CW5pCs56CW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=3>CMS执行的六个过程</p><p><img src="https://img-blog.csdnimg.cn/20210426171736480.png" alt="在这里插入图片描述"></p></blockquote><pre><code>  1.  初始标记(STW initial mark)   2.  并发标记(Concurrent marking)   3.  并发预清理(Concurrent precleaning)   4.  重新标记(STW remark)   5.  并发清理(Concurrent sweeping)   6.  并发重置(Concurrent reset)</code></pre><h2 id="①-初始标记"><a href="#①-初始标记" class="headerlink" title="①.初始标记"></a><font color='red' size=4>①.初始标记</h2><ul><li>在这个阶段，需要虚拟机停顿正在执行的任务，官方的叫法STW(Stop The Word)。</li><li>该阶段进行可达性分析，标记GC ROOT能直接关联到的对象，只扫描到能够和”根对象”直接关联的对象，并作标记。</li><li>这个过程虽然暂停了整个JVM，但是很快就完成了。</li></ul><h2 id="②-并发标记"><a href="#②-并发标记" class="headerlink" title="②.并发标记"></a><font color='red' size=4>②.并发标记</h2><ul><li>这个阶段紧随初始标记阶段，在初始标记的基础上继续向下追溯标记。</li><li>并发标记阶段，应用程序的线程和并发标记的线程并发执行，所以用户不会感受到停顿。</li><li>该阶段进行GC ROOT TRACING，在第一个阶段被暂停的线程重新开始运行。</li><li>并发标记阶段是和用户线程并发执行的过程。</li></ul><h2 id="③-并发预清理"><a href="#③-并发预清理" class="headerlink" title="③.并发预清理"></a><font color='red' size=4>③.并发预清理</h2><ul><li>在这个阶段，虚拟机查找在执行并发标记阶段新进入老年代的对象(可能会有一些对象从新生代晋升到老年代， 或者有一些对象被分配到老年代)。</li><li>通过重新扫描，减少下一个阶段”重新标记”的工作，因此重标记的工作尽可能多的在并发阶段完成来减少STW的时间。</li></ul><h2 id="④-重新标记"><a href="#④-重新标记" class="headerlink" title="④.重新标记"></a><font color='red' size=4>④.重新标记</h2><ul><li>这个阶段会暂停虚拟机，收集器线程扫描在CMS堆中剩余的对象。扫描从”跟对象”开始向下追溯，并处理对象关联。</li></ul><h2 id="⑤-并发清理"><a href="#⑤-并发清理" class="headerlink" title="⑤.并发清理"></a><font color='red' size=4>⑤.并发清理</h2><ul><li>清理垃圾对象，这个阶段收集器线程和应用程序线程并发执行。</li><li>用户线程被重新激活，同时清理那些无效的对象。</li></ul><h2 id="⑥-并发重置"><a href="#⑥-并发重置" class="headerlink" title="⑥.并发重置"></a><font color='red' size=4>⑥.并发重置</h2><ul><li>这个阶段，重置CMS收集器的数据结构，CMS清除内部状态，等待下一次垃圾回收。</li></ul><h1 id="三-CMS缺点"><a href="#三-CMS缺点" class="headerlink" title="三. CMS缺点"></a>三. CMS缺点</h1><ol><li><p>CMS不会整理、压缩堆空间。经过CMS收集的堆会产生空间碎片。 </p></li><li><p>CMS回收器减少了回收的停顿时间，但是降低了堆空间的利用率。</p></li><li><p>GC线程与用户线程抢占CPU。这可能会造成用户线程执行效率下降， 需要更多的CPU资源。</p></li></ol><p><img src="https://img-blog.csdnimg.cn/88cbd60b4f4d4f2291024a1c8b6ec058.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pCs56CW5pCs56CW5pCs56CW5pCs56CW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1 id="四-使用的场景"><a href="#四-使用的场景" class="headerlink" title="四. 使用的场景"></a>四. 使用的场景</h1><ul><li><strong>GC过程短暂停，适合对时延要求较高的服务，用户线程不允许长时间的停顿。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-Explain分析执行计划</title>
      <link href="/2021/08/16/MySQL-Explain%E5%88%86%E6%9E%90%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
      <url>/2021/08/16/MySQL-Explain%E5%88%86%E6%9E%90%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="一-查看SQL执行频率"><a href="#一-查看SQL执行频率" class="headerlink" title="一. 查看SQL执行频率"></a>一. 查看SQL执行频率</h1><ul><li>MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。show [session|global] status 可以根据需要加上参数“session”或者“global”来显示 session 级（当前连接）的计结果和 global 级（自数据库上次启动至今）的统计结果。如果不写，默认使用参数是“session”。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">GLOBAL</span> status <span class="keyword">like</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Innodb_rows_%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> goods_innodb;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/071daa487f3945357ac1d5e010a2f4c9.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/217eab2e42b01b36da5ff2db9db8bf57.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/eadf72196137ed0fde36dae1f243f25c.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/45806c4362bb1a261b19169b80c9c733.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/3b0d5cc5d9b566450e559b3f7b46b9fd.png" alt="在这里插入图片描述"></p><ul><li><p>Com_***      :  这些参数对于所有存储引擎的表操作都会进行累计。</p></li><li><p>Innodb_*** :  这几个参数只是针对InnoDB 存储引擎的，累加的算法也略有不同。</p></li></ul><h1 id="二-定位低效率执行SQL"><a href="#二-定位低效率执行SQL" class="headerlink" title="二. 定位低效率执行SQL"></a>二. 定位低效率执行SQL</h1><h2 id="①-慢查询日志"><a href="#①-慢查询日志" class="headerlink" title="①. 慢查询日志"></a>①. 慢查询日志</h2><ul><li>慢查询日志 : 通过慢查询日志定位那些执行效率较低的 SQL 语句，用–log-slow-queries[&#x3D;file_name]选项启动时，mysqld 写一个包含所有执行时间超过 long_query_time 秒的 SQL 语句的日志文件。</li></ul><h2 id="②-show-processlist"><a href="#②-show-processlist" class="headerlink" title="②.  show processlist"></a>②.  show processlist</h2><ul><li>show processlist  : 慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用show processlist命令查看当前MySQL在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/e6ce8126b1f0c87d6809d766cfc0caa2.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/42bde32e55180deb5842172e9eea79c9.png" alt="在这里插入图片描述"></p><h1 id="三-explain分析执行计划"><a href="#三-explain分析执行计划" class="headerlink" title="三.  explain分析执行计划"></a>三.  explain分析执行计划</h1><ul><li>通过以上步骤查询到效率低的 SQL 语句后，可以通过 EXPLAIN或者 DESC命令获取 MySQL如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</li></ul><h2 id="①-创建万级数据"><a href="#①-创建万级数据" class="headerlink" title="①. 创建万级数据"></a>①. 创建万级数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `user_test`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `user_test` (</span><br><span class="line">id <span class="type">BIGINT</span>(<span class="number">20</span>) UNSIGNED  <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键id&#x27;</span>,</span><br><span class="line">`user_name`  <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>  COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">`pass_word`  <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>  COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> COMMENT<span class="operator">=</span> <span class="string">&#x27;用户信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_test (user_name, pass_word) </span><br><span class="line"><span class="keyword">SELECT</span> MD5(RAND()),RAND(<span class="number">10000</span>) <span class="keyword">FROM</span> user_test;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/70c9c2e847e31c53003d7c11618fac53.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/26e1492ec811ac70ac72d567459bb42e.png" alt="在这里插入图片描述"></p><h2 id="②-查询SQL语句的执行计划"><a href="#②-查询SQL语句的执行计划" class="headerlink" title="②. 查询SQL语句的执行计划"></a>②. 查询SQL语句的执行计划</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/0ccd9e3565c488092c91ccd631d143da.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/7e3ad1f4359ddaff80dc211177dda4aa.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/82322ea509cfc75d0aad6940abb322af.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> explain 分析每个字段</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/39a1f9c65dd52bbb6b047b24a84f2bc0.png" alt="在这里插入图片描述"></p><h2 id="③-explain-分析每个字段环境准备"><a href="#③-explain-分析每个字段环境准备" class="headerlink" title="③.  explain 分析每个字段环境准备"></a>③.  explain 分析每个字段环境准备</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/e32b11fb62bd05f3d47f10277f7ab28b.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/c2dfbf450e9b3a910c42254456081b0d.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_role` (</span><br><span class="line">  `id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `role_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `role_code` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `description` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `unique_role_name` (`role_name`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_user` (</span><br><span class="line">  `id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">96</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `unique_user_username` (`username`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `user_role` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> auto_increment ,</span><br><span class="line">  `user_id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `role_id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `fk_ur_user_id` (`user_id`),</span><br><span class="line">  KEY `fk_ur_role_id` (`role_id`),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `fk_ur_role_id` <span class="keyword">FOREIGN</span> KEY (`role_id`) <span class="keyword">REFERENCES</span> `t_role` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> ACTION <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">NO</span> ACTION,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `fk_ur_user_id` <span class="keyword">FOREIGN</span> KEY (`user_id`) <span class="keyword">REFERENCES</span> `t_user` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> ACTION <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">NO</span> ACTION</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;super&#x27;</span>,<span class="string">&#x27;$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#x27;</span>,<span class="string">&#x27;超级管理员&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#x27;</span>,<span class="string">&#x27;系统管理员&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;itcast&#x27;</span>,<span class="string">&#x27;$2a$10$8qmaHgUFUAmPR5pOuWhYWOr291WJYjHelUlYn07k5ELF8ZCrW0Cui&#x27;</span>,<span class="string">&#x27;test02&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;stu1&#x27;</span>,<span class="string">&#x27;$2a$10$pLtt2KDAFpwTWLjNsmTEi.oU1yOZyIn9XkziK/y/spH5rftCpUMZa&#x27;</span>,<span class="string">&#x27;学生1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;stu2&#x27;</span>,<span class="string">&#x27;$2a$10$nxPKkYSez7uz2YQYUnwhR.z57km3yqKn3Hr/p1FR6ZKgc18u.Tvqm&#x27;</span>,<span class="string">&#x27;学生2&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;t1&#x27;</span>,<span class="string">&#x27;$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#x27;</span>,<span class="string">&#x27;老师1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="keyword">VALUES</span>(<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;学生&#x27;</span>,<span class="string">&#x27;student&#x27;</span>,<span class="string">&#x27;学生&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="keyword">VALUES</span>(<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;老师&#x27;</span>,<span class="string">&#x27;teacher&#x27;</span>,<span class="string">&#x27;老师&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="keyword">VALUES</span>(<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;教学管理员&#x27;</span>,<span class="string">&#x27;teachmanager&#x27;</span>,<span class="string">&#x27;教学管理员&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="keyword">VALUES</span>(<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;管理员&#x27;</span>,<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;管理员&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="keyword">VALUES</span>(<span class="string">&#x27;10&#x27;</span>,<span class="string">&#x27;超级管理员&#x27;</span>,<span class="string">&#x27;super&#x27;</span>,<span class="string">&#x27;超级管理员&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_role(id,user_id,role_id) <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;5&#x27;</span>),(<span class="keyword">NULL</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;7&#x27;</span>),(<span class="keyword">NULL</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;8&#x27;</span>),(<span class="keyword">NULL</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;9&#x27;</span>),(<span class="keyword">NULL</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;8&#x27;</span>),(<span class="keyword">NULL</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;10&#x27;</span>) ;</span><br></pre></td></tr></table></figure><h2 id="④-explain-之-id"><a href="#④-explain-之-id" class="headerlink" title="④. explain 之 id"></a>④. explain 之 id</h2><ul><li>id 字段是 select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。</li></ul><h3 id="1-id-相同表示加载表的顺序是从上到下"><a href="#1-id-相同表示加载表的顺序是从上到下" class="headerlink" title="1. id 相同表示加载表的顺序是从上到下"></a>1. id 相同表示加载表的顺序是从上到下</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_role r, t_user u, user_role ur <span class="keyword">where</span> r.id <span class="operator">=</span> ur.role_id <span class="keyword">and</span> u.id <span class="operator">=</span> ur.user_id ;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/f1b805a37f6517de4dbff25db6aa995a.png" alt="在这里插入图片描述"></p><h3 id="2-id-不同id值越大，优先级越高，越先被执行"><a href="#2-id-不同id值越大，优先级越高，越先被执行" class="headerlink" title="2.  id 不同id值越大，优先级越高，越先被执行"></a>2.  id 不同id值越大，优先级越高，越先被执行</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_role <span class="keyword">WHERE</span> id <span class="operator">=</span> (<span class="keyword">SELECT</span> role_id <span class="keyword">FROM</span> user_role <span class="keyword">WHERE</span> user_id <span class="operator">=</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;stu1&#x27;</span>))</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/1fc8808869fbbadba7d388a2c72881fc.png" alt="在这里插入图片描述"></p><h3 id="3-id-有相同，也有不同，同时存在"><a href="#3-id-有相同，也有不同，同时存在" class="headerlink" title="3.  id 有相同，也有不同，同时存在"></a>3.  id 有相同，也有不同，同时存在</h3><ul><li>id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_role r , (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_role ur <span class="keyword">WHERE</span> ur.`user_id` <span class="operator">=</span> <span class="string">&#x27;2&#x27;</span>) a <span class="keyword">WHERE</span> r.id <span class="operator">=</span> a.role_id ; </span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/ce0e0a6d9abff26ce22ef0b97dbdffa7.png" alt="在这里插入图片描述"></p><h2 id="⑤-explain-之-select-type"><a href="#⑤-explain-之-select-type" class="headerlink" title="⑤. explain 之 select_type"></a>⑤. explain 之 select_type</h2><ul><li>表示 SELECT 的类型，常见的取值，如下表所示：<br>  <img src="https://img-blog.csdnimg.cn/img_convert/1bf113004997595cf343061c3bba371d.png" alt="在这里插入图片描述"><blockquote><p><font color='red' size=4> SIMPLE</p></blockquote></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/ab0d7732a3b6fcfbc49ee2a490dacdac.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> PRIMARY和SUBQUEY</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> user_ role <span class="keyword">where</span> role_ id <span class="operator">=</span> <span class="string">&#x27;9&#x27;</span>) ;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/0e06f5d8e2d0d1a2e77b4c3ddaf89e13.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> PRIMARY和DERIVED</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/c13fbc069d5d45a376dfc6206628a5a7.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27;2&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=4> UNION和UNION RESULT<br><img src="https://img-blog.csdnimg.cn/img_convert/800bdb1e162297fbaa1d871781ce4127.png" alt="在这里插入图片描述"></p></blockquote><h2 id="⑥-explain-之-table"><a href="#⑥-explain-之-table" class="headerlink" title="⑥. explain 之 table"></a>⑥. explain 之 table</h2><ul><li>展示这一行的数据是关于哪一张表的</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/7a445a2b7e5c56f103ad10cf96bfbb97.png" alt="在这里插入图片描述"></p><h2 id="⑦-explain-之-type"><a href="#⑦-explain-之-type" class="headerlink" title="⑦. explain 之 type"></a>⑦. explain 之 type</h2><ul><li>type 显示的是访问类型，是较为重要的一个指标，可取值为：</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/874a275d07dd14434a6385b47ac5a9a0.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4>  system</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/27282289e7281bd75305814f16930f32.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> const</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 根据索引</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user  <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;admin&#x27;</span>;</span><br><span class="line"># 根据主键</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user  <span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/b9563f6f33dfb1f0038eb97f8fa04764.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4>  eq_ref<br><img src="https://img-blog.csdnimg.cn/img_convert/bcb3043ecccb731178858fe55ac30954.png" alt="在这里插入图片描述"></p></blockquote><blockquote><p><font color='red' size=4>  ref</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/6a56661dc3b240313f716b179a4e6404.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/c2ccedd57b53f6bb866b49594c9f0d02.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> ALL</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/af0871981a51a106ead62a9b7fdc651f.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> 结果值从最好到最坏以此是：</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/ec1b81adc90acf6dfcbf2e44401b63bb.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">NULL</span> <span class="operator">&gt;</span> <span class="keyword">system</span> <span class="operator">&gt;</span> const <span class="operator">&gt;</span> eq_ref <span class="operator">&gt;</span> <span class="keyword">ref</span> <span class="operator">&gt;</span> fulltext <span class="operator">&gt;</span> ref_or_null </span><br><span class="line"><span class="operator">&gt;</span> index_merge <span class="operator">&gt;</span> unique_subquery <span class="operator">&gt;</span> index_subquery <span class="operator">&gt;</span> <span class="keyword">range</span> <span class="operator">&gt;</span> index <span class="operator">&gt;</span> <span class="keyword">ALL</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">system</span> <span class="operator">&gt;</span> const <span class="operator">&gt;</span> eq_ref <span class="operator">&gt;</span> <span class="keyword">ref</span> <span class="operator">&gt;</span> <span class="keyword">range</span> <span class="operator">&gt;</span> index <span class="operator">&gt;</span> <span class="keyword">ALL</span></span><br></pre></td></tr></table></figure><ul><li>一般来说， 我们需要保证查询至少达到 range 级别， 最好达到ref 。</li></ul><h2 id="⑧-explain-之-key"><a href="#⑧-explain-之-key" class="headerlink" title="⑧.   explain 之  key"></a>⑧.   explain 之  key</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/ba0b31616f9e6d277b663f94da52e914.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/7c55f41ad2b09fbb335c0c06bdf4cd02.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">possible_keys : 显示可能应用在这张表的索引， 一个或多个。 </span><br><span class="line"></span><br><span class="line">key ： 实际使用的索引， 如果为<span class="keyword">NULL</span>， 则没有使用索引。</span><br><span class="line"></span><br><span class="line">key_len : 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。</span><br></pre></td></tr></table></figure><h2 id="⑨-explain-之-rows"><a href="#⑨-explain-之-rows" class="headerlink" title="⑨. explain 之 rows"></a>⑨. explain 之 rows</h2><ul><li>扫描行的数量。<br><img src="https://img-blog.csdnimg.cn/img_convert/e4e7564fad99d162aace2cb5c5291c7e.png" alt="在这里插入图片描述"></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/b7c69e16a57285f1df689eb0a41e0879.png" alt="在这里插入图片描述"></p><h2 id="⑩-explain-之-extra"><a href="#⑩-explain-之-extra" class="headerlink" title="⑩.  explain 之 extra"></a>⑩.  explain 之 extra</h2><ul><li>其他的额外的执行计划信息，在该列展示 。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/3731b7cfb17c4eaeb9a0c828bb295e46.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4>  Using filesort</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/75d34d81e98ccd6263b47f202b6f7872.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/89647f837acc3e1c603b92569134eb8c.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4>  Using index</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/f2cfb097a230b1c3fe25065dea2fab36.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/22f0db8a9fd68e9be5fe1717fd68145e.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4>  Using temporary ，Using filesort</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/40f3ee95fc6110a1ee1418c6bbdc9796.png" alt="在这里插入图片描述"></p><h1 id="四-show-profile分析SQL"><a href="#四-show-profile分析SQL" class="headerlink" title="四. show profile分析SQL"></a>四. show profile分析SQL</h1><ul><li>Mysql从5.0.37版本开始增加了对 show profiles 和 show profile 语句的支持。show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。</li><li>通过 have_profiling 参数，能够看到当前MySQL是否支持profile：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@have</span>_profiling</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/9220cd3b3fa5923e43a961869d7bb03f.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@profiling</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/7e3e3a8bd2216561f9f8eb967890094c.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling<span class="operator">=</span><span class="number">1</span>; <span class="operator">/</span><span class="operator">/</span>开启profiling 开关；</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/6bad39bb906dff5e1e6f2b75dcb2d6b3.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> 通过profile，我们能够更清楚地了解SQL执行的过程。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/0a5e34532c4105114b135241e1cb7ca2.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/04e11660618259b5120d662c8ca8a976.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> 通过show profile for query query_id 语句可以查看到该SQL执行过程中每个线程的状态和消耗的时间</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> profile <span class="keyword">all</span> <span class="keyword">for</span> query <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/839d3cf89f2ff3a8c00fe02456bd4a68.png" alt="在这里插入图片描述"></p><ul><li>在获取到最消耗时间的线程状态后，MySQL支持进一步选择all、cpu、block io 、context switch、page faults等明细类型类查看MySQL在使用什么资源上耗费了过高的时间。例如，选择查看CPU的耗费时间  ：</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/3eea00868cbaf7680681fe4aabcb1e8d.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/417139788a3eba8a73124a781737c196.png" alt="在这里插入图片描述"></p><h1 id="五-trace分析优化器执行计划"><a href="#五-trace分析优化器执行计划" class="headerlink" title="五. trace分析优化器执行计划"></a>五. trace分析优化器执行计划</h1><ul><li><p>MySQL5.6提供了对SQL的跟踪trace, 通过trace文件能够进一步了解为什么优化器选择A计划, 而不是选择B计划。</p></li><li><p>打开trace ， 设置格式为 JSON，并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span>&quot;enabled=on&quot;,end_markers_in_json<span class="operator">=</span><span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">set</span> optimizer_trace_max_mem_size<span class="operator">=</span><span class="number">1000000</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/8a6cf5bcaf7db08e21b06d66d69e4f5e.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> 执行SQL语句</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_test <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/bbb361d0a785bc10711d3767ae892b10.png" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4>  检查information_schema.optimizer_trace就可以知道MySQL是如何执行SQL的 </p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/062c0f678940e35e5d577e45f9fc3254.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal源码分析</title>
      <link href="/2021/08/12/ThreadLocal/"/>
      <url>/2021/08/12/ThreadLocal/</url>
      
        <content type="html"><![CDATA[<h1 id="一-ThreadLocal源码分析"><a href="#一-ThreadLocal源码分析" class="headerlink" title="一. ThreadLocal源码分析"></a>一. ThreadLocal源码分析</h1><p><img src="https://img-blog.csdnimg.cn/762e9cc66f6447999c97d423e7afba18.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pCs56CW5pCs56CW5pCs56CW5pCs56CW,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="①-核心属性"><a href="#①-核心属性" class="headerlink" title="①. 核心属性"></a>①. 核心属性</h2><p><img src="https://img-blog.csdnimg.cn/20210429162248291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义了一个AtomicInteger类型,每次获取当前值并加上HASH_INCREMENT</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadLocalHashCode</span> <span class="operator">=</span> nextHashCode();</span><br><span class="line"><span class="comment">//获取下一个hashCode值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">nextHashCode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"><span class="comment">//Hash值增长值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_INCREMENT</span> <span class="operator">=</span> <span class="number">0x61c88647</span>;</span><br></pre></td></tr></table></figure><h2 id="②-get-方法"><a href="#②-get-方法" class="headerlink" title="②. get()方法"></a>②. get()方法</h2><p><img src="https://img-blog.csdnimg.cn/20210429162540338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前线程本地变量的值</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取当前线程的map</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">//判断当前线程的map是否存在，不为空</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果存在，就获取当前对象的Entry键值对</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//判断这个键值对是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果不是空，就返回对应的value值</span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此处是当前线程的map不存在，返回setInitialValue，进程初始化</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=3>执行流程get()方法</p></blockquote><ol><li><p>首先获取当前线程</p></li><li><p>根据当前线程获取一个Map</p></li><li><p>如果获取的Map不为空，则在Map中以ThreadLocal的引用作为key来在Map中获取对应的value e，否则转到E</p></li><li><p>如果e不为null，则返回e.value，否则转到E</p></li><li><p>Map为空或者e为空，则通过initialValue函数获取初始值value，然后用ThreadLocal的引用和value作为firstKey和firstValue创建一个新的Map</p></li></ol><h2 id="③-setInitialValue"><a href="#③-setInitialValue" class="headerlink" title="③. setInitialValue()"></a>③. setInitialValue()</h2><p><img src="https://img-blog.csdnimg.cn/20210429163921402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set的变样实现，用于初始化值initialValue</span></span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//调用initialValue方法，此方法是初始化ThreadLocal的方法，</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">    <span class="comment">//获取当前线程对象</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">//如果此map存在</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 存在则调用map.set设置此实体entry</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 1）当前线程Thread 不存在ThreadLocalMap对象</span></span><br><span class="line">        <span class="comment">// 2）则调用createMap进行ThreadLocalMap对象的初始化</span></span><br><span class="line">        <span class="comment">// 3）并将此实体entry作为第一个值存放至ThreadLocalMap中</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="comment">// 返回设置的值value</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="④-createMap-和getMap-方法"><a href="#④-createMap-和getMap-方法" class="headerlink" title="④. createMap() 和getMap()方法"></a>④. createMap() 和getMap()方法</h2><blockquote><p><font color='red' size=4>createMap 创建当前线程Thread对应维护的ThreadLocalMap</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210429165651190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建当前线程Thread对应维护的ThreadLocalMap</span></span><br><span class="line"><span class="comment">//firstValue 存放到map中第一个entry的值</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    <span class="comment">//这里的this是调用此方法的threadLocal</span></span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=4>getMap(Thread t) 获取当前线程的map</p></blockquote><p><img src="https://img-blog.csdnimg.cn/2021042916275481.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> t.threadLocals;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=4>Thread类中的属性 threadLocals </p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210429162821514.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个Thread线程内部都有一个Map (ThreadLocalMap)</span></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h2 id="⑤-set-方法"><a href="#⑤-set-方法" class="headerlink" title="⑤. set()方法"></a>⑤. set()方法</h2><p><img src="https://img-blog.csdnimg.cn/20210429165319855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//在ThreadLocal 中，以t来获取当前线程的一个ThreadLocalMap</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">//如果ThreadLocal中有这个map，就把当前类和对应的值传进去</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 存在则调用map.set设置此实体entry</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 1）当前线程Thread 不存在ThreadLocalMap对象</span></span><br><span class="line">        <span class="comment">// 2）则调用createMap进行ThreadLocalMap对象的初始化</span></span><br><span class="line">        <span class="comment">// 3）并将此实体entry作为第一个值存放至ThreadLocalMap中</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=3>执行流程get()方法</p></blockquote><ol><li><p>首先获取当前线程，并根据当前线程获取一个Map</p></li><li><p>如果获取的Map不为空，则将参数设置到Map中（当前ThreadLocal的引用作为key）</p></li><li><p>如果Map为空，则给该线程创建 Map，并设置初始值</p></li></ol><h2 id="⑥-remove-方法"><a href="#⑥-remove-方法" class="headerlink" title="⑥. remove() 方法"></a>⑥. remove() 方法</h2><p><img src="https://img-blog.csdnimg.cn/20210429165521816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除当前线程中保存的ThreadLocal对应的实体entry</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">// 获取当前线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">     <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">     <span class="comment">// 如果此map存在</span></span><br><span class="line">     <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">         <span class="comment">// 存在则调用map.remove</span></span><br><span class="line">         <span class="comment">// 以当前ThreadLocal为key删除对应的实体entry</span></span><br><span class="line">         m.remove(<span class="built_in">this</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="二-ThreadLocalMap源码分析"><a href="#二-ThreadLocalMap源码分析" class="headerlink" title="二. ThreadLocalMap源码分析"></a>二. ThreadLocalMap源码分析</h1><blockquote><p><font color='red' size=3>ThreadLocalMap是ThreadLocal里面的一个静态内部类</p></blockquote><h2 id="①-Entry内部类"><a href="#①-Entry内部类" class="headerlink" title="①. Entry内部类"></a>①. Entry内部类</h2><p><img src="https://img-blog.csdnimg.cn/20210429170443658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadLocalMap 是ThreadLocal里面的一个内部类，相当于Map，是个双列集合</span></span><br><span class="line"><span class="comment">//由于ThreadLocalMap使用线性探测法来解决散列冲突，所以实际上Entry[]数组在程序逻辑上是作为一个环形存在的</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在ThreadLocalMap中，也是用Entry来保存K-V结构数据的。但是Entry中key只能是ThreadLocal对象，这点被Entry的构造方法已经限定死了</span></span><br><span class="line">    <span class="comment">// 另外，Entry继承WeakReference,使用弱引用，可以将ThreadLocal对象的生命周期和线程生命周期解绑</span></span><br><span class="line">    <span class="comment">// 持有对ThreadLocal的弱引用，可以使得ThreadLocal在没有其他强引用的时候被回收掉，这样可以避免因为线程得不到销毁导致ThreadLocal对象无法被回收</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        <span class="comment">//定义了一个类型为Object的value，用于存放塞到ThreadLocal里的值。</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="built_in">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="②-核心属性"><a href="#②-核心属性" class="headerlink" title="②. 核心属性"></a>②. 核心属性</h2><p><img src="https://img-blog.csdnimg.cn/20210429170606897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始容量，必须为2的幂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="comment">//Entry表，大小必须为2的幂</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"><span class="comment">//数组里面entrys的个数,可以用于判断table当前使用量是否超过负因子。</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//进行扩容的阈值,表使用量大于它的时候进行扩容,默认为0</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//阈值设置为长度的2/3</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setThreshold</span><span class="params">(<span class="type">int</span> len)</span> &#123;</span><br><span class="line">    threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取环形数组的下一个索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取环形数组的上一个索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">prevIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="③-ThreadLocalMap构造函数"><a href="#③-ThreadLocalMap构造函数" class="headerlink" title="③. ThreadLocalMap构造函数"></a>③. ThreadLocalMap构造函数</h2><p><img src="https://img-blog.csdnimg.cn/20210429170659196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造一个包含firstKey和firstValue的map。</span></span><br><span class="line"><span class="comment">//ThreadLocalMap是懒加载，所以只有当至少要往里面放一个元素的时候才会构建它。</span></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    <span class="comment">// 初始化table数组</span></span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">    <span class="comment">// 用firstKey的threadLocalHashCode与初始大小16取模得到哈希值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 初始化该节点</span></span><br><span class="line">    table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">    <span class="comment">// 设置节点表大小为1</span></span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设定扩容阈值</span></span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="④-getEntry-方法-获取Entry"><a href="#④-getEntry-方法-获取Entry" class="headerlink" title="④. getEntry()方法 获取Entry"></a>④. getEntry()方法 获取Entry</h2><p><img src="https://img-blog.csdnimg.cn/20210429170818327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取ThreadLocal的索引位置，通过下标索引获取内容</span></span><br><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据key这个ThreadLocal的ID来获取索引，也即哈希值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">    <span class="comment">// 对应的entry存在且未失效且弱引用指向的ThreadLocal就是key，则命中返回</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//如果第一次找的不对，因为用的是线性探测，所以往后找还是有可能能够找到目标Entry的</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑤-getEntryAfterMiss"><a href="#⑤-getEntryAfterMiss" class="headerlink" title="⑤. getEntryAfterMiss()"></a>⑤. getEntryAfterMiss()</h2><p><img src="https://img-blog.csdnimg.cn/20210429171031147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用getEntry未直接命中的时候调用此方法</span></span><br><span class="line"> <span class="keyword">private</span> Entry <span class="title function_">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="type">int</span> i, Entry e)</span> &#123;</span><br><span class="line">     Entry[] tab = table;</span><br><span class="line">     <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">     <span class="comment">// 循环向后遍历 基于线性探测法不断向后探测直到遇到空entry。</span></span><br><span class="line">     <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 获取节点对应的k</span></span><br><span class="line">         ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">         <span class="comment">// 相等则返回</span></span><br><span class="line">         <span class="keyword">if</span> (k == key)</span><br><span class="line">             <span class="keyword">return</span> e;</span><br><span class="line">         <span class="comment">// 如果为null，触发一次连续段清理</span></span><br><span class="line">         <span class="keyword">if</span> (k == <span class="literal">null</span>)</span><br><span class="line">             <span class="comment">// 该entry对应的ThreadLocal已经被回收，调用expungeStaleEntry来清理无效的entry</span></span><br><span class="line">             expungeStaleEntry(i);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             <span class="comment">// 获取下一个下标接着进行判断</span></span><br><span class="line">             i = nextIndex(i, len);</span><br><span class="line">         e = tab[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=3>getEntry() 流程</p></blockquote><ol><li><p>首先根据key的hashcode &amp; table.length - 1来确定在table当中的下标</p></li><li><p>如果获取到直接返回，没获取到的话，就接着往后遍历看是否能获取到（因为用的是线性探测法，往后遍历有可能获取到结果）</p></li><li><p>进入了getEntryAfterMiss方法进行线性探测，如果获取到则直接返回；获取的key为null，则触发一次连续段清理expungeStaleEntry（实际上在很多方法当中都会触发该方法，经常会进行连续段清理，这是ThreadLocal核心的清理方法）。</p></li></ol><h2 id="⑥-expungeStaleEntry-方法核心清理函数"><a href="#⑥-expungeStaleEntry-方法核心清理函数" class="headerlink" title="⑥. expungeStaleEntry()方法核心清理函数"></a>⑥. expungeStaleEntry()方法核心清理函数</h2><p><img src="https://img-blog.csdnimg.cn/20210429171353452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个函数是ThreadLocal中核心清理函数</span></span><br><span class="line">       <span class="comment">//  1、从staleSlot开始，向后遍历将ThreadLocal对象被回收所在Entry节点的value和Entry节点本身设置null，方便GC，并且size自减1</span></span><br><span class="line">       <span class="comment">//  2、并且会对非null的Entry节点进行rehash，只要不是在当前位置，就会将Entry挪到下一个为null的位置上</span></span><br><span class="line">       <span class="comment">// 所以实际上是对从staleSlot开始做一个连续段的清理和rehash操作</span></span><br><span class="line">       <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expungeStaleEntry</span><span class="params">(<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">           <span class="comment">// 新的引用指向table</span></span><br><span class="line">           Entry[] tab = table;</span><br><span class="line">           <span class="comment">// 获取长度</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">           <span class="comment">// 因为entry对应的ThreadLocal已经被回收，value设为null，显式断开强引用</span></span><br><span class="line">           tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">           <span class="comment">// 显式设置该entry为null，以便垃圾回收</span></span><br><span class="line">           tab[staleSlot] = <span class="literal">null</span>;</span><br><span class="line">           <span class="comment">// table的size-1</span></span><br><span class="line">           size--;</span><br><span class="line">           Entry e;</span><br><span class="line">           <span class="type">int</span> i;</span><br><span class="line">           <span class="comment">// 遍历删除指定节点所有后续节点当中，ThreadLocal被回收的节点</span></span><br><span class="line">           <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">                (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">                i = nextIndex(i, len)) &#123;</span><br><span class="line">               <span class="comment">// 获取entry当中的key</span></span><br><span class="line">               ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">               <span class="comment">// 如果ThreadLocal为null，则将value以及数组下标所在位置设置null，方便GC</span></span><br><span class="line">               <span class="comment">// 并且size-1</span></span><br><span class="line">               <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">                   e.value = <span class="literal">null</span>;</span><br><span class="line">                   tab[i] = <span class="literal">null</span>;</span><br><span class="line">                   size--;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 对于还没有被回收的情况，需要做一次rehash。</span></span><br><span class="line">                   <span class="comment">// 如果对应的ThreadLocal的ID对len取模出来的索引h不为当前位置i，</span></span><br><span class="line">                   <span class="comment">// 则从h向后线性探测到第一个空的slot，把当前的entry给挪过去。</span></span><br><span class="line">                   <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                   <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                       tab[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">while</span> (tab[h] != <span class="literal">null</span>)</span><br><span class="line">                           h = nextIndex(h, len);</span><br><span class="line">                       tab[h] = e;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 返回staleSlot之后第一个空的slot索引</span></span><br><span class="line">           <span class="keyword">return</span> i;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h2 id="⑦-set-方法"><a href="#⑦-set-方法" class="headerlink" title="⑦. set()方法"></a>⑦. set()方法</h2><p><img src="https://img-blog.csdnimg.cn/20210429171706815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  ThreadLocalMap的set方法，这个方法还是挺关键的</span></span><br><span class="line">       <span class="comment">//  通过这个方法，我们可以看出该哈希表是用线性探测法来解决冲突的</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">           <span class="comment">// 新开一个引用指向table</span></span><br><span class="line">           Entry[] tab = table;</span><br><span class="line">           <span class="comment">// 获取table的长度</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">           <span class="comment">//计算索引 &amp; (INITIAL_CAPACITY - 1),这是取模的一种方式，对于2的幂作为模数取模，用此代替%(2^n)</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">           <span class="comment">//根据获取到的索引进行循环，如果当前索引上的table[i]不为空，在没有return的情况下</span></span><br><span class="line">           <span class="comment">//就使用nextIndex()获取下一个(线性探测法)</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">                e != <span class="literal">null</span>;</span><br><span class="line">                e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">               ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">               <span class="comment">// table[i]上key不为空，并且和当前key相同，更新value</span></span><br><span class="line">               <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                   e.value = value;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// table[i]上的key为空，说明被回收了</span></span><br><span class="line">               <span class="comment">// 这个时候说明改table[i]可以重新使用，用新的key-value将其替换,并删除其他无效的entry</span></span><br><span class="line">               <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">                   replaceStaleEntry(key, value, i);</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 找到空的位置，创建Entry对象并插入</span></span><br><span class="line">           tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">           <span class="comment">// table内元素size自增</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">           <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">               rehash();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h2 id="⑧-replaceStaleEntry"><a href="#⑧-replaceStaleEntry" class="headerlink" title="⑧. replaceStaleEntry()"></a>⑧. replaceStaleEntry()</h2><p><img src="https://img-blog.csdnimg.cn/20210429171855156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    <span class="comment">// 新开一个引用指向table</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="comment">// 获取table的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="comment">// 记录当前失效的节点下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">slotToExpunge</span> <span class="operator">=</span> staleSlot;</span><br><span class="line">    <span class="comment">// 通过这个for循环的prevIndex(staleSlot, len)可以看出</span></span><br><span class="line">    <span class="comment">// 这是由staleSlot下标开始向前扫描</span></span><br><span class="line">    <span class="comment">// 查找并记录最前位置value为null的下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="literal">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    <span class="comment">// 通过for循环nextIndex(staleSlot, len)可以看出</span></span><br><span class="line">    <span class="comment">// 这是由staleSlot下标开始向后扫描</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        <span class="comment">// 获取Entry节点对应的ThreadLocal对象</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 找到了key，将其与无效的slot交换</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            <span class="comment">// 更新对应slot的value值</span></span><br><span class="line">            e.value = value;</span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过注释看出,i之前的节点里,没有value为null的情况</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            <span class="comment">// 从slotToExpunge开始做一次连续段的清理，再做一次启发式清理</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前的slot已经无效，并且向前扫描过程中没有无效slot，则更新slotToExpunge为当前位置</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果key在table中不存在，则在原地放一个即可</span></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="comment">//  在调用cleanSomeSlots进行启发式清理之前</span></span><br><span class="line">    <span class="comment">//  会先调用expungeStaleEntry方法从slotToExpunge到table下标所在为null的连续段进行一次清理</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑨-cleanSomeSlots-启发式地清理slot"><a href="#⑨-cleanSomeSlots-启发式地清理slot" class="headerlink" title="⑨. cleanSomeSlots()启发式地清理slot"></a>⑨. cleanSomeSlots()启发式地清理slot</h2><p><img src="https://img-blog.csdnimg.cn/20210429172013372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启发式地清理slot</span></span><br><span class="line">      <span class="comment">// i对应的Entry是非无效的，有可能是失效被回收了，也有可能是null</span></span><br><span class="line">      <span class="comment">// 会有两个地方调用到这个方法</span></span><br><span class="line">      <span class="comment">// 1、set方法，在判断是否需要resize之前，会清理并rehash一遍</span></span><br><span class="line">      <span class="comment">// 2、替换失效的节点时候，也会进行一次清理</span></span><br><span class="line">      <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">cleanSomeSlots</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">          <span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">          Entry[] tab = table;</span><br><span class="line">          <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">              <span class="comment">// i在任何情况下自己都不会是一个无效slot，所以从下一个开始判断</span></span><br><span class="line">              i = nextIndex(i, len);</span><br><span class="line">              <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">              <span class="comment">// Entry对象不为空，但是ThreadLocal这个key已经为null</span></span><br><span class="line">              <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// 扩大扫描控制因子</span></span><br><span class="line">                  n = len;</span><br><span class="line">                  removed = <span class="literal">true</span>;</span><br><span class="line">                  <span class="comment">// 清理一个连续段</span></span><br><span class="line">                  i = expungeStaleEntry(i);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">return</span> removed;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h2 id="⑩-rehash-方法和resize-方法"><a href="#⑩-rehash-方法和resize-方法" class="headerlink" title="⑩. rehash()方法和resize() 方法"></a>⑩. rehash()方法和resize() 方法</h2><blockquote><p><font color='red' size=4>rehash()</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210429173008133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 做一次全量清理</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    <span class="comment">//   因为做了一次清理，所以size很可能会变小。</span></span><br><span class="line">    <span class="comment">//   ThreadLocalMap这里的实现是调低阈值来判断是否需要扩容，</span></span><br><span class="line">    <span class="comment">//   threshold默认为len*2/3，所以这里的threshold - threshold / 4相当于len/2</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=4>resize()</p><p><img src="https://img-blog.csdnimg.cn/20210429172529729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扩容，因为需要保证table的容量len为2的幂，所以扩容即扩大2倍</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="comment">// 获取旧table的长度，并且创建一个长度为旧长度2倍的Entry数组</span></span><br><span class="line">          Entry[] oldTab = table;</span><br><span class="line">          <span class="type">int</span> <span class="variable">oldLen</span> <span class="operator">=</span> oldTab.length;</span><br><span class="line">          <span class="type">int</span> <span class="variable">newLen</span> <span class="operator">=</span> oldLen * <span class="number">2</span>;</span><br><span class="line">          Entry[] newTab = <span class="keyword">new</span> <span class="title class_">Entry</span>[newLen];</span><br><span class="line">          <span class="comment">// 记录插入的有效Entry节点数</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//  从下标0开始，逐个向后遍历插入到新的table当中</span></span><br><span class="line">          <span class="comment">//  1、如遇到key已经为null，则value设置null，方便GC回收</span></span><br><span class="line">          <span class="comment">//  2、通过hashcode &amp; len - 1计算下标，如果该位置已经有Entry数组，则通过线性探测向后探测插入</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">              <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> oldTab[j];</span><br><span class="line">              <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                  ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                  <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">                      e.value = <span class="literal">null</span>;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="comment">// 线性探测来存放Entry</span></span><br><span class="line">                      <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                      <span class="keyword">while</span> (newTab[h] != <span class="literal">null</span>)</span><br><span class="line">                          h = nextIndex(h, newLen);</span><br><span class="line">                      newTab[h] = e;</span><br><span class="line">                      count++;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 重新设置扩容的阈值</span></span><br><span class="line">          setThreshold(newLen);</span><br><span class="line">          <span class="comment">// 更新size</span></span><br><span class="line">          size = count;</span><br><span class="line">          <span class="comment">// 指向新的Entry数组</span></span><br><span class="line">          table = newTab;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=3> set() 流程</p></blockquote><ol><li>先通过hashcode &amp; (len - 1)来定位该ThreadLocal在table当中的下标</li><li>for循环向后遍历</li><li>如果获取Entry节点的key与我们需要操作的ThreadLocal相等，则直接替换value</li><li>如果遍历的时候拿到了key为null的情况，则调用replaceStaleEntry方法进行与之替换。</li><li>如果上述两个情况都是，则直接在计算的出来的下标当中new一个Entry阶段插入。</li><li>进行一次启发式地清理并且如果插入节点后的size大于扩容的阈值，则调用resize方法进行扩容。</li></ol><h2 id="⑩-remove-方法"><a href="#⑩-remove-方法" class="headerlink" title="⑩. remove() 方法"></a>⑩. remove() 方法</h2><p><img src="https://img-blog.csdnimg.cn/20210429172339217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将ThreadLocal对象对应的Entry节点从table当中删除</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">      Entry[] tab = table;</span><br><span class="line">      <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">           e != <span class="literal">null</span>;</span><br><span class="line">           e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">          <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">              <span class="comment">// // 将引用设置null，方便GC</span></span><br><span class="line">              e.clear();</span><br><span class="line">              <span class="comment">// 从该位置开始进行一次连续段清理</span></span><br><span class="line">              expungeStaleEntry(i);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="三-线程泄露"><a href="#三-线程泄露" class="headerlink" title="三. 线程泄露"></a>三. 线程泄露</h1><blockquote><p><font color='red' size=3> 线程泄露原因</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210429173834913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li>每次操作set、get、remove操作时，会相应调用 ThreadLocalMap 的三个方法，ThreadLocalMap的三个方法在每次被调用时 都会直接或间接调用一个 expungeStaleEntry() 方法，这个方法会将key为null的 Entry 删除，从而避免内存泄漏。</li><li>将一个大对象放入LocalThreadMap后便不再调用set、get、remove方法仍然有可能key的弱引用被回收后，Value强引用没有被回收，此时该仍然可能会导致内存泄漏，这个需要程序员在完成ThreadLocal的使用后要养成手动调用**remove()**的习惯，从而避免内存泄漏。</li></ol><blockquote><p><font color='red' size=3> 附总的数据结构流程图</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210429175257950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="&gt; &lt;font color=&#39;red&#39; size=3&gt; 解决办法"></p>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS底层原理---JDK1.8源码分析</title>
      <link href="/2021/08/07/CAS/"/>
      <url>/2021/08/07/CAS/</url>
      
        <content type="html"><![CDATA[<h1 id="一-CAS介绍"><a href="#一-CAS介绍" class="headerlink" title="一. CAS介绍"></a>一. CAS介绍</h1><ul><li><p>CAS的全称是Compare-And-Swap，它是CPU并发原语。</p></li><li><p>它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。</p></li><li><p>CAS并发原语体现在Java语言中就是sun.misc.Unsafe类的各个方法。调用UnSafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令，这是一种完全依赖于硬件的功能，通过它实现了原子操作，再次强调，由于CAS是一种系统原语，原语属于操作系统用于范畴，是由若干条指令组成，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致的问题，也就是说CAS是线程安全的。</p></li></ul><h1 id="二-CAS代码实现"><a href="#二-CAS代码实现" class="headerlink" title="二. CAS代码实现"></a>二. CAS代码实现</h1><p><img src="https://img-blog.csdnimg.cn/2021070919545723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xizi.cas;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CASDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个原子类</span></span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 一个是期望值，一个是更新值，但期望值和原来的值相同时，才能够更改</span></span><br><span class="line"><span class="comment">         * 假设三秒前，我拿的是5，也就是expect为5，然后我需要更新成 2019</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">2019</span>) + <span class="string">&quot;\t current data: &quot;</span> + atomicInteger.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">1024</span>) + <span class="string">&quot;\t current data: &quot;</span> + atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这是因为我们执行第一个的时候，期望值和原本值是满足的，因此修改成功，但是第二次后，主内存的值已经修改成了2019，不满足期望值，因此返回了false，本次写入失败。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210709195516516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="三-CAS底层原理"><a href="#三-CAS底层原理" class="headerlink" title="三. CAS底层原理"></a>三. CAS底层原理</h1><blockquote><p><font color='red' size=4> 首先我们先看看 atomicInteger.getAndIncrement()方法的源码</p></blockquote><ul><li>从这里能够看到，底层又调用了一个unsafe类的getAndAddInt方法</li></ul><p><img src="https://img-blog.csdnimg.cn/20210709195706542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="①-Unsafe类"><a href="#①-Unsafe类" class="headerlink" title="①.  Unsafe类"></a>①.  Unsafe类</h2><blockquote><p><font color='red' size=4> Unsafe类</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210709200109504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>Unsafe是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（Native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定的内存数据。Unsafe类存在sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中的CAS操作的执行依赖于Unsafe类的方法。</p></li><li><p>注意Unsafe类的所有方法都是native修饰的，也就是说unsafe类中的方法都直接调用操作系统底层资源执行相应的任务</p></li><li><p>为什么Atomic修饰的包装类，能够保证原子性，依靠的就是底层的unsafe类</p></li></ul><h2 id="②-变量valueOffset"><a href="#②-变量valueOffset" class="headerlink" title="②. 变量valueOffset"></a>②. 变量valueOffset</h2><ul><li>从这里我们能够看到，通过valueOffset，直接通过内存地址，获取到值，然后进行加1的操作</li><li><img src="https://img-blog.csdnimg.cn/20210709195706542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="③-变量value用volatile修饰"><a href="#③-变量value用volatile修饰" class="headerlink" title="③. 变量value用volatile修饰"></a>③. 变量value用volatile修饰</h2><ul><li>保证了多线程之间的内存可见性<br><img src="https://img-blog.csdnimg.cn/20210709200402154.png" alt="在这里插入图片描述"></li></ul><h2 id="④-getAndAddInt-源码分析"><a href="#④-getAndAddInt-源码分析" class="headerlink" title="④. getAndAddInt() 源码分析"></a>④. getAndAddInt() 源码分析</h2><p><img src="https://img-blog.csdnimg.cn/20210709200531561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>var5：就是我们从主内存中拷贝到工作内存中的值(每次都要从主内存拿到最新的值到自己的本地内存，然后执行compareAndSwapInt()在再和主内存的值进行比较。因为线程不可以直接越过高速缓存，直接操作主内存，所以执行上述方法需要比较一次，在执行加1操作)</p></li><li><p>那么操作的时候，需要比较工作内存中的值，和主内存中的值进行比较</p></li></ul><blockquote><p><font color='red' size=4> 假设执行 compareAndSwapInt返回false，那么就一直执行 while方法，直到期望的值和真实值一样</p></blockquote><ul><li>val1：AtomicInteger对象本身</li><li>var2：该对象值得引用地址</li><li>var4：需要变动的数量</li><li>var5：用var1和var2找到的内存中的真实值</li><li>用该对象当前的值与var5比较<ul><li>如果相同，更新var5 + var4 并返回true<br>- 如果不同，继续取值然后再比较，直到更新完成</li></ul></li></ul><p>这里没有用synchronized，而用CAS，这样提高了并发性，也能够实现一致性，是因为每个线程进来后，进入的do while循环，然后不断的获取内存中的值，判断是否为最新，然后在进行更新操作。</p><blockquote><p><font color='red' size=4> 假设线程A和线程B同时执行getAndInt操作（分别跑在不同的CPU上）</p></blockquote><ol><li>AtomicInteger里面的value原始值为3，即主内存中AtomicInteger的 value 为3，根据JMM模型，线程A和线程B各自持有一份价值为3的副本，分别存储在各自的工作内存</li><li>线程A通过getIntVolatile(var1 , var2) 拿到value值3，这是线程A被挂起（该线程失去CPU执行权）</li><li>线程B也通过getIntVolatile(var1, var2)方法获取到value值也是3，此时刚好线程B没有被挂起，并执行了compareAndSwapInt方法，比较内存的值也是3，成功修改内存值为4，线程B打完收工，一切OK</li><li>这是线程A恢复，执行CAS方法，比较发现自己手里的数字3和主内存中的数字4不一致，说明该值已经被其它线程抢先一步修改过了，那么A线程本次修改失败，只能够重新读取后在来一遍了，也就是在执行do while</li><li>线程A重新获取value值，因为变量value被volatile修饰，所以其它线程对它的修改，线程A总能够看到，线程A继续执行compareAndSwapInt进行比较替换，直到成功。</li></ol><blockquote><p><font color='red' size=4>Unsafe类 + CAS思想： 也就是自旋，自我旋转</p></blockquote><h2 id="⑤-底层汇编"><a href="#⑤-底层汇编" class="headerlink" title="⑤. 底层汇编"></a>⑤. 底层汇编</h2><ul><li><p>Unsafe类中的compareAndSwapInt是一个本地方法，该方法的实现位于unsafe.cpp中</p><ul><li>先想办法拿到变量value在内存中的地址<ul><li>通过Atomic::cmpxchg实现比较替换，其中参数X是即将更新的值，参数e是原内存的值</li></ul></li></ul></li></ul><h2 id="⑥-原子引用"><a href="#⑥-原子引用" class="headerlink" title="⑥. 原子引用"></a>⑥. 原子引用</h2><ul><li>原子引用其实和原子包装类是差不多的概念，就是将一个java类，用原子引用类进行包装起来，那么这个类就具备了原子性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xizi.cas;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    String userName;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">z3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;z3&quot;</span>, <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">l4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;l4&quot;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建原子引用包装类</span></span><br><span class="line">        AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在主物理内存的共享变量，为z3</span></span><br><span class="line">        atomicReference.set(z3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较并交换，如果现在主物理内存的值为z3，那么交换成l4</span></span><br><span class="line">        System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="string">&quot;\t &quot;</span> + atomicReference.get().toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较并交换，现在主物理内存的值是l4了，但是预期为z3，因此交换失败</span></span><br><span class="line">        System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="string">&quot;\t &quot;</span> + atomicReference.get().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四-CAS缺点"><a href="#四-CAS缺点" class="headerlink" title="四. CAS缺点"></a>四. CAS缺点</h1><blockquote><p><font color='red' size=4> CAS不加锁，保证一次性，但是需要多次比较</p></blockquote><ul><li>循环时间长，开销大（因为执行的是do while，如果比较不成功一直在循环，最差的情况，就是某个线程一直取到的值和预期值都不一样，这样就会无限循环）</li><li>只能保证一个共享变量的原子操作</li><li>当对一个共享变量执行操作时，我们可以通过循环CAS的方式来保证原子操作</li><li>但是对于多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候只能用锁来保证原子性</li><li>引出来ABA问题？</li></ul><h1 id="五-解决ABA问题"><a href="#五-解决ABA问题" class="headerlink" title="五. 解决ABA问题"></a>五. 解决ABA问题</h1><h2 id="①-ABA问题介绍"><a href="#①-ABA问题介绍" class="headerlink" title="①. ABA问题介绍"></a>①. ABA问题介绍</h2><ul><li>CAS只管开头和结尾，也就是头和尾是一样，那就修改成功，中间的这个过程，可能会被人修改过。</li><li>ABA问题的根本在于CAS在修改变量的时候，无法记录变量的状态，比如修改的次数，否修改过这个变量。这样就很容易在一个线程将A修改成B时，另一个线程又会把B修改成A,造成CAS多次执行的问题。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210709201348581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="②-ABA问题解决方法"><a href="#②-ABA问题解决方法" class="headerlink" title="②. ABA问题解决方法"></a>②. ABA问题解决方法</h2><ul><li>时间戳原子引用，来这里应用于版本号的更新，也就是每次更新的时候，需要比较期望值和当前值，以及期望版本号和当前版本号</li></ul><p><img src="https://img-blog.csdnimg.cn/20210709201558202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xizi.cas;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ABADemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传递两个值，一个是初始值，一个是初始版本号</span></span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;============以下是ABA问题的解决==========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 获取版本号</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第一次版本号&quot;</span> + stamp);</span><br><span class="line">            <span class="comment">// 暂停t3一秒钟</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 传入4个值，期望值，更新值，期望版本号，更新版本号</span></span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第二次版本号&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第三次版本号&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line">        &#125;, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 获取版本号</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第一次版本号&quot;</span> + stamp);</span><br><span class="line">            <span class="comment">// 暂停t4 3秒钟，保证t3线程也进行一次ABA问题</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>, stamp, stamp+<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 修改成功否：&quot;</span> + result + <span class="string">&quot;\t 当前最新实际版本号：&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 当前实际最新值&quot;</span> + atomicStampedReference.getReference());</span><br><span class="line">        &#125;, <span class="string">&quot;t4&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> Java集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Synchronized---JDK1.8源码分析</title>
      <link href="/2021/08/07/Synchronized/"/>
      <url>/2021/08/07/Synchronized/</url>
      
        <content type="html"><![CDATA[<h1 id="一-Synchronized的特性"><a href="#一-Synchronized的特性" class="headerlink" title="一. Synchronized的特性"></a>一. Synchronized的特性</h1><h2 id="①-原子性"><a href="#①-原子性" class="headerlink" title="①.  原子性"></a>①.  原子性</h2><ul><li>所谓原子性就是指一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</li><li>被synchronized修饰的类或对象的所有操作都是原子的，因为在执行操作之前必须先获得类或对象的锁，直到执行完才能释放，这中间的过程无法被中断（除了已经废弃的stop()方法），即保证了原子性。</li></ul><h2 id="②-可见性"><a href="#②-可见性" class="headerlink" title="②. 可见性"></a>②. 可见性</h2><ul><li>可见性是指多个线程访问一个资源时，该资源的状态、值信息等对于其他线程都是可见的。</li><li>synchronized和volatile都具有可见性，其中synchronized对一个类或对象加锁时，一个线程如果要访问该类或对象必须先获得它的锁，而这个锁的状态对于其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到主存当中，保证资源变量的可见性，如果某个线程占用了该锁，其他线程就必须在锁池中等待锁的释放。</li></ul><h2 id="③-有序性"><a href="#③-有序性" class="headerlink" title="③. 有序性"></a>③. 有序性</h2><ul><li>有序性值程序执行的顺序按照代码先后执行。</li><li>有效解决重排序问题，即 一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作；</li><li>synchronized和volatile都具有有序性，Java允许编译器和处理器对指令进行重排，但是指令重排并不会影响单线程的顺序，它影响的是多线程并发执行的顺序性。synchronized保证了每个时刻都只有一个线程访问同步代码块，也就确定了线程执行同步代码块是分先后顺序的，保证了有序性。</li></ul><h2 id="④-可重入性"><a href="#④-可重入性" class="headerlink" title="④. 可重入性"></a>④. 可重入性</h2><ul><li>Synchronized和ReentrantLock都是可重入锁。</li><li>当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁。通俗一点讲就是说一个线程拥有了锁仍然还可以重复申请锁。</li></ul><h1 id="二-Synchronized的使用"><a href="#二-Synchronized的使用" class="headerlink" title="二. Synchronized的使用"></a>二. Synchronized的使用</h1><h2 id="①-修饰普通方法"><a href="#①-修饰普通方法" class="headerlink" title="①. 修饰普通方法"></a>①. 修饰普通方法</h2><p><img src="https://img-blog.csdnimg.cn/20210517212325180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xizi.SynchronizedTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//共享资源(临界资源)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没有synchronized关键字，输出小于20000</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10000</span>;j++)&#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread1 t=<span class="keyword">new</span> <span class="title class_">Thread1</span>();</span><br><span class="line">        Thread t1=<span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();<span class="comment">//主线程等待t1执行完毕</span></span><br><span class="line">        t2.join();<span class="comment">//主线程等待t2执行完毕</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出结果:</span></span><br><span class="line"><span class="comment">     * 20000</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="②-修饰代码块"><a href="#②-修饰代码块" class="headerlink" title="②. 修饰代码块"></a>②. 修饰代码块</h2><p><img src="https://img-blog.csdnimg.cn/20210517212700604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xizi.SynchronizedTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//共享资源(临界资源)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10000</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Thread1.class)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread1 t=<span class="keyword">new</span> <span class="title class_">Thread1</span>();</span><br><span class="line">        Thread t1=<span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出结果:</span></span><br><span class="line"><span class="comment">     * 20000</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="③-修饰静态方法"><a href="#③-修饰静态方法" class="headerlink" title="③. 修饰静态方法"></a>③. 修饰静态方法</h2><p><img src="https://img-blog.csdnimg.cn/20210517212934684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xizi.SynchronizedTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread1</span> &#123;</span><br><span class="line">    <span class="comment">//共享资源(临界资源)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果没有synchronized关键字，输出小于20000</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    increase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    increase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();<span class="comment">//主线程等待t1执行完毕</span></span><br><span class="line">        t2.join();<span class="comment">//主线程等待t2执行完毕</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出结果:</span></span><br><span class="line"><span class="comment">     * 20000</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>synchronized修饰的实例方法，多线程并发访问时，只能有一个线程进入，获得对象内置锁，其他线程阻塞等待，但在此期间线程仍然可以访问其他方法。</li><li>synchronized修饰的静态方法，多线程并发访问时，只能有一个线程进入，获得类锁，其他线程阻塞等待，但在此期间线程仍然可以访问其他方法。</li><li>synchronized修饰的代码块，多线程并发访问时，只能有一个线程进入，根据括号中的对象或者是类，获得相应的对象内置锁或者是类锁</li></ol><h1 id="三-Synchronized锁原理——反编译分析"><a href="#三-Synchronized锁原理——反编译分析" class="headerlink" title="三. Synchronized锁原理——反编译分析"></a>三. Synchronized锁原理——反编译分析</h1><h2 id="①-同步方法"><a href="#①-同步方法" class="headerlink" title="①. 同步方法"></a>①. 同步方法</h2><h3 id="1-进行javap反编译"><a href="#1-进行javap反编译" class="headerlink" title="1. 进行javap反编译"></a>1. 进行javap反编译</h3><p><img src="https://img-blog.csdnimg.cn/20210517204613365.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;synchronized 方法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size> 进行javap反编译</p></blockquote><p><img src="https://img-blog.csdnimg.cn/2021051720455746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2-ACC-SYNCHRONIZED标志位"><a href="#2-ACC-SYNCHRONIZED标志位" class="headerlink" title="2. ACC_SYNCHRONIZED标志位"></a>2. ACC_SYNCHRONIZED标志位</h3><ul><li>从反编译的结果来看，方法的同步并没有通过指令monitorenter和monitorexit来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。</li><li>JVM就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。 其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。</li></ul><h2 id="②-同步代码块"><a href="#②-同步代码块" class="headerlink" title="②. 同步代码块"></a>②. 同步代码块</h2><p><img src="https://img-blog.csdnimg.cn/20210517204158140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//同步代码块</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized 代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-进行javap反编译-1"><a href="#1-进行javap反编译-1" class="headerlink" title="1. 进行javap反编译"></a>1. 进行javap反编译</h3><blockquote><p><font color='red' size> 进行javap反编译</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210517204124457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70"></p><h3 id="2-monitorenter进入指令"><a href="#2-monitorenter进入指令" class="headerlink" title="2. monitorenter进入指令"></a>2. monitorenter进入指令</h3><blockquote><p><font color='red' size=4><strong>monitorenter</strong>：每个对象都是一个监视器锁（monitor）。</p></blockquote><ul><li>当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</li></ul><ol><li>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；</li><li>如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1；</li><li>如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权；</li></ol><h3 id="3-monitorexit退出指令"><a href="#3-monitorexit退出指令" class="headerlink" title="3. monitorexit退出指令"></a>3. monitorexit退出指令</h3><blockquote><p><font color='red' size=4><strong>monitorexit</strong></p></blockquote><ul><li><p>monitorexit：执行monitorexit的线程必须是objectref所对应的monitor的所有者。</p></li><li><p>指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。</p></li><li><p>上面monitorexit指令出现了两次，第1次为同步正常退出释放锁；第2次为发生异步退出释放锁；</p></li></ul><h1 id="四-JVM对Synchronized的优化"><a href="#四-JVM对Synchronized的优化" class="headerlink" title="四. JVM对Synchronized的优化"></a>四. JVM对Synchronized的优化</h1><h2 id="①-对象头存储布局"><a href="#①-对象头存储布局" class="headerlink" title="①. 对象头存储布局"></a>①. 对象头存储布局</h2><blockquote><p><font color='red' size=3> 在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据、对其填充。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210517211008740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>实例数据：存放类的属性数据信息，包括父类的属性信息；</li><li>对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐；</li><li>对象头：Java对象头一般占有2个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit，在64位虚拟机中，1个机器码是8个字节，也就是64bit），但是 如果对象是数组类型，则需要3个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。</li></ul><blockquote><p><font color='red' size=4> Java对象头具体结构描述</p></blockquote><ul><li>Synchronized用的锁就是存在Java对象头里的，对象头主要包括两部分数据：Mark Word（标记字段）、Class Pointer（类型指针）。其中 Class Pointer是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，Mark Word用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/d49dc0285cbd2c365f862133230d14ab.png" alt="在这里插入图片描述"></p><h2 id="②-Java对象头结构组成"><a href="#②-Java对象头结构组成" class="headerlink" title="②. Java对象头结构组成"></a>②. Java对象头结构组成</h2><blockquote><p><font color='red' size=4> Java对象头结构组成</p></blockquote><ul><li>Mark Word用于存储对象自身的运行时数据，如：哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。</li><li>下图是Java对象头 无锁状态下Mark Word部分的存储结构（32位虚拟机）：<br><img src="https://img-blog.csdnimg.cn/img_convert/beb4a8024a5d2dbebe65a91a38b5860d.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/img_convert/2f9d7ad8d0767709d79ae633ef74e69c.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/7e72b7eb11911fcee2b21a51c66e4a3f.png" alt="在这里插入图片描述"></li></ul><h2 id="③-对象头中Mark-Word与线程中Lock-Record"><a href="#③-对象头中Mark-Word与线程中Lock-Record" class="headerlink" title="③. 对象头中Mark Word与线程中Lock Record"></a>③. 对象头中Mark Word与线程中Lock Record</h2><ul><li>Lock Record是线程私有的数据结构，每一个线程都有一个可用Lock Record列表，同时还有一个全局的可用列表。</li><li>每一个被锁住的对象Mark Word都会和一个Lock Record关联（对象头的MarkWord中的Lock Word指向Lock Record的起始地址），同时Lock Record中有一个Owner字段存放拥有该锁的线程的唯一标识（或者object mark word），表示该锁被这个线程占用。</li></ul><blockquote><p><font color='red' size=4> Lock Record的内部结构：</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/325aa8a8bb1ccbba15fb5260d43e1f79.png" alt="在这里插入图片描述"></p><h2 id="④-监视器（Monitor）"><a href="#④-监视器（Monitor）" class="headerlink" title="④. 监视器（Monitor）"></a>④. 监视器（Monitor）</h2><ul><li><p>任何一个对象都有一个Monitor与之关联，当且一个Monitor被持有后，它将处于锁定状态。Synchronized在JVM里的实现都是 基于进入和退出Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。</p></li><li><p>MonitorEnter指令：插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁；</p></li><li><p>MonitorExit指令：插入在方法结束处和异常处，JVM保证每个MonitorEnter必须有对应的MonitorExit；</p></li></ul><h2 id="⑤-锁优化"><a href="#⑤-锁优化" class="headerlink" title="⑤. 锁优化"></a>⑤. 锁优化</h2><ul><li>JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</li><li>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁。但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。</li><li>在 JDK 1.6 中默认是开启偏向锁和轻量级锁的，可以通过-XX:-UseBiasedLocking来禁用偏向锁。</li></ul><h3 id="1-自旋锁"><a href="#1-自旋锁" class="headerlink" title="1. 自旋锁"></a>1. 自旋锁</h3><ul><li><p>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。</p></li><li><p>所以引入自旋锁，何谓自旋锁？ </p></li><li><p>所谓自旋锁，就是指当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检测锁是否被释放，而不是进入线程挂起或睡眠状态。</p></li><li><p>自旋锁适用于锁保护的临界区很小的情况，临界区很小的话，锁占用的时间就很短。自旋等待不能替代阻塞，虽然它可以避免线程切换带来的开销，但是它占用了CPU处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。</p></li><li><p>自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用-XX:+UseSpinning开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整。</p></li><li><p>如果通过参数-XX:PreBlockSpin来调整自旋锁的自旋次数，会带来诸多不便。假如将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如多自旋一两次就可以获取锁），是不是很尴尬。于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明。</p></li></ul><h3 id="2-适应性自旋锁"><a href="#2-适应性自旋锁" class="headerlink" title="2. 适应性自旋锁"></a>2. 适应性自旋锁</h3><ul><li>JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。那它如何进行适应性自旋呢？ </li><li>线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</li></ul><h3 id="3-锁消除"><a href="#3-锁消除" class="headerlink" title="3. 锁消除"></a>3. 锁消除</h3><ul><li>为了保证数据的完整性，在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。</li><li>如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于程序员来说这还不清楚么？在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？虽然没有显示使用锁，但是在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作。比如StringBuffer的append()方法，Vector的add()方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">vectorTest</span><span class="params">()</span>&#123;</span><br><span class="line">    Vector&lt;String&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">        vector.add(i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(vector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在运行这段代码时，JVM可以明显检测到变量vector没有逃逸出方法vectorTest()之外，所以JVM可以大胆地将vector内部的加锁操作消除。</li></ul><h3 id="4-锁粗化"><a href="#4-锁粗化" class="headerlink" title="4. 锁粗化"></a>4. 锁粗化</h3><ul><li>如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。</li><li>锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。</li><li>vector每次add的时候都需要加锁操作，JVM检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外。</li></ul><h3 id="5-偏向锁"><a href="#5-偏向锁" class="headerlink" title="5. 偏向锁"></a>5. 偏向锁</h3><ul><li>偏向锁是JDK6中的重要引进，因为HotSpot作者经过研究实践发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，引进了偏向锁。</li></ul><blockquote><p><font color='red' >偏向锁是在单线程执行代码块时使用的机制，如果在多线程并发的环境下（即线程A尚未执行完同步代码块，线程B发起了申请锁的申请），则一定会转化为轻量级锁或者重量级锁。</p></blockquote><ul><li>在JDK5中偏向锁默认是关闭的，而到了JDK6中偏向锁已经默认开启。如果并发数较大同时同步代码块执行时间较长，则被多个线程同时访问的概率就很大，就可以使用参数-XX:-UseBiasedLocking来禁止偏向锁(但这是个JVM参数，不能针对某个对象锁来单独设置)。</li><li>引入偏向锁主要目的是：为了在没有多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。因为轻量级锁的加锁解锁操作是需要依赖多次CAS原子指令的，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗也必须小于节省下来的CAS原子指令的性能消耗）。</li></ul><blockquote><p><font color='red' > 轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</p></blockquote><blockquote><p><font color='red'  size=4>偏向锁的获取 处理流程如下：</p></blockquote><ul><li>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程进入和退出同步块时不需要花费CAS操作来争夺锁资源，只需要检查是否为偏向锁、锁标识为以及ThreadID即可</li></ul><ol><li>检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；</li><li>若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）；</li><li>如果测试线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）；</li><li>通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；</li><li>执行同步代码块；</li></ol><blockquote><p><font color='red'  size=4>偏向锁的释放 处理流程如下：</p></blockquote><ul><li>偏向锁的释放采用了 一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要 等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：</li></ul><ol><li>暂停拥有偏向锁的线程；</li><li>判断锁对象是否还处于被锁定状态，否，则恢复到无锁状态（01），以允许其余线程竞争。是，则挂起持有锁的当前线程，并将指向当前线程的锁记录地址的指针放入对象头Mark Word，升级为轻量级锁状态（00），然后恢复持有锁的当前线程，进入轻量级锁的竞争模式；</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/8dce1a573822afd1065c26f56ecf9720.png" alt="在这里插入图片描述"></p><h3 id="6-轻量级锁"><a href="#6-轻量级锁" class="headerlink" title="6. 轻量级锁"></a>6. 轻量级锁</h3><blockquote><p><font color='red'  size=4> 轻量级锁获取过程</p></blockquote><ul><li>引入轻量级锁的主要目的是 在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步骤如下：</li></ul><ol><li><p>在线程进入同步块时，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。此时线程堆栈与对象头的状态如下图所示：<br>  <img src="https://img-blog.csdnimg.cn/img_convert/e08e370085acbafed55262daffa78247.png" alt="在这里插入图片描述"></p></li><li><p>拷贝对象头中的Mark Word复制到锁记录（Lock Record）中；</p></li><li><p>拷贝成功后，虚拟机将使用CAS操作尝试将对象Mark Word中的Lock Word更新为指向当前线程Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤（4），否则执行步骤（5）；</p></li><li><p>如果这个更新动作成功了，那么当前线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态，此时线程堆栈与对象头的状态如下图所示</p></li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/bfed138d4e519a2c510c942ee3274237.png" alt="在这里插入图片描述"><br>5. 如果这个更新操作失败了，虚拟机首先会检查对象Mark Word中的Lock Word是否指向当前线程的栈帧，如果是，就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，进入自旋执行（3），若自旋结束时仍未获得锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，当前线程以及后面等待锁的线程也要进入阻塞状态。</p><blockquote><p><font color='red'  size=4> 轻量级锁释放过程 </p></blockquote><ul><li>轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：</li></ul><ol><li>通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word；</li><li>如果替换成功，整个同步过程就完成了，恢复到无锁状态（01）；</li><li>如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），那就要在释放锁的同时，唤醒被挂起的线程。</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/63790cf7b52954cbe7b50738ca78c1ea.png" alt="在这里插入图片描述"></p><ul><li>此处，如何理解“轻量级”？“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。</li></ul><blockquote><p><font color='red' > 轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，必然就会导致轻量级锁膨胀为重量级锁。</p></blockquote><h3 id="7-重量级锁"><a href="#7-重量级锁" class="headerlink" title="7. 重量级锁"></a>7. 重量级锁</h3><ul><li><font color='red' >Synchronized是通过对象内部的一个叫做 监视器锁（Monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为 “重量级锁”。</li></ul><h3 id="8-重量级锁、轻量级锁和偏向锁之间转换"><a href="#8-重量级锁、轻量级锁和偏向锁之间转换" class="headerlink" title="8. 重量级锁、轻量级锁和偏向锁之间转换"></a>8. 重量级锁、轻量级锁和偏向锁之间转换</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/7e6896eee12083c647782c16e0d04d67.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/2c180a58045ee0b2c28c369a0918a952.png" alt="在这里插入图片描述"></p><h3 id="9-锁的优劣"><a href="#9-锁的优劣" class="headerlink" title="9. 锁的优劣"></a>9. 锁的优劣</h3><ul><li>各种锁并不是相互代替的，而是在不同场景下的不同选择，绝对不是说重量级锁就是不合适的。每种锁是只能升级，不能降级，即由偏向锁-&gt;轻量级锁-&gt;重量级锁，而这个过程就是开销逐渐加大的过程。<br><img src="https://img-blog.csdnimg.cn/img_convert/67e2d2988878d0033b1377dfda36774e.png" alt="在这里插入图片描述"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayBlockingQueue-JDK1.8源码分析</title>
      <link href="/2021/08/07/ArrayBlockingQueue/"/>
      <url>/2021/08/07/ArrayBlockingQueue/</url>
      
        <content type="html"><![CDATA[<h1 id="一-ArrayBlockingQueue介绍"><a href="#一-ArrayBlockingQueue介绍" class="headerlink" title="一. ArrayBlockingQueue介绍"></a>一. ArrayBlockingQueue介绍</h1><ul><li>ArrayBlockingQueue是一个基于用数组实现的有界阻塞队列。此队列按照先进先出的原则对元素进行排序</li></ul><h1 id="二-ArrayBlockingQueue数据结构"><a href="#二-ArrayBlockingQueue数据结构" class="headerlink" title="二. ArrayBlockingQueue数据结构"></a>二. ArrayBlockingQueue数据结构</h1><ul><li>ArrayBlockingQueue的底层数据结构是数组，数据结构如下:</li></ul><p><img src="https://img-blog.csdnimg.cn/20210719211605423.png" alt="在这里插入图片描述"></p><ul><li>ArrayBlockingQueue底层采用数据才存放数据，对数组的访问添加了锁的机制，使其能够支持多线程并发。</li></ul><h1 id="三-ArrayBlockingQueue源码分析"><a href="#三-ArrayBlockingQueue源码分析" class="headerlink" title="三. ArrayBlockingQueue源码分析"></a>三. ArrayBlockingQueue源码分析</h1><h2 id="①-类的继承关系"><a href="#①-类的继承关系" class="headerlink" title="①. 类的继承关系"></a>①. 类的继承关系</h2><p><img src="https://img-blog.csdnimg.cn/20210719212210360.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayBlockingQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>ArrayBlockingQueue继承了AbstractQueue抽象类，AbstractQueue定义了对队列的基本操作；同时实现了BlockingQueue接口，BlockingQueue表示阻塞型的队列，其对队列的操作可能会抛出异常；同时也实现了Searializable接口，表示可以被序列化。</li></ul><h2 id="②-类的属性"><a href="#②-类的属性" class="headerlink" title="②. 类的属性"></a>②. 类的属性</h2><ul><li>从类的属性中可以清楚的看到其底层的结构是Object类型的数组，取元素和存元素有不同的索引，有一个可重入锁ReentrantLock，两个条件Condition。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210719212646370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">817911632652898426L</span>;</span><br><span class="line">    <span class="comment">// 存放实际元素的数组</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items;</span><br><span class="line">    <span class="comment">// 取元素索引</span></span><br><span class="line">    <span class="type">int</span> takeIndex;</span><br><span class="line">    <span class="comment">// 获取元素索引</span></span><br><span class="line">    <span class="type">int</span> putIndex;</span><br><span class="line">    <span class="comment">// 队列中的项</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">    <span class="comment">// 等待获取条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">    <span class="comment">// 等待存放条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">Itrs</span> <span class="variable">itrs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h2 id="③-类的构造函数"><a href="#③-类的构造函数" class="headerlink" title="③. 类的构造函数"></a>③. 类的构造函数</h2><p><img src="https://img-blog.csdnimg.cn/20210719212757411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用两个参数的构造函数</span></span><br><span class="line">    <span class="built_in">this</span>(capacity, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始容量必须大于0</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="comment">// 初始化数组</span></span><br><span class="line">    <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">    <span class="comment">// 初始化可重入锁</span></span><br><span class="line">    lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(fair);</span><br><span class="line">    <span class="comment">// 初始化等待条件</span></span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用两个参数的构造函数</span></span><br><span class="line">    <span class="built_in">this</span>(capacity, fair);</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 上锁</span></span><br><span class="line">    lock.lock(); <span class="comment">// Lock only for visibility, not mutual exclusion</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (E e : c) &#123; <span class="comment">// 遍历集合</span></span><br><span class="line">                <span class="comment">// 检查元素是否为空</span></span><br><span class="line">                checkNotNull(e);</span><br><span class="line">                <span class="comment">// 存入ArrayBlockingQueue中</span></span><br><span class="line">                items[i++] = e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当初始化容量小于传入集合的大小时，会抛出异常</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 元素数量</span></span><br><span class="line">        count = i;</span><br><span class="line">        <span class="comment">// 初始化存元素的索引</span></span><br><span class="line">        putIndex = (i == capacity) ? <span class="number">0</span> : i;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="④-put-方法"><a href="#④-put-方法" class="headerlink" title="④. put()方法"></a>④. put()方法</h2><ul><li><ul><li>put函数用于存放元素，在当前线程被中断时会抛出异常，并且当队列已经满时，会阻塞一直等待。其中，put会调用enqueue函数<br><img src="https://img-blog.csdnimg.cn/20210719213145808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">// 获取可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 如果当前线程未被中断，则获取锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)<span class="comment">// 判断元素是否已满</span></span><br><span class="line">            <span class="comment">// 若满，则等待</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        <span class="comment">// 入队列</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="④-enqueue-方法"><a href="#④-enqueue-方法" class="headerlink" title="④. enqueue() 方法"></a>④. enqueue() 方法</h2><ul><li>enqueue函数用于将元素存入底层Object数组中，并且会唤醒等待notEmpty条件的线程。<br><img src="https://img-blog.csdnimg.cn/20210719213400920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(E x)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取数组</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">    <span class="comment">// 将元素放入</span></span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)<span class="comment">// 放入后存元素的索引等于数组长度（表示已满）</span></span><br><span class="line">        <span class="comment">// 重置存索引为0</span></span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 元素数量加1</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">// 唤醒在notEmpty条件上等待的线程</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑤-offer-方法"><a href="#⑤-offer-方法" class="headerlink" title="⑤. offer()方法"></a>⑤. offer()方法</h2><ul><li>offer函数也用于存放元素，在调用ArrayBlockingQueue的add方法时，会间接的调用到offer函数，offer函数添加元素不会抛出异常，当底层Object数组已满时，则返回false，否则，会调用enqueue函数，将元素存入底层Object数组。并唤醒等待notEmpty条件的线程。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查元素不能为空</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == items.length) <span class="comment">// 元素个数等于数组长度，则返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 添加进数组</span></span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放数组</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20210719213642567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="⑥-add-方法"><a href="#⑥-add-方法" class="headerlink" title="⑥. add()方法"></a>⑥. add()方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.add(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210719213804456.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (offer(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210719213901242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="⑦-poll-方法"><a href="#⑦-poll-方法" class="headerlink" title="⑦. poll()方法"></a>⑦. poll()方法</h2><ul><li>poll函数用于获取元素，其与offer函数相对应，不会抛出异常，当元素个数为0是，返回null，否则，调用dequeue函数，并唤醒等待notFull条件的线程。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210719214048513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 重入锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 若元素个数为0则返回null，否则，调用dequeue，出队列</span></span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="literal">null</span> : dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑦-dequeue-方法"><a href="#⑦-dequeue-方法" class="headerlink" title="⑦. dequeue() 方法"></a>⑦. dequeue() 方法</h2><ul><li>dequeue函数用于将取元素，并且会唤醒等待notFull条件的线程</li></ul><p><img src="https://img-blog.csdnimg.cn/20210719214123600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">     <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">     <span class="comment">// 取元素</span></span><br><span class="line">     <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> (E) items[takeIndex];</span><br><span class="line">     <span class="comment">// 该索引的值赋值为null</span></span><br><span class="line">     items[takeIndex] = <span class="literal">null</span>;</span><br><span class="line">     <span class="comment">// 取值索引等于数组长度</span></span><br><span class="line">     <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">         <span class="comment">// 重新赋值取值索引</span></span><br><span class="line">         takeIndex = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">// 元素个数减1</span></span><br><span class="line">     count--;</span><br><span class="line">     <span class="keyword">if</span> (itrs != <span class="literal">null</span>)</span><br><span class="line">         itrs.elementDequeued();</span><br><span class="line">     <span class="comment">// 唤醒在notFull条件上等待的线程</span></span><br><span class="line">     notFull.signal();</span><br><span class="line">     <span class="keyword">return</span> x;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="⑧-take-方法"><a href="#⑧-take-方法" class="headerlink" title="⑧. take()方法"></a>⑧. take()方法</h2><ul><li>take函数用于从ArrayBlockingQueue中获取一个元素，其与put函数相对应，在当前线程被中断时会抛出异常，并且当队列为空时，会阻塞一直等待。其中，take会调用dequeue函数</li></ul><p><img src="https://img-blog.csdnimg.cn/20210719214310223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 如果当前线程未被中断，则获取锁，中断会抛出异常</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)<span class="comment">// 元素数量为0，即Object数组为空</span></span><br><span class="line">            <span class="comment">// 则等待notEmpty条件</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="comment">// 出队列</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑨-remove-方法"><a href="#⑨-remove-方法" class="headerlink" title="⑨. remove()方法"></a>⑨. remove()方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> poll();</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210719214001184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="⑩-clear-方法"><a href="#⑩-clear-方法" class="headerlink" title="⑩. clear() 方法"></a>⑩. clear() 方法</h2><ul><li>clear函数用于清空ArrayBlockingQueue，并且会释放所有等待notFull条件的线程（存放元素的线程）</li></ul><p><img src="https://img-blog.csdnimg.cn/20210719214720952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 数组</span></span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">        <span class="comment">// 可重入锁</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 保存元素个数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> count;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span>) &#123; <span class="comment">// 元素个数大于0</span></span><br><span class="line">                <span class="comment">// 存数元素索引</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">putIndex</span> <span class="operator">=</span> <span class="built_in">this</span>.putIndex;</span><br><span class="line">                <span class="comment">// 取元素索引</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> takeIndex;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">// 赋值为null</span></span><br><span class="line">                    items[i] = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (++i == items.length) <span class="comment">// 重新赋值i</span></span><br><span class="line">                        i = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">while</span> (i != putIndex);</span><br><span class="line">                <span class="comment">// 重新赋值取元素索引</span></span><br><span class="line">                takeIndex = putIndex;</span><br><span class="line">                <span class="comment">// 元素个数为0</span></span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (itrs != <span class="literal">null</span>)</span><br><span class="line">                    itrs.queueIsEmpty();</span><br><span class="line">                <span class="keyword">for</span> (; k &gt; <span class="number">0</span> &amp;&amp; lock.hasWaiters(notFull); k--) <span class="comment">// 若有等待notFull条件的线程，则逐一唤醒</span></span><br><span class="line">                    notFull.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="四-ArrayBlockingQueue方法总结"><a href="#四-ArrayBlockingQueue方法总结" class="headerlink" title="四. ArrayBlockingQueue方法总结"></a>四. ArrayBlockingQueue方法总结</h1><p><img src="https://img-blog.csdnimg.cn/20210719212323833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>抛出异常：当队列满时，再向队列中插入元素，则会抛出IllegalStateException异常。当队列空时，再向队列中获取元素，则会抛出NoSuchElementException异常。</li><li>返回特殊值：当队列满时，向队列中添加元素，则返回false，否则返回true。当队列为空时，向队列中获取元素，则返回null，否则返回元素。</li><li>一直阻塞：当阻塞队列满时，如果生产者向队列中插入元素，则队列会一直阻塞当前线程，直到队列可用或响应中断退出。当阻塞队列为空时，如果消费者线程向阻塞队列中获取数据，则队列会一直阻塞当前线程，直到队列空闲或响应中断退出。</li><li>超时退出：当队列满时，如果生产线程向队列中添加元素，则队列会阻塞生产线程一段时间，超过指定的时间则退出返回false。当队列为空时，消费线程从队列中移除元素，则队列会阻塞一段时间，如果超过指定时间退出返回null。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AbstractQueuedSynchronizer---JDK1.8源码分析</title>
      <link href="/2021/05/16/AQS/"/>
      <url>/2021/05/16/AQS/</url>
      
        <content type="html"><![CDATA[<h1 id="一-AQS相关知识点"><a href="#一-AQS相关知识点" class="headerlink" title="一. AQS相关知识点"></a>一. AQS相关知识点</h1><blockquote><p><font color='red'  size=3>AQS底层其实就是队列，AQS的核心代码其实就是acquire和release函数，分别有独占模式和共享模式两种，我们开发自定义同步组件只需要重写tryAcquire和tryRelease方法等即可</p></blockquote><h2 id="①-AQS介绍"><a href="#①-AQS介绍" class="headerlink" title="①. AQS介绍"></a>①. AQS介绍</h2><blockquote><p><font color='blue'  size=4>AQS 是一个用于构建锁、同步器等线程协作工具类的框架1</p></blockquote><ul><li><p>AQS(AbstractQueuedSynchronizer)，AQS是JDK下提供的一套用于实现基于FIFO等待队列的阻塞锁和相关的同步器的一个同步框架。这个抽象类被设计为作为一些可用原子int值来表示状态的同步器的基类。</p></li><li><p>ReentrantLock，ReentrantReadWriteLock，CountDownLatch，CyclicBarrier，Semaphore等都是基于AQS来实现的。</p></li><li><p>AQS通过内置FIFO同步队列来完成资源获取线程的排队工作，如果当前线程获取同步状态失败（即获取锁失败）AQS则会将当前线程以及等待状态等信息构成一个节点（Node）并将其加如同步队列，同时会阻塞当前线程，当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。</p></li></ul><h2 id="②-AQS核心思想"><a href="#②-AQS核心思想" class="headerlink" title="②. AQS核心思想"></a>②. AQS核心思想</h2><ul><li>AQS的核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</li></ul><h2 id="②-实现方式："><a href="#②-实现方式：" class="headerlink" title="②. 实现方式："></a>②. 实现方式：</h2><ul><li>一般是通过一个内部类Sync继承AQS，然后将同步器所有调用都映射到Sync对应的方法.<br>Sync相当于队列的实现，各种锁通过内部类Sync和Node来完成AQS逻辑QS实现方式</li></ul><h2 id="③-CLH—-同步队列"><a href="#③-CLH—-同步队列" class="headerlink" title="③. CLH— 同步队列"></a>③. CLH— 同步队列</h2><ul><li>CLH 同步队列是一个 FIFO 双向队列，AQS 依赖它来完成同步状态的管理：</li></ul><ul><li>当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程</li><li>当同步状态释放时，会把首节点唤醒，使其再次尝试获取同步状态。<blockquote><p><font color='red' >入队操作</p></blockquote></li></ul><ul><li>通过“自旋”也就是死循环的方式来保证该节点能顺利的加入到队列尾部，只有加入成功才会退出循环，否则会一直循序直到成功。</li></ul><blockquote><p><font color='red' >出队操作</p></blockquote><ul><li>同步队列（CLH）遵循FIFO，首节点是获取同步状态的节点，首节点的线程释放同步状态后，将会唤醒它的后继节点（next），而后继节点将会在获取同步状态成功时将自己设置为首节</li></ul><p><img src="https://img-blog.csdnimg.cn/20210506194400605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="二-AQS源码分析"><a href="#二-AQS源码分析" class="headerlink" title="二. AQS源码分析"></a>二. AQS源码分析</h1><h2 id="①-state状态"><a href="#①-state状态" class="headerlink" title="①. state状态"></a>①. state状态</h2><ul><li>AQS使用一个int类型的成员变量<strong>state</strong>来表示同步状态</li><li>当state&gt;0时表示已经获取了锁，当state&#x3D;0时表示释放了锁</li><li>它提供了三个方法getState()、setState(int newState)、compareAndSetState(int expect,int update)）来对同步状态state进行操作</li></ul><p><img src="https://img-blog.csdnimg.cn/20210506191231125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//锁状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取锁的状态</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置状态</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CAS改变状态</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="②-AQS类中的Node类"><a href="#②-AQS类中的Node类" class="headerlink" title="②. AQS类中的Node类"></a>②. AQS类中的Node类</h2><p><img src="https://img-blog.csdnimg.cn/20210506191155243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AQS类里有一个Node类，对线程进行了封装</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">      <span class="comment">// 共享模式下等待的标记</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">      <span class="comment">// 独占模式下等待的标记</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 线程的等待状态 表示节点已被取消 由于超时或中断此节点被取消 取消节点的线程不会阻塞</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 线程的等待状态 表示节点需要被唤醒 挂起状态 等待被唤醒 一般是获取失败后线程被挂起的节点</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 线程的等待状态 表示线程正在等待条件 此节点当前在条件队列中 不会用于同步队列 转到同步队列时状态值会改为0</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">      <span class="comment">// 表示下一个acquireShared需要无条件的传播 仅适用于头部节点</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//等待的状态</span></span><br><span class="line">      <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">      <span class="comment">//前一个节点</span></span><br><span class="line">      <span class="keyword">volatile</span> Node prev;</span><br><span class="line">      <span class="comment">//下一个节点</span></span><br><span class="line">      <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//当前节点的线程,初始化后使用,在使用后失效</span></span><br><span class="line">      <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 链接到等在等待条件上的下一个节点,或特殊的值SHARED,因为条件队列只有在独占模式时才能被访问,</span></span><br><span class="line"><span class="comment">       * 所以我们只需要一个简单的连接队列在等待的时候保存节点,然后把它们转移到队列中重新获取</span></span><br><span class="line"><span class="comment">       * 因为条件只能是独占性的,我们通过使用特殊的值来表示共享模式</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      Node nextWaiter;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果节点处于共享模式下等待直接返回true</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="type">return</span> <span class="variable">nextWaiter</span> <span class="operator">=</span>= SHARED;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//返回当前节点的前驱节点,如果为空,直接抛出空指针异常</span></span><br><span class="line">      <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">          <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">          <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 用来建立初始化的head 或 SHARED的标记</span></span><br><span class="line">      Node() &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 指定线程和模式的构造方法</span></span><br><span class="line">      Node(Thread thread, Node mode) &#123;</span><br><span class="line">          <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">          <span class="built_in">this</span>.thread = thread;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 指定线程和节点状态的构造方法</span></span><br><span class="line">      Node(Thread thread, <span class="type">int</span> waitStatus) &#123;</span><br><span class="line">          <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">          <span class="built_in">this</span>.thread = thread;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="③-获取独占锁acquire"><a href="#③-获取独占锁acquire" class="headerlink" title="③. 获取独占锁acquire()"></a>③. 获取独占锁acquire()</h2><p><img src="https://img-blog.csdnimg.cn/2021050619162156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取独占锁</span></span><br><span class="line"><span class="comment">//  1. 根据if短路，当获取锁成功后就不执行后续代码</span></span><br><span class="line"><span class="comment">//  2. 获取锁失败，先通过addWaiter方法将创建一个独占线程节点，加入阻塞队列</span></span><br><span class="line"><span class="comment">//  3. 然后让阻塞队列中的所有线程都自旋方式来获取锁</span></span><br><span class="line"><span class="comment">//  4. 如果获取锁失败，并且加入队列失败，或者超时等，会进入if体，中断自己</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//通过tryAcquire获取锁，如果成功获取到锁直接终止(selfInterrupt),否则将当前线程插入队列</span></span><br><span class="line">    <span class="comment">//这里的Node.EXCLUSIVE表示创建一个独占模式的节点</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        <span class="comment">//自我中断</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="④-addWaiter-Node-添加元素到阻塞队列中"><a href="#④-addWaiter-Node-添加元素到阻塞队列中" class="headerlink" title="④.  addWaiter(Node) 添加元素到阻塞队列中"></a>④.  addWaiter(Node) 添加元素到阻塞队列中</h2><p><img src="https://img-blog.csdnimg.cn/20210506191938236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="comment">//当前线程和模式 包装为一个node</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">//获取当前队列尾部</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="comment">//如果尾节点不为空</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">//CAS操作进行一次快速insert操作，如果成功就返回</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果添加失败，enq这里会做自旋操作，直到插入成功。</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑤-enq-自旋操作添加元素"><a href="#⑤-enq-自旋操作添加元素" class="headerlink" title="⑤. enq() 自旋操作添加元素"></a>⑤. enq() 自旋操作添加元素</h2><p><img src="https://img-blog.csdnimg.cn/20210506192156325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自旋操作添加元素到队列尾部</span></span><br><span class="line">   <span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">       <span class="comment">//无限循环</span></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="comment">//获取尾节点</span></span><br><span class="line">           <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">           <span class="comment">//如果尾节点为空，说明当前队列是空，需要初始化队列 随便加一个</span></span><br><span class="line">           <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">//初始化当前队列</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                   tail = head;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//否则通过CAS操作插入Node，设置Node为队列的尾节点，并返回Node</span></span><br><span class="line">               node.prev = t;</span><br><span class="line">               <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                   t.next = node;</span><br><span class="line">                   <span class="keyword">return</span> t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="⑥-acquireQueued-尝试获取锁"><a href="#⑥-acquireQueued-尝试获取锁" class="headerlink" title="⑥. acquireQueued() 尝试获取锁"></a>⑥. acquireQueued() 尝试获取锁</h2><p><img src="https://img-blog.csdnimg.cn/20210506192259681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果插入的节点前面是head,尝试获取锁，</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">       <span class="comment">//是否失败</span></span><br><span class="line">       <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//是否中断</span></span><br><span class="line">           <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">           <span class="comment">//自旋操作 会一直尝试</span></span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="comment">//获取当前插入节点的前置节点</span></span><br><span class="line">               <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">               <span class="comment">//前置节点是head，尝试获取锁</span></span><br><span class="line">               <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                   <span class="comment">//设置head为当前节点，表示获取锁成功</span></span><br><span class="line">                   setHead(node);</span><br><span class="line">                   p.next = <span class="literal">null</span>;</span><br><span class="line">                   failed = <span class="literal">false</span>;</span><br><span class="line">                   <span class="keyword">return</span> interrupted;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//是否挂起当前线程，如果是，则挂起线程</span></span><br><span class="line">               <span class="comment">//park（阻塞）是通过unsafe包来实现的，native方法</span></span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;parkAndCheckInterrupt())</span><br><span class="line">                   <span class="comment">//在park中出现中断，会执行到此，但是不会响应中断</span></span><br><span class="line">                   interrupted = <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//线程中断，需要取消获取锁</span></span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="⑦-shouldParkAfterFailedAcquire-判断失败获取后是否可以挂起当前线程"><a href="#⑦-shouldParkAfterFailedAcquire-判断失败获取后是否可以挂起当前线程" class="headerlink" title="⑦. shouldParkAfterFailedAcquire() 判断失败获取后是否可以挂起当前线程"></a>⑦. shouldParkAfterFailedAcquire() 判断失败获取后是否可以挂起当前线程</h2><p><img src="https://img-blog.csdnimg.cn/20210506192505969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断失败获取后是否可以挂起当前线程</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">       <span class="comment">//ws为node前置节点的状态</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">       <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">           <span class="comment">//如果前置节点状态为SIGNAL，当前节点可以挂起</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//ws&gt;0  只有CANCELLED =1 前驱状态是取消</span></span><br><span class="line">           <span class="comment">//通过循环跳过所有的CANCELLED节点，找到一个正常的节点，将当前节点排在它后面</span></span><br><span class="line">           <span class="comment">//GC会将这些CANCELLED节点回收</span></span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               node.prev = pred = pred.prev;</span><br><span class="line">           &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">           pred.next = node;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//若ws&lt;=0 前驱状态正常 将前置节点的状态修改为SIGNAL</span></span><br><span class="line">           compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="⑧-parkAndCheckInterrupt-通过LockSupport挂起线程，等待唤醒"><a href="#⑧-parkAndCheckInterrupt-通过LockSupport挂起线程，等待唤醒" class="headerlink" title="⑧. parkAndCheckInterrupt()通过LockSupport挂起线程，等待唤醒"></a>⑧. parkAndCheckInterrupt()通过LockSupport挂起线程，等待唤醒</h2><p><img src="https://img-blog.csdnimg.cn/2021050619262731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过LockSupport挂起线程，等待唤醒 停顿并检查中断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑨-release-释放独占锁"><a href="#⑨-release-释放独占锁" class="headerlink" title="⑨.release() 释放独占锁"></a>⑨.release() 释放独占锁</h2><ul><li>它会释放指定量的资源，如果彻底释放了（即state&#x3D;0）,它会唤醒等待队列里的其他线程来获取资源</li></ul><p><img src="https://img-blog.csdnimg.cn/20210506192826115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放独占锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//尝试释放锁，这里tryRelease同样由子类实现，如果失败直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123; <span class="comment">//如果尝试释放锁成功</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//唤醒头结点的后继节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑩-unparkSuccessor-来释放并唤醒下一个节点"><a href="#⑩-unparkSuccessor-来释放并唤醒下一个节点" class="headerlink" title="⑩.  unparkSuccessor()来释放并唤醒下一个节点"></a>⑩.  unparkSuccessor()来释放并唤醒下一个节点</h2><p><img src="https://img-blog.csdnimg.cn/2021050619294748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unparkSuccessor来释放并唤醒下一个节点</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">       <span class="comment">//node一般为当前线程所在的节点</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">       <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="comment">//ws的状态&lt;0  CAS修改头节点状态修改为0</span></span><br><span class="line">           compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">       <span class="comment">// 状态值 &gt;0 只有取消状态Cancal</span></span><br><span class="line">       <span class="comment">//从队列里找出下一个需要唤醒的节点s</span></span><br><span class="line">       <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">       <span class="comment">//如果直接后继为空或者它的waitStatus大于0(已经放弃获取锁了)，我们就遍历整个队列，</span></span><br><span class="line">       <span class="comment">//获取第一个需要唤醒的节点</span></span><br><span class="line">       <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           s = <span class="literal">null</span>;</span><br><span class="line">           <span class="comment">//从tail开始倒着找，直到node停止</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">               <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) <span class="comment">//&lt;=0的节点 都是有效节点</span></span><br><span class="line">                   s = t;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">           <span class="comment">//唤醒找到的符合条件的节点</span></span><br><span class="line">           LockSupport.unpark(s.thread);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="11-AQS的流程"><a href="#11-AQS的流程" class="headerlink" title="11. AQS的流程"></a>11. AQS的流程</h2><blockquote><p><font color='red'>获取锁</p></blockquote><ol><li>tryAcquire()尝试直接去获取资源，如果成功则直接返回（这里体现了非公平锁，每个线程获取锁时会尝试直接抢占加塞一次，而CLH队列中可能还有别的线程在等待）；</li><li>addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li><li>acquireQueued()使线程阻塞在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li></ol><blockquote><p><font color='red'>释放锁：</p></blockquote><ol><li><p>将头节点的状态设置为Node.Singal(唤醒下一个节点）</p></li><li><p>如果下一个节点处于挂起状态，那么就唤醒他，让他运行在自旋状态</p></li><li><p>将当前的同步器状态设置为空闲状态</p></li><li><p>头节点完成了上述过程后，下次后续节点再进行自旋判断时，发现前驱节点已经释放了锁，那么就再次申请获取锁，获取到锁后，重置一下state，下一次轮回开始了</p></li></ol><h2 id="12-独占模式获取和释放资源"><a href="#12-独占模式获取和释放资源" class="headerlink" title="12. 独占模式获取和释放资源"></a>12. 独占模式获取和释放资源</h2><p><img src="https://img-blog.csdnimg.cn/20210506193734234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="三-源码补充"><a href="#三-源码补充" class="headerlink" title="三. 源码补充"></a>三. 源码补充</h1><h2 id="①-tryAcquire-int-arg-独占方式。尝试获取资源"><a href="#①-tryAcquire-int-arg-独占方式。尝试获取资源" class="headerlink" title="①. tryAcquire(int arg) 独占方式。尝试获取资源"></a>①. tryAcquire(int arg) 独占方式。尝试获取资源</h2><ul><li>　此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。</li><li>　AQS只是一个框架，具体资源的获取&#x2F;释放方式交由自定义同步器去实现吗，AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get&#x2F;set&#x2F;CAS）。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210506194857473.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="②-tryRelease-int-arg-独占方式。尝试释放资源"><a href="#②-tryRelease-int-arg-独占方式。尝试释放资源" class="headerlink" title="②. tryRelease(int arg) 独占方式。尝试释放资源"></a>②. tryRelease(int arg) 独占方式。尝试释放资源</h2><ul><li>跟tryAcquire()一样，这个方法是需要独占模式的自定义同步器去实现的</li></ul><p><img src="https://img-blog.csdnimg.cn/20210506195030226.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="③-acquireShared-int"><a href="#③-acquireShared-int" class="headerlink" title="③. acquireShared(int)"></a>③. acquireShared(int)</h2><ul><li>此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210506195804814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取共享锁</span></span><br><span class="line"><span class="comment">//  tryAcquireShared留给用户重写获取共享锁方法</span></span><br><span class="line"><span class="comment">//  返回值负数表示获取失败</span></span><br><span class="line"><span class="comment">//  0表示获取成功，但是后续节点无法获取成功</span></span><br><span class="line"><span class="comment">//  正数表示获取成功且后续节点也可能获取成功</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>tryAcquireShared()尝试获取资源，成功则直接返回；</li><li>失败则通过doAcquireShared()进入等待队列，直到获取到资源为止才返回。</li></ol><h2 id="④-tryAcquireShared-int-：共享方式。尝试获取资源"><a href="#④-tryAcquireShared-int-：共享方式。尝试获取资源" class="headerlink" title="④. tryAcquireShared(int)：共享方式。尝试获取资源"></a>④. tryAcquireShared(int)：共享方式。尝试获取资源</h2><ul><li>负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210506195837502.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑤-doAcquireShared-int"><a href="#⑤-doAcquireShared-int" class="headerlink" title="⑤. doAcquireShared(int)"></a>⑤. doAcquireShared(int)</h2><p><img src="https://img-blog.csdnimg.cn/20210506200408515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);<span class="comment">//加入队列尾部</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//是否成功标志</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//等待过程中是否被中断过的标志</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();<span class="comment">//前驱</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;<span class="comment">//如果到head的下一个，因为head是拿到资源的线程，此时node被唤醒，很可能是head用完资源来唤醒自己的</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);<span class="comment">//尝试获取资源</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;<span class="comment">//成功</span></span><br><span class="line">                    setHeadAndPropagate(node, r);<span class="comment">//将head指向自己，还有剩余资源可以再唤醒之后的线程</span></span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)<span class="comment">//如果等待过程中被打断过，此时将中断补上。</span></span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断状态，寻找安全点，进入waiting状态，等着被unpark()或interrupt()</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑥-setHeadAndPropagate-对共享锁进行扩散"><a href="#⑥-setHeadAndPropagate-对共享锁进行扩散" class="headerlink" title="⑥. setHeadAndPropagate() 对共享锁进行扩散"></a>⑥. setHeadAndPropagate() 对共享锁进行扩散</h2><p><img src="https://img-blog.csdnimg.cn/20210506200512859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对共享锁进行扩散</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">//如果还有剩余量，继续唤醒下一个邻居线程</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="comment">// 如果后继节点是共享的，或者是出现了空，都会执行唤醒的操作</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">            <span class="comment">//唤醒节点</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red'  size=4>  acquireShared获取共享锁流程</p></blockquote><ol><li>tryAcquireShared()尝试获取资源，成功则直接返回；</li><li>失败则通过doAcquireShared()进入等待队列park()，直到被unpark()&#x2F;interrupt()并成功获取到资源才返回。整个等待过程也是忽略中断的。</li><li>其实跟acquire()的流程差不多，只不过多了个自己拿到资源后，还会去唤醒后继队友的操作（这才是共享）。</li></ol><h2 id="⑦-releaseShared-释放共享锁"><a href="#⑦-releaseShared-释放共享锁" class="headerlink" title="⑦. releaseShared() 释放共享锁"></a>⑦. releaseShared() 释放共享锁</h2><p><img src="https://img-blog.csdnimg.cn/20210506201047903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放共享锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;<span class="comment">//尝试释放资源</span></span><br><span class="line">        doReleaseShared();<span class="comment">//唤醒后继结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑧-doReleaseShared"><a href="#⑧-doReleaseShared" class="headerlink" title="⑧. doReleaseShared()"></a>⑧. doReleaseShared()</h2><p><img src="https://img-blog.csdnimg.cn/20210506201105205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体的节点状态检测和唤醒</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="comment">//如果节点的状态是SINGAL，且CAS成功就唤醒该节点</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果节点的状态是0，尝试CAS设置为PROPAGTE，以便下次共享锁传播</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果其他线程修改了头结点，那么在执行一次唤醒的逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑨-共享模式获取和释放资源"><a href="#⑨-共享模式获取和释放资源" class="headerlink" title="⑨. 共享模式获取和释放资源"></a>⑨. 共享模式获取和释放资源</h2><p><img src="https://img-blog.csdnimg.cn/20210506202424403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> Java集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList---JDK1.8源码分析</title>
      <link href="/2021/04/17/ArrayList/"/>
      <url>/2021/04/17/ArrayList/</url>
      
        <content type="html"><![CDATA[<h1 id="一-ArrayList的数据结构"><a href="#一-ArrayList的数据结构" class="headerlink" title="一. ArrayList的数据结构"></a>一. ArrayList的数据结构</h1><p><img src="https://img-blog.csdnimg.cn/20210426200605207.png" alt="在这里插入图片描述"></p><ul><li>底层的数据结构就是数组，数组元素类型为Object类型，即可以存放所有类型数据。我们对ArrayList类的实例的所有的操作底层都是基于数组的。</li></ul><h1 id="二-ArrayList源码分析"><a href="#二-ArrayList源码分析" class="headerlink" title="二. ArrayList源码分析"></a>二. ArrayList源码分析</h1><h2 id="①-继承关系"><a href="#①-继承关系" class="headerlink" title="①. 继承关系"></a>①. 继承关系</h2><p><img src="https://img-blog.csdnimg.cn/20210426212049673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li>RandomAccess接口：这个是一个标记性接口，通过查看api文档，它的作用就是用来快速随机存取</li><li>Serializable接口：实现该序列化接口，表明该类可以被序列化就是能够从类变成字节流传输，然后还能从字节流变成原来的类。</li><li>Cloneable接口：实现了该接口，就可以使用Object.Clone()方法了。</li><li>ArrayList就继承这个AbstractList类，继承一些通用的方法，然后自己在实现一些自己特有的方法</li></ol><h2 id="②-类中的属性"><a href="#②-类中的属性" class="headerlink" title="②. 类中的属性"></a>②. 类中的属性</h2><p><img src="https://img-blog.csdnimg.cn/20210426212321844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列号</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//默认初始容量  10</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//一个空数组，当用户指定ArrayList容量为0时，用户指定容量为 0 时返回返回该数组</span></span><br><span class="line"> <span class="comment">//ArrayList list1 = new ArrayList(0);</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//ArrayList list = new ArrayList();</span></span><br><span class="line">  <span class="comment">//1. 当用户没有指定 ArrayList() 的容量时(即调用无参构造函数)，返回的是该数组==&gt;刚创建一个 ArrayList 时，其内数据量为 0。</span></span><br><span class="line">  <span class="comment">//2. 当用户第一次添加元素时，该数组将会扩容，变成默认容量为 10(DEFAULT_CAPACITY) 的一个数组===&gt;通过  ensureCapacityInternal() 实现</span></span><br><span class="line">  <span class="comment">//3. 它与 EMPTY_ELEMENTDATA 的区别就是：该数组是默认返回的，而后者是在用户指定容量为 0 时返回</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//1. 当前数据对象存放地方，当前对象不参与序列化</span></span><br><span class="line"> <span class="comment">//2. 这个关键字最主要的作用就是当序列化时，被transient修饰的内容将不会被序列化</span></span><br><span class="line"> <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//ArrayList实际存储的数据数量</span></span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//继承于AbstractList</span></span><br><span class="line"> <span class="comment">//集合数组修改次数的标识</span></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="③-构造方法"><a href="#③-构造方法" class="headerlink" title="③. 构造方法"></a>③. 构造方法</h2><blockquote><p><font color='red' size=3>无参构造方法_(DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210426212123879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 无参构造函数：没有进行传参 当前元素数组直接返回默认 容量空元素数据 DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"> <span class="comment">//2. 创建一个 空的 ArrayList，此时其内数组缓冲区 elementData = &#123;&#125;, 长度为 0</span></span><br><span class="line"> <span class="comment">//3. 当元素第一次被加入时，扩容至默认容量 10</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=3>有参构造方法1，若参数为0_EMPTY_(ELEMENTDATA)<br><img src="https://img-blog.csdnimg.cn/20210426212150883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity  初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 当初试容量值非法(小于0)时抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//创建一个初试容量的、空的ArrayList arraylist并不是懒加载机制</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当出现这个情况 ArrayList list = new ArrayList(0);和直接不传是不一样的</span></span><br><span class="line">        <span class="comment">//传0 是直接赋值 EMPTY_ELEMENTDATA</span></span><br><span class="line">        <span class="comment">//不传 是直接赋值 DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line">        <span class="comment">//初始化容量为0 的时候 直接返回 EMPTY_ELEMENTDATA 空元素数据</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=3>有参构造方法2_集合添加</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210426212219495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 要放入 ArrayList 中的集合，其内元素将会全部添加到新建的 ArrayList 实例中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 当参数 c 为 null 时抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//创建一个包含collection的ArrayList</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="comment">//把集合传化成Object[]数组</span></span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="comment">//转化后的数组长度赋给当前ArrayList的size,并判断是否为0</span></span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            <span class="comment">// 若c.toArray() 返回的数组类型不是 Object[]，则利用 Arrays.copyOf(); 来构造一个大小为 size 的 Object[] 数组</span></span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 数组长度为0 直接使用空数组</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="④-核心方法"><a href="#④-核心方法" class="headerlink" title="④. 核心方法"></a>④. 核心方法</h2><h3 id="1-add-E-e-有四个方法，我仔细分析一个"><a href="#1-add-E-e-有四个方法，我仔细分析一个" class="headerlink" title="1. add(E e)__有四个方法，我仔细分析一个"></a>1. add(E e)__有四个方法，我仔细分析一个</h3><p><img src="https://img-blog.csdnimg.cn/20210426202153250.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210426202552968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=3>1. add(E e) 默认直接在末尾添加元素</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加指定的元素到ArrayList的最后位置</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">      <span class="comment">//确定ArrayList的容量大小  size是当前集合元素的个数</span></span><br><span class="line">      <span class="comment">// 若第一次 size肯定是0 minCapacity=1  +1是未来判断新加进来的元素是否有位置可以存下来</span></span><br><span class="line">      ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">//确保容量充足 进行元素添加</span></span><br><span class="line">      elementData[size++] = e;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="2-ensureCapacityInternal-size-1-确定内部容量的方法"><a href="#2-ensureCapacityInternal-size-1-确定内部容量的方法" class="headerlink" title="2. ensureCapacityInternal(size + 1) 确定内部容量的方法"></a>2. ensureCapacityInternal(size + 1) 确定内部容量的方法</h3><blockquote><p><font color='red' size=3>2. ensureCapacityInternal(size + 1) 确定内部容量的方法　　　</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210426202503847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//确保内部容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//calculateCapacity()判断是否走的是空参构造函数 DEFAULTCAPACITY_EMPTY_ELEMENTDATA  将容量初始为10</span></span><br><span class="line">    <span class="comment">//ensureExplicitCapacity判断容量是否要进行扩容 并且modCount++</span></span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-calculateCapacity-主要看list是不是初始的时候是空参构造函数"><a href="#3-calculateCapacity-主要看list是不是初始的时候是空参构造函数" class="headerlink" title="3. calculateCapacity() 主要看list是不是初始的时候是空参构造函数"></a>3. calculateCapacity() 主要看list是不是初始的时候是空参构造函数</h3><blockquote><p><font color='red' size=3>3. calculateCapacity()判断是否走的是空参构造函数，走空参将容量初始为10</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210426202647227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DEFAULTCAPACITY_EMPTY_ELEMENTDATA 主要是这个 默认容量空元素数据</span></span><br><span class="line"><span class="comment">//这个返回主要是看list是不是初始的时候是调用的空参构造函数 ====&gt;ArrayList list = new ArrayList(); DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//如果没有指定初始化容量，第一次调用add()方法，会初始化容量为10</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">//直接返回minCapacity默认容量10 和传入的最小容量取最大值</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若不是第一次添加直接返回minCapacity 也就是数组的大小+1</span></span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-还是确保明确的容量-ensureExplicitCapacity-int-minCapacity"><a href="#4-还是确保明确的容量-ensureExplicitCapacity-int-minCapacity" class="headerlink" title="4. 还是确保明确的容量 ensureExplicitCapacity(int minCapacity)"></a>4. 还是确保明确的容量 ensureExplicitCapacity(int minCapacity)</h3><blockquote><p><font color='red' size=3>4.还是确保明确的容量 ensureExplicitCapacity(int minCapacity)</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210426203004545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//还是确保明确的容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 将“修改统计数”+1，该变量主要是用来实现fail-fast机制的</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 防止溢出代码：确保指定的最小容量 &gt; 数组缓冲区当前的长度</span></span><br><span class="line">    <span class="comment">//若当前集合的最小容量超过数据的长度 需要进行扩容</span></span><br><span class="line">    <span class="comment">//比如第一次添加&amp;&amp;elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA ==&gt; minCapacity=10</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-grow-int-minCapacity-扩容机制——重点-看我的注释"><a href="#5-grow-int-minCapacity-扩容机制——重点-看我的注释" class="headerlink" title="5. grow(int minCapacity) 扩容机制——重点(看我的注释)"></a>5. grow(int minCapacity) 扩容机制——重点(看我的注释)</h3><blockquote><p><font color='red' size=3>5. grow(int minCapacity) 扩容机制——重点</p><p><img src="https://img-blog.csdnimg.cn/20210426203243701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扩容,以确保 ArrayList 至少能存储 minCapacity 个元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算出老的数组的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">//扩充当前容量为老的数组容量1.5倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 若扩充后newCapacity 还是小于 添加元素时候传进来的容量 minCapacity</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//直接将minCapacity直接赋值新的容量 newCapacity</span></span><br><span class="line">        <span class="comment">//若是第一次 newCapacity = minCapacity=10</span></span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 若扩充后的newCapacity 大于最大存储容量，则进行大容量分配</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">//将数组元素进行copy 长度为 newCapacity</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-hugeCapacity-大容量分配，最大分配-Integer-MAX-VALUE"><a href="#6-hugeCapacity-大容量分配，最大分配-Integer-MAX-VALUE" class="headerlink" title="6.hugeCapacity()大容量分配，最大分配 Integer.MAX_VALUE"></a>6.hugeCapacity()大容量分配，最大分配 Integer.MAX_VALUE</h3><blockquote><p><font color='red' size=3>6.hugeCapacity()大容量分配，最大分配 Integer.MAX_VALUE</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210426203738898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组缓冲区最大存储容量</span></span><br><span class="line"><span class="comment"> * - 一些 VM 会在一个数组中存储某些数据---&gt;为什么要减去 8 的原因</span></span><br><span class="line"><span class="comment"> * - 尝试分配这个最大存储容量，可能会导致 OutOfMemoryError(当该值 &gt; VM 的限制时)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大容量分配，最大分配 Integer.MAX_VALUE</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//越界直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="comment">//Integer.MAX_VALUE - 8;</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-分析一波ArrayList构造函数不传容量的情况"><a href="#7-分析一波ArrayList构造函数不传容量的情况" class="headerlink" title="7.分析一波ArrayList构造函数不传容量的情况"></a>7.分析一波ArrayList构造函数不传容量的情况</h3><blockquote><p><font color='red' size=3>7.分析一波ArrayList构造函数不传容量的情况</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 不传容量参数,直接走空参构造方法</span></span><br><span class="line">　List&lt;Integer&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">　　lists.add(<span class="number">8</span>);</span><br><span class="line">　　</span><br><span class="line">　　<span class="comment">//2. 走空参构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">//3. 添加元素的时候 进行判断==&gt;空参直接使用默认容量10</span></span><br><span class="line">  <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           <span class="comment">//直接返回minCapacity默认容量10 和传入的最小容量取最大值</span></span><br><span class="line">           <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210426204502796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>在add方法之前elementData &#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA。调用add方法时进行判断初始化默认容量为10，之后再返回到add函数，把8放在elementData[0]中</li></ul><h3 id="8-分析一波ArrayList构造函数传一个容量的情况或者传0情况"><a href="#8-分析一波ArrayList构造函数传一个容量的情况或者传0情况" class="headerlink" title="8.分析一波ArrayList构造函数传一个容量的情况或者传0情况"></a>8.分析一波ArrayList构造函数传一个容量的情况或者传0情况</h3><blockquote><p><font color='red' size=3>8.分析一波ArrayList构造函数传一个容量的情况或者传0情况</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 传一个初始化容量参数6</span></span><br><span class="line">　List&lt;Integer&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(<span class="number">6</span>);</span><br><span class="line">　　lists.add(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//2. 创建一个初试容量的、空的ArrayList arraylist并不是懒加载机制</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//大于0 直接创建一个对象数组</span></span><br><span class="line">          <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">           <span class="comment">//传0 是直接赋值 EMPTY_ELEMENTDATA</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 当出现这个情况 ArrayList list = new ArrayList(0);和直接不传是不一样的</span></span><br><span class="line">          <span class="comment">//传0 是直接赋值 EMPTY_ELEMENTDATA</span></span><br><span class="line">          <span class="comment">//不传 是直接赋值 DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line">          <span class="comment">//初始化容量为0 的时候 直接返回 EMPTY_ELEMENTDATA 空元素数据</span></span><br><span class="line">          <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                             initialCapacity);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210426205321270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>我们可以知道，在调用add方法之前，elementData的大小已经为6，之后再进行传递，不会进行扩容处理。</li><li>正常情况下会扩容1.5倍，特殊情况下（新扩展数组大小已经达到了最大值）则只取最大值。</li></ul><h3 id="9-remove-删除方法"><a href="#9-remove-删除方法" class="headerlink" title="9. remove() 删除方法"></a>9. remove() 删除方法</h3><blockquote><p><font color='red' size=3>9.remove(int index)    移除指定位置下标的元素</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210426205756457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除指定位置下标的元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 判断索引是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">//2. 增加修改的次数</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//3. 保存要删除的元素为oldValue</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    <span class="comment">//4. 将指定位置index+1往后的元素都向前移动一位，覆盖需要删除的元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 再进行数组copy</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 将最后一个元素置空</span></span><br><span class="line">    elementData[--size] = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 返回删除的元素</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-remove-Object-o-移除list中指定的第一个元素"><a href="#10-remove-Object-o-移除list中指定的第一个元素" class="headerlink" title="10.remove(Object o)  移除list中指定的第一个元素"></a>10.remove(Object o)  移除list中指定的第一个元素</h3><blockquote><p><font color='red' size=3>10.remove(Object o)  移除list中指定的第一个元素</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210426210028571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除list中指定的第一个元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果包含null这个元素，index 之后的所有元素依次左移一位</span></span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="comment">//通过元素 计算出下标</span></span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                <span class="comment">//如果包含这个元素，index 之后的所有元素依次左移一位</span></span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-fastRemove-int-index-传入下标进行删除当前index下标位置的元素"><a href="#11-fastRemove-int-index-传入下标进行删除当前index下标位置的元素" class="headerlink" title="11.fastRemove(int index) 传入下标进行删除当前index下标位置的元素"></a>11.fastRemove(int index) 传入下标进行删除当前index下标位置的元素</h3><blockquote><p><font color='red' size=3>11.fastRemove(int index) 传入下标进行删除当前index下标位置的元素</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210426210705515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入下标进行删除当前index下标位置的元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//移动的个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//将index后面的元素移动前面来 index位置的元素就是在最后一个位置</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">//将最后一个元素删除</span></span><br><span class="line">    elementData[--size] = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-get-int-index-直接获取下标的位置的值"><a href="#12-get-int-index-直接获取下标的位置的值" class="headerlink" title="12.get(int index) 直接获取下标的位置的值"></a>12.get(int index) 直接获取下标的位置的值</h3><blockquote><p><font color='red' size=3>12.get(int index) 直接获取下标的位置的值</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210426210254433.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接获取下标的位置的值</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line"><span class="comment">//检查范围</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">//直接返回</span></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-clear-将elementData中每个元素都赋值为null，等待垃圾回收将这个给回收掉"><a href="#13-clear-将elementData中每个元素都赋值为null，等待垃圾回收将这个给回收掉" class="headerlink" title="13.clear 将elementData中每个元素都赋值为null，等待垃圾回收将这个给回收掉"></a>13.clear 将elementData中每个元素都赋值为null，等待垃圾回收将这个给回收掉</h3><blockquote><p><font color='red' size=3>13.clear 将elementData中每个元素都赋值为null，等待垃圾回收将这个给回收掉</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210426210435838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除list中的所有元素，这个list表将在调用之后置空</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="literal">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h1><ol><li>arrayList可以存放null</li><li>arrayList本质上就是一个elementData数组。</li><li>arrayList区别于数组的地方在于能够自动扩展大小，其中关键的方法就是gorw()方法。</li><li>arrayList中removeAll(collection c)和clear()的区别就是removeAll可以删除批量指定的元素，而clear是全是删除集合中的元素。</li><li>arrayList由于本质是数组，所以它在数据的查询方面会很快，而在插入删除这些方面，性能下降很多，有移动很多数据才能达到应有的效果</li><li>arrayList实现了RandomAccess，所以在遍历它的时候推荐使用for循环。</li><li>主要是分析构造参数是否进行了传参，这里要判断是否要使用默认的容量10</li></ol><blockquote><p><font color='red' size=4> 补充一个添加元素add整个的流程</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210426211715505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4> 补充一个删除元素remove整个的流程</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210426211837389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> Java集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap----JDK1.8源码分析</title>
      <link href="/2021/04/16/HashMap/"/>
      <url>/2021/04/16/HashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="一-HashMap数据结构"><a href="#一-HashMap数据结构" class="headerlink" title="一. HashMap数据结构"></a>一. HashMap数据结构</h1><ul><li>hashMap的数据结构由<code>数组+链表+红黑树</code>构成，当链表的长度大于等于8，并且数组长度大于64，转换成红黑树，红黑树节点转换链表节点是6个节点作为临界值。</li><li>使用这个是数据结构了提升在 hash 冲突严重时（链表过长）的查找性能，使用链表的查找性能是 O(n)，而使用红黑树是 O(logn)。</li><li>对于插入，默认情况下是使用链表节点。当同一个索引位置的节点在新增后达到9个（阈值8）：如果此时数组长度大于等于 64，则会触发链表节点转红黑树节点（treeifyBin）；而如果数组长度小于64，则不会触发链表转红黑树，而是会进行扩容，因为此时的数据量还比较小。</li><li>对于移除，当同一个索引位置的节点在移除后达到 6 个，并且该索引位置的节点为红黑树节点，会触发红黑树节点转链表节点（untreeify）。<br><img src="https://img-blog.csdnimg.cn/20210228165601974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h1 id="二-HashMap的基本属性"><a href="#二-HashMap的基本属性" class="headerlink" title="二. HashMap的基本属性"></a>二. HashMap的基本属性</h1><p><img src="https://img-blog.csdnimg.cn/20210720102608807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">//序列号,序列化的时候使用。</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br><span class="line"> <span class="comment">//默认容量16</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"> <span class="comment">//最大容量,2的30次方。</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"> <span class="comment">//默认负载因子0.75 用于扩容使用。</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"> <span class="comment">//链表节点转为红黑树节点的阈值 8个节点转</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"> <span class="comment">//红黑树节点转换链表节点的阈值 6个节点转</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"> <span class="comment">// 转红黑树时 table 的最小长度</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"> <span class="comment">//存储元素的数组，transient关键字表示该属性不能被序列化</span></span><br><span class="line"> <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"> <span class="comment">//将数据转换成set的另一种存储形式，这个变量主要用于迭代功能。</span></span><br><span class="line"> <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"> <span class="comment">//hashmap中元素数量</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"> <span class="comment">//统计该map修改的次数</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"><span class="comment">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class="line"> <span class="type">int</span> threshold;</span><br><span class="line"> <span class="comment">//填充因子</span></span><br><span class="line"> <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h1 id="三-HashMap构造函数"><a href="#三-HashMap构造函数" class="headerlink" title="三. HashMap构造函数"></a>三. HashMap构造函数</h1><p><img src="https://img-blog.csdnimg.cn/20210720103330104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始容量+加载因子构造函数 hashmap构造函数懒加载 只有put元素的时候 才会去创建数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="comment">//判断初始容量是否越界</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="comment">//将加载因子进行全局变量赋值</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//tableSizeFor(initialCapacity)返回大于等于initialCapacity的最小的二次幂数值。</span></span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置初始容量,使用默认的加载因子0.75</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap实行了懒加载, 新建HashMap时不会对table进行赋值, 而是到第一次插入时, 进行resize时构建table;</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//0.75</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数是一个Map</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="comment">//使用默认的加载因子0.75</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四-tableSizeFor-initialCapacity"><a href="#四-tableSizeFor-initialCapacity" class="headerlink" title="四. tableSizeFor(initialCapacity)"></a>四. tableSizeFor(initialCapacity)</h1><ul><li>返回大于等于initialCapacity的最小的二次幂数值。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210720103523199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找出和cap最近的2的幂的数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五-HashMap里的put-方法存储键值对"><a href="#五-HashMap里的put-方法存储键值对" class="headerlink" title="五. HashMap里的put()方法存储键值对"></a>五. HashMap里的put()方法存储键值对</h1><p><img src="https://img-blog.csdnimg.cn/2021072010565983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p><font color='red' size=4>HashMap的数据存储实现原理</p></blockquote><ul><li><p>根据key计算得到key.hash &#x3D; (h &#x3D; k.hashCode()) ^ (h &gt;&gt;&gt; 16)；</p></li><li><p>根据key.hash计算得到桶数组的索引index &#x3D; key.hash &amp; (table.length - 1)，这样就找到该key的存放位置了：</p><ul><li><p>① 如果该位置没有数据，用该数据新生成一个节点保存新数据，返回null；</p></li><li><p>② 如果该位置有数据是一个红黑树，那么执行相应的插入 &#x2F; 更新操作；</p></li><li><p>③ 如果该位置有数据是一个链表，分两种情况一是该链表没有这个节点，另一个是该链表上有这个节点，注意这里判断的依据是key.hash是否一样：</p><ul><li>如果该链表没有这个节点，那么采用尾插法新增节点保存新数据，返回null；如果该链表已经有这个节点了，那么找到该节点并更新新数据，返回老数据。</li></ul></li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20210720103613698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//put() 存储键值对  linkedHashMap也是调用这个方法</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">//直接调putVal() 传入hash(key)以后的值 使用hash(key) 作为table的下标值 i = (n - 1) &amp; hash</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="①-HashMap里的putVal-方法存储键值对"><a href="#①-HashMap里的putVal-方法存储键值对" class="headerlink" title="①.   HashMap里的putVal()方法存储键值对"></a>①.   HashMap里的putVal()方法存储键值对</h2><p><img src="https://img-blog.csdnimg.cn/2021072010373591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//数组+链表+红黑树</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 1. 校验table是否为空或者length等于0，如果是则调用resize方法进行初始化table</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//resize()方法 扩容之后返回一个新的Node[]数组</span></span><br><span class="line">        <span class="comment">//n为数组tab的长度</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 2. 通过hash值计算索引位置，将该索引位置的头节点赋值给p，如果p为空则直接在该索引位置新增一个节点即可</span></span><br><span class="line">    <span class="comment">//  差不多就是计算hash%n</span></span><br><span class="line">    <span class="comment">//若计算出的下标i table[i]为空 直接newNode()</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//newNode()方法 链表的头结点</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//否则进行hash key 的对比</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3.table表该索引位置不为空，则进行查找 p是头结点</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 4.判断p节点是否为TreeNode, 如果是则调用红黑树的putTreeVal方法查找目标节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">//将键值对存入红黑树中 putTreeVal()</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 5.走到这代表p节点为普通链表节点，则调用普通的链表方法进行查找，使用binCount统计链表的节点数</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//当遍历到链表为空的时候</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 1. hashmap中在链表的末尾创建新的节点</span></span><br><span class="line">                    <span class="comment">// 2. linkedhashMap重写了newNode节点 转为双向链表</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 7.校验节点数是否超过8个，如果超过则调用treeifyBin方法将链表节点转为红黑树节点，</span></span><br><span class="line">                    <span class="comment">// 减一是因为循环是从p节点的下一个节点开始的</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// 8-1</span></span><br><span class="line">                        <span class="comment">//链表转红黑树treeifyBin()</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 8.如果e节点存在hash值和key值都与传入的相同，则e节点即为目标节点，跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 将p指向下一个节点</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 9.如果e节点不为空，则代表目标节点存在，使用传入的value覆盖该节点的value，并返回oldValue</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 用于LinkedHashMap</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 10.如果插入节点后节点数超过阈值，则调用resize方法进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        <span class="comment">//resize()扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 用于LinkedHashMap</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="②-HashMap里的putTreeVal-方法红黑树存储键值对"><a href="#②-HashMap里的putTreeVal-方法红黑树存储键值对" class="headerlink" title="②. HashMap里的putTreeVal()方法红黑树存储键值对"></a>②. HashMap里的putTreeVal()方法红黑树存储键值对</h2><p><img src="https://img-blog.csdnimg.cn/20210720103932845.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210720104149767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红黑树的put操作，红黑树插入会同时维护原来的链表属性, 即原来的next属性</span></span><br><span class="line">        <span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="type">int</span> h, K k, V v)</span> &#123;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">searched</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 1.查找根节点, 索引位置的头节点并不一定为红黑树的根节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; root = (parent != <span class="literal">null</span>) ? root() : <span class="built_in">this</span>;</span><br><span class="line">            <span class="comment">// 2.将根节点赋值给p节点，开始进行查找</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="type">int</span> dir, ph; K pk;</span><br><span class="line">                <span class="comment">// 3.如果传入的hash值小于p节点的hash值，将dir赋值为-1，代表向p的左边查找树</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 4.如果传入的hash值大于p节点的hash值， 将dir赋值为1，代表向p的右边查找树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 5.如果传入的hash值和key值等于p节点的hash值和key值, 则p节点即为目标节点, 返回p节点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="literal">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="comment">// 6.如果k所属的类没有实现Comparable接口 或者 k和p节点的key相等</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 6.1 第一次符合条件, 从p节点的左节点和右节点分别调用find方法进行查找, 如果查找到目标节点则返回</span></span><br><span class="line">                    <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (((ch = p.left) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="literal">null</span>) ||</span><br><span class="line">                            ((ch = p.right) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="literal">null</span>))</span><br><span class="line">                            <span class="keyword">return</span> q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 6.2 否则使用定义的一套规则来比较k和p节点的key的大小, 用来决定向左还是向右查找</span></span><br><span class="line">                    dir = tieBreakOrder(k, pk);<span class="comment">// dir&lt;0则代表k&lt;pk，则向p左边查找；反之亦然</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// xp赋值为x的父节点,中间变量,用于下面给x的父节点赋值</span></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="comment">// 7.dir&lt;=0则向p左边查找,否则向p右边查找,如果为null,则代表该位置即为x的目标位置</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 走进来代表已经找到x的位置，只需将x放到该位置即可</span></span><br><span class="line">                    Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                    <span class="comment">// 8.创建新的节点, 其中x的next节点为xpn, 即将x节点插入xp与xpn之间</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                    <span class="comment">// 9.调整x、xp、xpn之间的属性关系</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)<span class="comment">// 如果时dir &lt;= 0, 则代表x节点为xp的左节点</span></span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span>         <span class="comment">// 如果时dir &gt; 0, 则代表x节点为xp的右节点</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    <span class="comment">// 将xp的next节点设置为x</span></span><br><span class="line">                    xp.next = x;</span><br><span class="line">                    x.parent = x.prev = xp;</span><br><span class="line">                    <span class="comment">// 如果xpn不为空,则将xpn的prev节点设置为x节点,与上文的x节点的next节点对应</span></span><br><span class="line">                    <span class="keyword">if</span> (xpn != <span class="literal">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                    <span class="comment">// 10.进行红黑树的插入平衡调整</span></span><br><span class="line">                    moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="③-HashMap里红黑树中的tieBreakOrder-方法"><a href="#③-HashMap里红黑树中的tieBreakOrder-方法" class="headerlink" title="③.  HashMap里红黑树中的tieBreakOrder()方法"></a>③.  HashMap里红黑树中的tieBreakOrder()方法</h2><p><img src="https://img-blog.csdnimg.cn/20210720104103990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于不可比较或者hashCode相同时进行比较的方法, 只是一个一致的插入规则，用来维护重定位的等价性。</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">tieBreakOrder</span><span class="params">(Object a, Object b)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span> ||</span><br><span class="line">        (d = a.getClass().getName().</span><br><span class="line">         compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">        d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">             -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="④-HashMap里的treeifyBin-方法链表转红黑树"><a href="#④-HashMap里的treeifyBin-方法链表转红黑树" class="headerlink" title="④. HashMap里的treeifyBin()方法链表转红黑树"></a>④. HashMap里的treeifyBin()方法链表转红黑树</h2><p><img src="https://img-blog.csdnimg.cn/20210720104322489.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210720104333532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将链表节点转为红黑树节点</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">       <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">       <span class="comment">// 1.如果table为空或者table的长度小于64, 调用resize方法进行扩容</span></span><br><span class="line">       <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) <span class="comment">//转红黑树时 table 的最小长度64</span></span><br><span class="line">           resize();</span><br><span class="line">       <span class="comment">// 2.根据hash值计算索引值，将该索引位置的节点赋值给e，从e开始遍历该索引位置的链表</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">           TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 3.将链表节点转红黑树节点</span></span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               <span class="comment">//将Node节点转为TreeNode节点</span></span><br><span class="line">               TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">               <span class="comment">// 4.如果是第一次遍历，将头节点赋值给hd</span></span><br><span class="line">               <span class="keyword">if</span> (tl == <span class="literal">null</span>) <span class="comment">// tl为空代表为第一次循环</span></span><br><span class="line">                   hd = p;</span><br><span class="line">               <span class="comment">// 5.如果不是第一次遍历，则处理当前节点的prev属性和上一个节点的next属性</span></span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   p.prev = tl;</span><br><span class="line">                   tl.next = p;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 6.将p节点赋值给tl，用于在下一次循环中作为上一个节点进行一些链表的关联操作（p.prev = tl 和 tl.next = p）</span></span><br><span class="line">               tl = p;</span><br><span class="line">           &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">           <span class="comment">// 7.将table该索引位置赋值为新转的TreeNode的头节点，如果该节点不为空，则以以头节点(hd)为根节点, 构建红黑树treeify()</span></span><br><span class="line">           <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">               <span class="comment">//treeify()使用数组tab[Node&lt;key,value&gt;] 构建红黑树</span></span><br><span class="line">               hd.treeify(tab);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="⑤-HashMap里的treeify-方法构建红黑树"><a href="#⑤-HashMap里的treeify-方法构建红黑树" class="headerlink" title="⑤. HashMap里的treeify()方法构建红黑树"></a>⑤. HashMap里的treeify()方法构建红黑树</h2><p><img src="https://img-blog.csdnimg.cn/20210720104413215.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210720104422620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建红黑树</span></span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> &#123;</span><br><span class="line">     TreeNode&lt;K,V&gt; root = <span class="literal">null</span>;</span><br><span class="line">     <span class="comment">// 1.将调用此方法的节点hd赋值给x，以x作为起点，开始进行遍历</span></span><br><span class="line">     <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="built_in">this</span>, next; x != <span class="literal">null</span>; x = next) &#123;</span><br><span class="line">         <span class="comment">// next赋值为x的下个节点</span></span><br><span class="line">         next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">         <span class="comment">// 将x的左右节点设置为空</span></span><br><span class="line">         x.left = x.right = <span class="literal">null</span>;</span><br><span class="line">         <span class="comment">// 2.如果还没有根节点, 则将x设置为根节点</span></span><br><span class="line">         <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">             x.parent = <span class="literal">null</span>; <span class="comment">// 根节点没有父节点</span></span><br><span class="line">             x.red = <span class="literal">false</span>; <span class="comment">// 根节点必须为黑色</span></span><br><span class="line">             root = x; <span class="comment">// 将x设置为根节点</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//root不为空的时候</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> x.key; <span class="comment">// k赋值为x的key</span></span><br><span class="line">             <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> x.hash; <span class="comment">// h赋值为x的hash值</span></span><br><span class="line">             Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line">             <span class="comment">// 3.如果当前节点x不是根节点, 则从根节点开始查找属于该节点的位置</span></span><br><span class="line">             <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                 <span class="type">int</span> dir, ph;</span><br><span class="line">                 <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key;</span><br><span class="line">                 <span class="comment">// 4.如果x节点的hash值小于p节点的hash值，则将dir赋值为-1, 代表向p的左边查找</span></span><br><span class="line">                 <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                     dir = -<span class="number">1</span>;</span><br><span class="line">                 <span class="comment">// 5.如果x节点的hash值大于p节点的hash值，则将dir赋值为1, 代表向p的右边查找</span></span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                     dir = <span class="number">1</span>;</span><br><span class="line">                 <span class="comment">// 6.走到这代表x的hash值和p的hash值相等，则比较key值</span></span><br><span class="line">                     <span class="comment">// 6.1 如果k没有实现Comparable接口 或者 x节点的key和p节点的key相等</span></span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                           (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                          (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                     <span class="comment">// 6.2 使用定义的一套规则来比较x节点和p节点的大小，用来决定向左还是向右查找</span></span><br><span class="line">                     dir = tieBreakOrder(k, pk);</span><br><span class="line">                 <span class="comment">// xp赋值为x的父节点,中间变量用于下面给x的父节点赋值</span></span><br><span class="line">                 TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                 <span class="comment">// 7.dir&lt;=0则向p左边查找,否则向p右边查找,如果为null,则代表该位置即为x的目标位置</span></span><br><span class="line">                 <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">                     <span class="comment">// 8.x和xp节点的属性设置</span></span><br><span class="line">                     x.parent = xp; <span class="comment">// x的父节点即为最后一次遍历的p节点</span></span><br><span class="line">                     <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                         <span class="comment">// 如果时dir &lt;= 0, 则代表x节点为父节点的左节点</span></span><br><span class="line">                         xp.left = x;</span><br><span class="line">                     <span class="keyword">else</span></span><br><span class="line">                         <span class="comment">// 如果时dir &gt; 0, 则代表x节点为父节点的右节点</span></span><br><span class="line">                         xp.right = x;</span><br><span class="line">             <span class="comment">// 9.进行红黑树的插入平衡(通过左旋、右旋和改变节点颜色来保证当前树符合红黑树的要求)</span></span><br><span class="line">                     root = balanceInsertion(root, x);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 10.如果root节点不在table索引位置的头节点, 则将其调整为头节点</span></span><br><span class="line">     moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑥-HashMap里的moveRootToFront-方法将root放到头节点的位置"><a href="#⑥-HashMap里的moveRootToFront-方法将root放到头节点的位置" class="headerlink" title="⑥. HashMap里的moveRootToFront()方法将root放到头节点的位置"></a>⑥. HashMap里的moveRootToFront()方法将root放到头节点的位置</h2><p><img src="https://img-blog.csdnimg.cn/20210720104519417.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021072010453442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将root放到头节点的位置</span></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="keyword">void</span> <span class="title function_">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> &#123;</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line">            <span class="comment">// 1.校验root是否为空、table是否为空、table的length是否大于0</span></span><br><span class="line">            <span class="keyword">if</span> (root != <span class="literal">null</span> &amp;&amp; tab != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 2.计算root节点的索引位置</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">                TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">                <span class="comment">// 3.如果该索引位置的头节点不是root节点，则该索引位置的头节点替换为root节点</span></span><br><span class="line">                <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; rn;</span><br><span class="line">                    <span class="comment">// 3.1 将该索引位置的头节点赋值为root节点</span></span><br><span class="line">                    tab[index] = root;</span><br><span class="line">                    TreeNode&lt;K,V&gt; rp = root.prev; <span class="comment">// root节点的上一个节点</span></span><br><span class="line">                    <span class="comment">// 3.2 如果root节点的next节点不为空，则将root节点的next节点的prev属性设置为root节点的prev节点</span></span><br><span class="line">                    <span class="keyword">if</span> ((rn = root.next) != <span class="literal">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">                    <span class="comment">// 3.3 如果root节点的prev节点不为空，则将root节点的prev节点的next属性设置为root节点的next节点</span></span><br><span class="line">                    <span class="keyword">if</span> (rp != <span class="literal">null</span>)</span><br><span class="line">                        rp.next = rn;</span><br><span class="line">                    <span class="comment">// 3.4 如果原头节点不为空, 则将原头节点的prev属性设置为root节点</span></span><br><span class="line">                    <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">                        first.prev = root;</span><br><span class="line">                    <span class="comment">// 3.5 将root节点的next属性设置为原头节点</span></span><br><span class="line">                    root.next = first;</span><br><span class="line">                    <span class="comment">// 3.6 root此时已经被放到该位置的头节点位置，因此将prev属性设为空</span></span><br><span class="line">                    root.prev = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 4.该索引位置的头节点就是root节点,检查树是否正常</span></span><br><span class="line">                <span class="keyword">assert</span> <span class="title function_">checkInvariants</span><span class="params">(root)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="六-HashMap的get-方法"><a href="#六-HashMap的get-方法" class="headerlink" title="六.  HashMap的get()方法"></a>六.  HashMap的get()方法</h1><p><img src="https://img-blog.csdnimg.cn/20210720104803506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hashmap的get()分析</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 定义一个链表节点</span></span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//2. 通过key和hash以后的key获取值</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="①-通过hash函数进行计算索引的位置"><a href="#①-通过hash函数进行计算索引的位置" class="headerlink" title="①. 通过hash函数进行计算索引的位置"></a>①. 通过hash函数进行计算索引的位置</h2><p><img src="https://img-blog.csdnimg.cn/20210720104901744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过hash函数进行计算索引的位置</span></span><br><span class="line"><span class="comment">//当get的时候 还是通过这个计算找到table的位置 存的时候就是使用这个计算</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">//1.先拿到key的hashCode值</span></span><br><span class="line">    <span class="comment">//2.将hashCode后和hashcode的高16位进行异或运算</span></span><br><span class="line">    <span class="comment">//3. &gt;&gt;&gt; 右移在补码得基础上 高位补0</span></span><br><span class="line">    <span class="comment">//4. &gt;&gt; 右移补码得基础上 高位补符号位</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先获取对象的hashCode()值，然后将hashCode值右移16位，然后将右移后的值与原来的hashCode做异或运算，返回结果。（其中h&gt;&gt;&gt;16，在JDK1.8中，优化了高位运算的算法，使用了零扩展，无论正数还是负数，都在高位插入0）。</li><li>在putVal源码中，我们通过(n-1)&amp;hash获取该对象的键在hashmap中的位置。其中n表示的是hash桶数组的长度，并且该长度为2的n次方，这样(n-1)&amp;hash就等价于hash%n。因为&amp;运算的效率高于%运算。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210720105820910.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210720105846956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="②-hashmap的链表getNode-方法获取值"><a href="#②-hashmap的链表getNode-方法获取值" class="headerlink" title="②. hashmap的链表getNode()方法获取值"></a>②. hashmap的链表getNode()方法获取值</h2><p><img src="https://img-blog.csdnimg.cn/20210720104950165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取节点getNode()</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="comment">//1.对table进行效验 ：table不为空 &amp;&amp; table长度大于0 &amp;&amp;</span></span><br><span class="line">    <span class="comment">// table索引位置(使用table.length-1 和hash值进行位与计算)</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="comment">//i = (n - 1) &amp; hash</span></span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 检查first节点的hash值和key是否入参的一样,如果一样则first即为目标节点，直接返回first节点</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp;</span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 3.如果first不是目标节点，并且first的next节点e不为空则继续遍历</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.如果是红黑树节点，则调用红黑树的查找目标节点方法getTreeNode</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//调用红黑树的getTreeNode()方法获取值</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//do while 循环进行搜索</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 5.执行链表节点的查找，向下遍历链表, 直至找到节点的key和入参的key相等时,返回该节点</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                <span class="comment">//若有下一个节点 继续查找</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="③-Hashmap的红黑树getTreeNode-获取值"><a href="#③-Hashmap的红黑树getTreeNode-获取值" class="headerlink" title="③. Hashmap的红黑树getTreeNode()获取值"></a>③. Hashmap的红黑树getTreeNode()获取值</h2><p><img src="https://img-blog.csdnimg.cn/2021072010502919.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210720105040338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210228172019372.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在红黑树中获取节点</span></span><br><span class="line"> <span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">getTreeNode</span><span class="params">(<span class="type">int</span> h, Object k)</span> &#123;</span><br><span class="line">     <span class="comment">//1. 首先找到红黑树的根节点；</span></span><br><span class="line">     <span class="comment">//2. 再使用根节点调用find方法</span></span><br><span class="line">     <span class="keyword">return</span> ((parent != <span class="literal">null</span>) ? root() : <span class="built_in">this</span>).find(h, k, <span class="literal">null</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="④-Hashmap里的find-方法"><a href="#④-Hashmap里的find-方法" class="headerlink" title="④. Hashmap里的find()方法"></a>④. Hashmap里的find()方法</h2><p><img src="https://img-blog.csdnimg.cn/20210720105150573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//1. 从调用此方法的节点开始查找, 通过hash值和key找到对应的节点</span></span><br><span class="line">  <span class="comment">//2. 此方法是红黑树节点的查找, 红黑树是特殊的自平衡二叉查找树</span></span><br><span class="line">  <span class="comment">//3. 平衡二叉查找树的特点： 左节点&lt;根节点&lt;右节点</span></span><br><span class="line"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">find</span><span class="params">(<span class="type">int</span> h, Object k, Class&lt;?&gt; kc)</span> &#123;</span><br><span class="line">    <span class="comment">//1.将p节点赋值为调用此方法的节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">//2. 从p节点开始向下遍历</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">int</span> ph, dir; K pk;</span><br><span class="line">        TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">        <span class="comment">// 3.如果传入的hash值小于p节点的hash值，则往p节点的左边遍历</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="comment">// 4.如果传入的hash值大于p节点的hash值，则往p节点的右边遍历</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="comment">// 5.如果传入的hash值和key值等于p节点的hash值和key值,则p节点为目标节点,返回p节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="literal">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">// 6.p节点的左节点为空则将向右遍历</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="literal">null</span>)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="comment">// 7.p节点的右节点为空则向左遍历</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="literal">null</span>)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="comment">// 8.将p节点与k进行比较</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="literal">null</span> ||</span><br><span class="line">                  (kc = comparableClassFor(k)) != <span class="literal">null</span>) &amp;&amp;   <span class="comment">//kc不为空代表k实现了Comparable</span></span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>) <span class="comment">//k&lt;pk则dir&lt;0, k&gt;pk则dir&gt;0</span></span><br><span class="line">            p = (dir &lt; <span class="number">0</span>) ? pl : pr;  <span class="comment">//根据dir进行判断向哪一边搜索</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 9.代码走到此处, 代表key所属类没有实现Comparable, 直接指定向p的右边遍历</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = pl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑤-Hashmap里的comparableClassFor-方法"><a href="#⑤-Hashmap里的comparableClassFor-方法" class="headerlink" title="⑤.  Hashmap里的comparableClassFor()方法"></a>⑤.  Hashmap里的comparableClassFor()方法</h2><p><img src="https://img-blog.csdnimg.cn/20210720105233637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210720105244275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将key传进来判断是否实现了Comparable接口</span></span><br><span class="line"><span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">    <span class="comment">// 1.判断x是否实现了Comparable接口</span></span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">        Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;</span><br><span class="line">        <span class="comment">// 2.校验x是否为String类型</span></span><br><span class="line">        <span class="keyword">if</span> ((c = x.getClass()) == String.class)</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 3.遍历x实现的所有接口</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ts.length; ++i) &#123;</span><br><span class="line">                <span class="comment">// 4.如果x实现了Comparable接口，则返回x的Class</span></span><br><span class="line">                <span class="keyword">if</span> (((t = ts[i]) <span class="keyword">instanceof</span> ParameterizedType) &amp;&amp;</span><br><span class="line">                    ((p = (ParameterizedType)t).getRawType() ==</span><br><span class="line">                     Comparable.class) &amp;&amp;</span><br><span class="line">                    (as = p.getActualTypeArguments()) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                    as.length == <span class="number">1</span> &amp;&amp; as[<span class="number">0</span>] == c)</span><br><span class="line">                    <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七-HashMap里的resize-方法扩容"><a href="#七-HashMap里的resize-方法扩容" class="headerlink" title="七. HashMap里的resize()方法扩容"></a>七. HashMap里的resize()方法扩容</h1><ul><li><p>①. 计算新桶数组的容量 newCap 和新阈值 newThr</p></li><li><p>②. 根据计算出的 newCap 创建新的桶数组，桶数组 table 也是在这里进行初始化的</p></li><li><p>③. 将键值对节点重新映射到新的桶数组里。如果节点是 TreeNode 类型，则需要拆分红黑树。如果是普通节点，则节点按原顺序进行分组。</p></li><li><p>④. 如果e的hash值与旧表的容量进行&amp;与运算为0,则扩容后的索引位置跟旧表的索引位置一样。如果e的hash值与旧表的容量进行&amp;与运算为非0,则扩容后的索引位置为:旧表的索引位置＋oldCap。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210720112123456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210720105552992.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hashmap的扩容机制 重点重点</span></span><br><span class="line">   <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">       <span class="comment">//把没插入之前的哈希数组做我诶oldTal</span></span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       <span class="comment">//old的长度</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="comment">//old的阈值</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">       <span class="comment">//初始化new的长度和阈值</span></span><br><span class="line">       <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//oldCap &gt; 0也就是说不是首次初始化，因为hashMap用的是懒加载</span></span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 1.1 判断老表的容量是否超过最大容量值：如果超过则将阈值设置为Integer.MAX_VALUE，并直接返回老表,</span></span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 1.2 将newCap赋值为oldCap的2倍，如果newCap&lt;最大容量&amp;&amp;oldCap&gt;=16, 则将新阈值设置为原来的两倍</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               <span class="comment">//阈值也扩大到原来的两倍</span></span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//首次进行初始化扩容 走这里</span></span><br><span class="line">       <span class="comment">// 2.如果老表的容量为0, 老表的阈值大于0, 是因为初始容量被放入阈值，则将新表的容量设置为老表的阈值</span></span><br><span class="line">       <span class="comment">//这种情况走这里  HashMap hashMap = new HashMap(0);</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</span><br><span class="line">           <span class="comment">//将老的阈值赋给新的容量 感觉没啥逻辑感</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3.老表的容量为0, 老表的阈值为0，这种情况是没有传初始容量的new方法创建的空表，将阈值和容量设置为默认值</span></span><br><span class="line">       <span class="comment">// 这种情况只有 HashMap hashMap = new HashMap(); 不传参数的时候</span></span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//新表使用默认的容量值16</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           <span class="comment">//新的阈值 16*0.75=12</span></span><br><span class="line">           newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//进入这里可能就是 执行了上面的 (oldThr &gt; 0) 里面的阈值传给newCap 然后 newThr并没有执行</span></span><br><span class="line">       <span class="comment">// 4.如果新表的阈值为空, 则通过新的容量*负载因子获得阈值</span></span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 5.将当前阈值设置为刚计算出来的新的阈值，定义新表，容量为刚计算出来的新容量，将table设置为新定义的表。</span></span><br><span class="line">       threshold = newThr;</span><br><span class="line">       <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">           Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 6.如果老表不为空，则需遍历所有节点，将节点赋值给新表</span></span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="comment">// 将索引值为j的老表头节点赋值给e</span></span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// 将老表的节点设置为空, 以便垃圾收集器回收空间</span></span><br><span class="line">                   oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                   <span class="comment">// 7.如果e.next为空, 则代表老表的该位置只有1个节点，计算新表的索引位置, 直接将该节点放在该位置</span></span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="comment">// 8.如果是红黑树节点，则进行红黑树的重hash分布(跟链表的hash分布基本相同)</span></span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="comment">// 9.如果是普通的链表节点，则进行普通的重hash分布</span></span><br><span class="line">                   <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="comment">// 存储索引位置为:“原索引位置”的节点</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                       <span class="comment">// 存储索引位置为:“原索引位置+oldCap”的节点</span></span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="comment">// 9.1 如果e的hash值与旧表的容量进行与运算为0,则扩容后的索引位置跟旧表的索引位置一样</span></span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="comment">// 如果loTail为空, 代表该节点为第一个节点</span></span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                   <span class="comment">// 则将loHead赋值为第一个节点</span></span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   <span class="comment">// 否则将节点添加在loTail后面</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               <span class="comment">// 并将loTail赋值为新增的节点</span></span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">// 9.2 如果e的hash值与旧表的容量进行与运算为非0,则扩容后的索引位置为:旧表的索引位置＋oldCap</span></span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="comment">// 如果hiTail为空, 代表该节点为第一个节点</span></span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                   <span class="comment">// 则将hiHead赋值为第一个节点</span></span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   <span class="comment">// 否则将节点添加在hiTail后面</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               <span class="comment">// 并将hiTail赋值为新增的节点</span></span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                       <span class="comment">// 10.如果loTail不为空（说明老表的数据有分布到新表上“原索引位置”的节点），则将最后一个节点</span></span><br><span class="line">                       <span class="comment">// 的next设为空，并将新表上索引位置为“原索引位置”的节点设置为对应的头节点</span></span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                           loTail.next = <span class="literal">null</span>;</span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">// 11.如果hiTail不为空（说明老表的数据有分布到新表上“原索引+oldCap位置”的节点），则将最后</span></span><br><span class="line">                       <span class="comment">// 一个节点的next设为空，并将新表上索引位置为“原索引+oldCap”的节点设置为对应的头节点</span></span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 12.返回新表</span></span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=4> 将键值对节点重新映射到新的桶数组里</p></blockquote><ul><li>依次遍历链表，并计算节点 <strong>hash &amp; oldCap</strong> 的值。</li><li>如果值为0，将 loHead 和 loTail 指向这个节点。如果后面还有节点 hash &amp; oldCap 为0的话，则将节点链入 loHead 指向的链表中，并将 loTail 指向该节点。</li><li>如果值为非0的话，则让 hiHead 和 hiTail 指向该节点。完成遍历后，可能会得到两条链表，此时就完成了链表分组。</li><li>最后再将这两条链接存放到相应的桶中，完成扩容</li></ul><p><img src="https://img-blog.csdnimg.cn/20210720111407706.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210720111415204.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210720111441977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="①-HashMap里的split-方法红黑树的重-hash-分布"><a href="#①-HashMap里的split-方法红黑树的重-hash-分布" class="headerlink" title="①. HashMap里的split()方法红黑树的重 hash 分布"></a>①. HashMap里的split()方法红黑树的重 hash 分布</h2><blockquote><p><font color='red' size=4> 在扩容过程中，树化要满足两个条件</p></blockquote><ul><li>链表长度大于等于 TREEIFY_THRESHOLD</li><li>桶数组容量大于等于 MIN_TREEIFY_CAPACITY</li></ul><p><img src="https://img-blog.csdnimg.cn/20210720111532384.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210720111610269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> map 代表要扩容的HashMap</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> tab 代表新创建的数组，用来存放旧数组迁移的数据</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> index 代表旧数组的索引</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> bit 代表旧数组的长度，需要配合使用来做按位与运算</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">// split()方法的作用是将旧数组转移到新数组</span></span><br><span class="line">       <span class="comment">//这个方法在HashMap进行扩容时会调用到:  ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap)</span></span><br><span class="line">       <span class="comment">//扩容后，红黑树的hash分布，只可能存在于两个位置：原索引位置、原索引位置+oldCap</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="type">int</span> index, <span class="type">int</span> bit)</span> &#123;</span><br><span class="line">           <span class="comment">// 拿到调用此方法的节点</span></span><br><span class="line">           TreeNode&lt;K,V&gt; b = <span class="built_in">this</span>;</span><br><span class="line">           <span class="comment">// 存储索引位置为:“原索引位置”的节点</span></span><br><span class="line">           TreeNode&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">           <span class="comment">// 存储索引位置为:“原索引+oldCap”的节点</span></span><br><span class="line">           TreeNode&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">           <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">           <span class="comment">// 1.以调用此方法的节点开始，遍历整个红黑树节点</span></span><br><span class="line">           <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="literal">null</span>; e = next) &#123;</span><br><span class="line">               next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">               <span class="comment">// 同时将老表的节点设置为空，以便垃圾收集器回收</span></span><br><span class="line">               e.next = <span class="literal">null</span>;</span><br><span class="line">               <span class="comment">// 2.如果e的hash值与老表的容量进行与运算为0,则扩容后的索引位置跟老表的索引位置一样</span></span><br><span class="line">               <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="comment">// 如果loTail为空, 代表该节点为第一个节点</span></span><br><span class="line">                   <span class="keyword">if</span> ((e.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                       <span class="comment">// 则将loHead赋值为第一个节点</span></span><br><span class="line">                       loHead = e;</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                       <span class="comment">// 否则将节点添加在loTail后面</span></span><br><span class="line">                       loTail.next = e;</span><br><span class="line">                   <span class="comment">// 并将loTail赋值为新增的节点</span></span><br><span class="line">                   loTail = e;</span><br><span class="line">                   <span class="comment">// 统计原索引位置的节点个数</span></span><br><span class="line">                   ++lc;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//3.如果e的hash值与老表的容量进行与运算为非0,则扩容后的索引位置为:老表的索引位置＋oldCap</span></span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 如果hiHead为空, 代表该节点为第一个节点</span></span><br><span class="line">                   <span class="keyword">if</span> ((e.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                       <span class="comment">// 则将hiHead赋值为第一个节点</span></span><br><span class="line">                       hiHead = e;</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                       <span class="comment">// 否则将节点添加在hiTail后面</span></span><br><span class="line">                       hiTail.next = e;</span><br><span class="line">                   <span class="comment">// 并将hiTail赋值为新增的节点</span></span><br><span class="line">                   hiTail = e;</span><br><span class="line">                   <span class="comment">// 统计索引位置为原索引+oldCap的节点个数</span></span><br><span class="line">                   ++hc;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 4.如果原索引位置的节点不为空</span></span><br><span class="line">           <span class="keyword">if</span> (loHead != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 4.1 如果节点个数&lt;=6个则将红黑树转为链表结构</span></span><br><span class="line">               <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                   <span class="comment">//红黑树转链表</span></span><br><span class="line">                   tab[index] = loHead.untreeify(map);</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 4.2 将原索引位置的节点设置为对应的头节点</span></span><br><span class="line">                   tab[index] = loHead;</span><br><span class="line">                   <span class="comment">// 4.3 如果hiHead不为空，则代表原来的红黑树(老表的红黑树由于节点被分到两个位置)</span></span><br><span class="line">                   <span class="keyword">if</span> (hiHead != <span class="literal">null</span>)</span><br><span class="line">                       <span class="comment">// 4.4 以loHead为根节点, 构建新的红黑树</span></span><br><span class="line">                       loHead.treeify(tab);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 5.如果索引位置为原索引+oldCap的节点不为空</span></span><br><span class="line">           <span class="keyword">if</span> (hiHead != <span class="literal">null</span>) &#123;   <span class="comment">// 索引位置为原索引+oldCap的节点不为空</span></span><br><span class="line">               <span class="comment">// 5.1 如果节点个数&lt;=6个则将红黑树转为链表结构</span></span><br><span class="line">               <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                   tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 5.2 将索引位置为原索引+oldCap的节点设置为对应的头节点</span></span><br><span class="line">                   tab[index + bit] = hiHead;</span><br><span class="line">                   <span class="comment">// 5.3 loHead不为空则代表原来的红黑树(老表的红黑树由于节点被分到两个位置)</span></span><br><span class="line">                   <span class="keyword">if</span> (loHead != <span class="literal">null</span>)</span><br><span class="line">                       <span class="comment">// 5.4 以hiHead为根节点, 构建新的红黑树</span></span><br><span class="line">                       hiHead.treeify(tab);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><ul><li>从源码上可以看得出，重新映射红黑树的逻辑和重新映射链表的逻辑基本一致。不同的地方在于，重新映射后，会将红黑树拆分成两条由 TreeNode 组成的链表。如果链表长度小于 UNTREEIFY_THRESHOLD，则将链表转换成普通链表。否则根据条件重新将 TreeNode 链表树化。</li></ul><h2 id="②-HashMap里的untreeify-方法红黑树节点转为链表节点"><a href="#②-HashMap里的untreeify-方法红黑树节点转为链表节点" class="headerlink" title="②. HashMap里的untreeify()方法红黑树节点转为链表节点"></a>②. HashMap里的untreeify()方法红黑树节点转为链表节点</h2><p><img src="https://img-blog.csdnimg.cn/20210720111708373.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210720111729938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红黑树转链表 当节点&lt;=6个时会被触发</span></span><br><span class="line">       <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> &#123;</span><br><span class="line">           <span class="comment">// hd指向头节点, tl指向尾节点</span></span><br><span class="line">           Node&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">           <span class="comment">//1.从调用该方法的节点, 即链表的头节点开始遍历, 将所有节点全转为链表节点</span></span><br><span class="line">           <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="built_in">this</span>; q != <span class="literal">null</span>; q = q.next) &#123;</span><br><span class="line">               <span class="comment">// 2.调用replacementNode方法构建链表节点</span></span><br><span class="line">               Node&lt;K,V&gt; p = map.replacementNode(q, <span class="literal">null</span>);</span><br><span class="line">               <span class="comment">// 3.如果tl尾节点为null, 则代表当前节点为第一个节点, 将hd赋值为该节点</span></span><br><span class="line">               <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                   hd = p;</span><br><span class="line">               <span class="comment">// 4.否则, 将尾节点的next属性设置为当前节点p</span></span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   tl.next = p;</span><br><span class="line">               <span class="comment">// 5.每次都将tl节点指向当前节点, 即尾节点</span></span><br><span class="line">               tl = p;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 6.返回转换后的链表的头节点</span></span><br><span class="line">           <span class="keyword">return</span> hd;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h1 id="八-HashMap里的remove-方法移除某个节点"><a href="#八-HashMap里的remove-方法移除某个节点" class="headerlink" title="八. HashMap里的remove()方法移除某个节点"></a>八. HashMap里的remove()方法移除某个节点</h1><ul><li>HashMap 的删除操作并不复杂，仅需三个步骤即可完成。第一步是定位桶位置，第二步遍历链表并找到键值相等的节点，第三步删除节点。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210720112300631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除某个节点 remove()</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//直接调用removeNode()</span></span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">        <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="①-HashMap里的removeNode-方法移除某个节点"><a href="#①-HashMap里的removeNode-方法移除某个节点" class="headerlink" title="①.  HashMap里的removeNode()方法移除某个节点"></a>①.  HashMap里的removeNode()方法移除某个节点</h2><p><img src="https://img-blog.csdnimg.cn/20210720112331728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除节点</span></span><br><span class="line">    <span class="comment">// linkedhashMap也是使用的这个方法 本身未重写</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value, <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">        <span class="comment">// 1.如果table不为空并且根据hash值计算出来的索引位置不为空, 将该位置的节点赋值给p</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">            <span class="comment">// 2.如果p的hash值和key都与入参的相同, 则p即为目标节点, 赋值给node</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line">            <span class="comment">// 3.否则将p.next赋值给e，向下遍历节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 3.1 如果p是TreeNode则调用红黑树的方法查找节点</span></span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 3.2 否则，进行普通链表节点的查找</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="comment">// 当节点的hash值和key与传入的相同,则该节点即为目标节点</span></span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e; <span class="comment">// 赋值给node, 并跳出循环</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// p节点赋值为本次结束的e，在下一次循环中，e为p的next节点</span></span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.如果node不为空(即根据传入key和hash值查找到目标节点)，则进行移除操作</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value || (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)            <span class="comment">// 4.1 如果是TreeNode则调用红黑树的移除方法</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">                <span class="comment">// 4.2 如果node是该索引位置的头节点则直接将该索引位置的值赋值为node的next节点，</span></span><br><span class="line">                <span class="comment">// “node == p”只会出现在node是头节点的时候，如果node不是头节点，则node为p的next节点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="comment">// 4.3 否则将node的上一个节点的next属性设置为node的next节点,</span></span><br><span class="line">                <span class="comment">// 即将node节点移除, 将node的上下节点进行关联(链表的移除)</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                <span class="comment">// 供LinkedHashMap使用</span></span><br><span class="line">                <span class="comment">//调用删除回调方法进行后续操作</span></span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="comment">// 5.返回被移除的节点</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若不存在返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="②-HashMap里的removeTreeNode-方法红黑树中移除某个节点"><a href="#②-HashMap里的removeTreeNode-方法红黑树中移除某个节点" class="headerlink" title="②.  HashMap里的removeTreeNode()方法红黑树中移除某个节点"></a>②.  HashMap里的removeTreeNode()方法红黑树中移除某个节点</h2><p><img src="https://img-blog.csdnimg.cn/20210720112558102.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210720112623567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//红黑树中删除一个节点</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">//链表的操作</span></span><br><span class="line">    <span class="comment">// 1.table为空或者length为0直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 2.根据hash计算出索引的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">    <span class="comment">// 3.将索引位置的头节点赋值给first和root</span></span><br><span class="line">    TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">    <span class="comment">// 4.该方法被将要被移除的node(TreeNode)调用, 因此此方法的this为要被移除node节点,</span></span><br><span class="line">    <span class="comment">// 将node的next节点赋值给succ节点，prev节点赋值给pred节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">    <span class="comment">// 5.如果pred节点为空，则代表要被移除的node节点为头节点，</span></span><br><span class="line">    <span class="comment">// 则将table索引位置的值和first节点的值赋值为succ节点(node的next节点)即可</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">        tab[index] = first = succ;</span><br><span class="line">        <span class="comment">// 6.否则将pred节点的next属性设置为succ节点(node的next节点)</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = succ;</span><br><span class="line">    <span class="comment">// 7.如果succ节点不为空，则将succ的prev节点设置为pred, 与前面对应</span></span><br><span class="line">    <span class="keyword">if</span> (succ != <span class="literal">null</span>)</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    <span class="comment">// 8.如果进行到此first节点为空，则代表该索引位置已经没有节点则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (first == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 9.如果root的父节点不为空, 则将root赋值为根节点</span></span><br><span class="line">    <span class="keyword">if</span> (root.parent != <span class="literal">null</span>)</span><br><span class="line">        root = root.root();</span><br><span class="line">    <span class="comment">// 10.通过root节点来判断此红黑树是否太小, 如果是则调用untreeify方法转为链表节点并返回</span></span><br><span class="line">    <span class="comment">// (转链表后就无需再进行下面的红黑树处理)</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || root.right == <span class="literal">null</span> ||</span><br><span class="line">            (rl = root.left) == <span class="literal">null</span> || rl.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//红黑树的操作</span></span><br><span class="line">    <span class="comment">// 11.将p赋值为要被移除的node节点，pl赋值为p的左节点，pr赋值为p 的右节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="built_in">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">    <span class="comment">// 12.如果p的左节点和右节点都不为空时</span></span><br><span class="line">    <span class="keyword">if</span> (pl != <span class="literal">null</span> &amp;&amp; pr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 12.1 将s节点赋值为p的右节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">        <span class="comment">// 12.2 向左一直查找，跳出循环时,s为没有左节点的节点</span></span><br><span class="line">        <span class="keyword">while</span> ((sl = s.left) != <span class="literal">null</span>) <span class="comment">// find successor</span></span><br><span class="line">            s = sl;</span><br><span class="line">        <span class="comment">// 12.3 交换p节点和s节点的颜色</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">c</span> <span class="operator">=</span> s.red; s.red = p.red; p.red = c;</span><br><span class="line">        <span class="comment">// s的右节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">        <span class="comment">// p的父节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        <span class="comment">// 如果p节点的右节点即为s节点，则将p的父节点赋值为s，将s的右节点赋值为p</span></span><br><span class="line">        <span class="keyword">if</span> (s == pr) &#123;</span><br><span class="line">            p.parent = s;</span><br><span class="line">            s.right = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将sp赋值为s的父节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">            <span class="comment">// 将p的父节点赋值为sp</span></span><br><span class="line">            <span class="keyword">if</span> ((p.parent = sp) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果s节点为sp的左节点，则将sp的左节点赋值为p节点</span></span><br><span class="line">                <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                    sp.left = p;</span><br><span class="line">                    <span class="comment">// 否则s节点为sp的右节点，则将sp的右节点赋值为p节点</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sp.right = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// s的右节点赋值为p节点的右节点</span></span><br><span class="line">            <span class="keyword">if</span> ((s.right = pr) != <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">// 如果pr不为空，则将pr的父节点赋值为s</span></span><br><span class="line">                pr.parent = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 12.5 第二次调整</span></span><br><span class="line">        <span class="comment">// 将p的左节点赋值为空，pl已经保存了该节点</span></span><br><span class="line">        p.left = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 将p节点的右节点赋值为sr，如果sr不为空，则将sr的父节点赋值为p节点</span></span><br><span class="line">        <span class="keyword">if</span> ((p.right = sr) != <span class="literal">null</span>)</span><br><span class="line">            sr.parent = p;</span><br><span class="line">        <span class="comment">// 将s节点的左节点赋值为pl，如果pl不为空，则将pl的父节点赋值为s节点</span></span><br><span class="line">        <span class="keyword">if</span> ((s.left = pl) != <span class="literal">null</span>)</span><br><span class="line">            pl.parent = s;</span><br><span class="line">        <span class="comment">// 将s的父节点赋值为p的父节点pp</span></span><br><span class="line">        <span class="comment">// 如果pp为空，则p节点为root节点, 交换后s成为新的root节点</span></span><br><span class="line">        <span class="keyword">if</span> ((s.parent = pp) == <span class="literal">null</span>)</span><br><span class="line">            root = s;</span><br><span class="line">            <span class="comment">// 如果p不为root节点, 并且p是pp的左节点，则将pp的左节点赋值为s节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = s;</span><br><span class="line">            <span class="comment">// 如果p不为root节点, 并且p是pp的右节点，则将pp的右节点赋值为s节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = s;</span><br><span class="line">        <span class="comment">// 12.6 寻找replacement节点，用来替换掉p节点</span></span><br><span class="line">        <span class="comment">// 12.6.1 如果sr不为空，则replacement节点为sr，因为s没有左节点，所以使用s的右节点来替换p的位置</span></span><br><span class="line">        <span class="keyword">if</span> (sr != <span class="literal">null</span>)</span><br><span class="line">            replacement = sr;</span><br><span class="line">            <span class="comment">// 12.6.1 如果sr为空，则s为叶子节点，replacement为p本身，只需要将p节点直接去除即可</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            replacement = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 13.承接12点的判断，如果p的左节点不为空，右节点为空，replacement节点为p的左节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="literal">null</span>)</span><br><span class="line">        replacement = pl;</span><br><span class="line">        <span class="comment">// 14.如果p的右节点不为空,左节点为空，replacement节点为p的右节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="literal">null</span>)</span><br><span class="line">        replacement = pr;</span><br><span class="line">        <span class="comment">// 15.如果p的左右节点都为空, 即p为叶子节点, replacement节点为p节点本身</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        replacement = p;</span><br><span class="line">    <span class="comment">// 16.第三次调整：使用replacement节点替换掉p节点的位置，将p节点移除</span></span><br><span class="line">    <span class="keyword">if</span> (replacement != p) &#123; <span class="comment">// 如果p节点不是叶子节点</span></span><br><span class="line">        <span class="comment">// 16.1 将p节点的父节点赋值给replacement节点的父节点, 同时赋值给pp节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">        <span class="comment">// 16.2 如果p没有父节点, 即p为root节点，则将root节点赋值为replacement节点即可</span></span><br><span class="line">        <span class="keyword">if</span> (pp == <span class="literal">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">            <span class="comment">// 16.3 如果p不是root节点, 并且p为pp的左节点，则将pp的左节点赋值为替换节点replacement</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = replacement;</span><br><span class="line">            <span class="comment">// 16.4 如果p不是root节点, 并且p为pp的右节点，则将pp的右节点赋值为替换节点replacement</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = replacement;</span><br><span class="line">        <span class="comment">// 16.5 p节点的位置已经被完整的替换为replacement, 将p节点清空, 以便垃圾收集器回收</span></span><br><span class="line">        p.left = p.right = p.parent = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 17.如果p节点不为红色则进行红黑树删除平衡调整</span></span><br><span class="line">    <span class="comment">// (如果删除的节点是红色则不会破坏红黑树的平衡无需调整)</span></span><br><span class="line">    TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 18.如果p节点为叶子节点, 则简单的将p节点去除即可</span></span><br><span class="line">    <span class="keyword">if</span> (replacement == p) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        <span class="comment">// 18.1 将p的parent属性设置为空</span></span><br><span class="line">        p.parent = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 18.2 如果p节点为父节点的左节点，则将父节点的左节点赋值为空</span></span><br><span class="line">            <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 18.3 如果p节点为父节点的右节点， 则将父节点的右节点赋值为空</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                pp.right = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (movable)</span><br><span class="line">        <span class="comment">// 19.将root节点移到索引位置的头节点</span></span><br><span class="line">        moveRootToFront(tab, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="九-HashMap-和-Hashtable-的区别"><a href="#九-HashMap-和-Hashtable-的区别" class="headerlink" title="九. HashMap 和 Hashtable 的区别"></a>九. HashMap 和 Hashtable 的区别</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HashMap 允许 key 和 value 为 <span class="literal">null</span>，Hashtable 不允许。</span><br><span class="line">HashMap 的默认初始容量为 <span class="number">16</span>，Hashtable 为 <span class="number">11</span>。</span><br><span class="line">HashMap 的扩容为原来的 <span class="number">2</span> 倍，Hashtable 的扩容为原来的 <span class="number">2</span> 倍加 <span class="number">1</span>。</span><br><span class="line">HashMap 是非线程安全的，Hashtable是线程安全的。</span><br><span class="line">HashMap 的 hash 值重新计算过，Hashtable 直接使用 hashCode。</span><br><span class="line">HashMap 去掉了 Hashtable 中的 contains 方法。</span><br><span class="line">HashMap 继承自 AbstractMap 类，Hashtable 继承自 Dictionary 类。</span><br></pre></td></tr></table></figure><h1 id="十-JDK1-8版本前的死循环问题分析"><a href="#十-JDK1-8版本前的死循环问题分析" class="headerlink" title="十. JDK1.8版本前的死循环问题分析"></a>十. JDK1.8版本前的死循环问题分析</h1><ul><li>导致死循环的根本原因是 JDK 1.7 扩容采用的是“头插法”，会导致同一索引位置的节点在扩容后顺序反掉。而 JDK 1.8 之后采用的是“尾插法”，扩容后节点顺序不会反掉，不存在死循环问题。</li></ul><h1 id="十一-JDK1-8优化改变的结构总结"><a href="#十一-JDK1-8优化改变的结构总结" class="headerlink" title="十一. JDK1.8优化改变的结构总结"></a>十一. JDK1.8优化改变的结构总结</h1><ol><li>jdk1.8扩容时插入方式从“头插法”改成“尾插法”，避免了并发下的死循环。</li><li>底层数据结构从“数组+链表”改成“数组+链表+红黑树”，主要是优化了 hash 冲突较严重时，链表过长的查找性能：O(n) -&gt; O(logn)。</li><li>计算 table 初始容量的方式发生了改变，老的方式是从1开始不断向左进行移位运算，直到找到大于等于入参容量的值；新的方式则是通过“5个移位+或等于运算”来计算。</li><li>优化了 hash 值的计算方式，将 hashCode 的高16位和 hashCode 进行异或（XOR）运算，得到最终的 hash 值。</li><li>扩容时计算节点在新表的索引位置方式从<code>h &amp; (length-1)</code>改成<code>hash &amp; oldCap</code>，性能可能提升不大，但设计更巧妙</li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> Java集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CopyOnWriteArrayList-JDK1.8源码分析</title>
      <link href="/2020/04/16/CopyOnWriteArrayList-JDK1.8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2020/04/16/CopyOnWriteArrayList-JDK1.8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="一-CopyOnWriteArrayList介绍"><a href="#一-CopyOnWriteArrayList介绍" class="headerlink" title="一. CopyOnWriteArrayList介绍"></a>一. CopyOnWriteArrayList介绍</h1><ul><li>CopyOnWriteArrayList是Java并发包中提供的一个并发容器，它是个线程安全且<strong>读操作</strong>无锁的ArrayList，<strong>写操作</strong>则通过创建底层数组的新副本来实现，是一种读写分离的并发策略，我们也可以称这种容器为”写时复制器”。</li></ul><h1 id="二-CopyOnWriteArrayList源码分析"><a href="#二-CopyOnWriteArrayList源码分析" class="headerlink" title="二. CopyOnWriteArrayList源码分析"></a>二. CopyOnWriteArrayList源码分析</h1><h2 id="①-CopyOnWriteArrayList的内部类—COWIterator类"><a href="#①-CopyOnWriteArrayList的内部类—COWIterator类" class="headerlink" title="①.  CopyOnWriteArrayList的内部类—COWIterator类"></a>①.  CopyOnWriteArrayList的内部类—COWIterator类</h2><ul><li>COWIterator表示迭代器，其也有一个Object类型的数组作为CopyOnWriteArrayList数组的快照，这种快照风格的迭代器方法在创建迭代器时使用了对当时数组状态的引用。此数组在迭代器的生存期内不会更改，因此不可能发生冲突，并且迭代器保证不会抛出 ConcurrentModificationException。创建迭代器以后，迭代器就不会反映列表的添加、移除或者更改。在迭代器上进行的元素更改操作（remove、set 和 add）不受支持。这些方法将抛出 UnsupportedOperationException。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210516135421878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">COWIterator</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">ListIterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//快照</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line">    <span class="comment">//游标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cursor;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">COWIterator</span><span class="params">(Object[] elements, <span class="type">int</span> initialCursor)</span> &#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否还有下一项</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否有上一项</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// next项</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">previous</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 不存在下一项，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (! hasPrevious())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="comment">// 返回下一项</span></span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[--cursor];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一项索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上一项索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">previousIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不支持remove操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不支持set操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不支持add操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="②-CopyOnWriteArrayList的属性"><a href="#②-CopyOnWriteArrayList的属性" class="headerlink" title="②. CopyOnWriteArrayList的属性"></a>②. CopyOnWriteArrayList的属性</h2><ul><li>属性中有一个可重入锁，内部持有一个ReentrantLock lock &#x3D; new ReentrantLock()，用来保证线程安全访问。</li><li>还有一个Object类型的数组，用来存放具体的元素。使用到了反射机制和CAS来保证原子性的修改lock域。</li><li>底层是用volatile transient声明的数组 array。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210516135649122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    <span class="comment">// 版本序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8673264195747942595L</span>;</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// 对象数组，用于存放元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line">    <span class="comment">// Unsafe类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="comment">// lock域的内存偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> lockOffset;</span><br><span class="line">    <span class="comment">//静态代码块获取内存偏移量</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = CopyOnWriteArrayList.class;</span><br><span class="line">            lockOffset = UNSAFE.objectFieldOffset(k.getDeclaredField(<span class="string">&quot;lock&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="③-CopyOnWriteArrayList的构造函数"><a href="#③-CopyOnWriteArrayList的构造函数" class="headerlink" title="③. CopyOnWriteArrayList的构造函数"></a>③. CopyOnWriteArrayList的构造函数</h2><p><img src="https://img-blog.csdnimg.cn/20210516135856424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CopyOnWriteArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 设置当前数组</span></span><br><span class="line">    setArray(<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CopyOnWriteArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    <span class="comment">// 类型相同</span></span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == CopyOnWriteArrayList.class)</span><br><span class="line">        <span class="comment">// 获取c集合的数组</span></span><br><span class="line">        elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将c集合转化为数组并赋值给elements</span></span><br><span class="line">        elements = c.toArray();</span><br><span class="line">        <span class="comment">// elements类型不为Object[]类型</span></span><br><span class="line">        <span class="keyword">if</span> (elements.getClass() != Object[].class)</span><br><span class="line">            <span class="comment">// 将elements数组转化为Object[]类型的数组</span></span><br><span class="line">            elements = Arrays.copyOf(elements, elements.length, Object[].class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置数组</span></span><br><span class="line">    setArray(elements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将toCopyIn转化为Object[]类型数组，然后设置当前数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CopyOnWriteArrayList</span><span class="params">(E[] toCopyIn)</span> &#123;</span><br><span class="line">    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="④-Arrays-copyOf-方法"><a href="#④-Arrays-copyOf-方法" class="headerlink" title="④. Arrays.copyOf()方法"></a>④. Arrays.copyOf()方法</h2><p><img src="https://img-blog.csdnimg.cn/20210516140012526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="type">int</span> newLength, Class&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>[]&gt; newType) &#123;</span><br><span class="line">    <span class="comment">// 确定copy的类型 将newType转化为Object类型，将Object[].class转化为Object类型</span></span><br><span class="line">    <span class="comment">// 判断两者是否相等，若相等，则生成指定长度的Object数组</span></span><br><span class="line">    <span class="comment">// 否则,生成指定长度的新类型的数组</span></span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[].class)? (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[newLength]:</span><br><span class="line">            (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    <span class="comment">// 将original数组从下标0开始，复制长度为(original.length和newLength的较小者),复制到copy数组中（也从下标0开始）</span></span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><font color='red' size=4> System.arraycopy()方法</p><p><img src="https://img-blog.csdnimg.cn/20210516140042374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//System.arraycopy() 是 native方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src 原数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcPos  原数组中的起始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dest  目标数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> destPos 目标数组的起始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 要赋值的数组元素数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src,  <span class="type">int</span>  srcPos,Object dest, <span class="type">int</span> destPos,<span class="type">int</span> length)</span>;</span><br></pre></td></tr></table></figure><h2 id="⑤-add-E-e-方法"><a href="#⑤-add-E-e-方法" class="headerlink" title="⑤. add(E e) 方法"></a>⑤. add(E e) 方法</h2><ul><li>此函数用于将指定元素添加到此列表的尾部</li></ul><ol><li><p>获取锁（保证多线程的安全访问），获取当前的Object数组，获取Object数组的长度为length。</p></li><li><p>根据Object数组复制一个长度为length+1的Object数组为newElements（此时，newElements[length]为null），进入步骤③。</p></li><li><p>将下标为length的数组元素newElements[length]设置为元素e，再设置当前Object[]为newElements，释放锁，返回。这样就完成了元素的添加。<br>  <img src="https://img-blog.csdnimg.cn/20210516140406834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       <span class="comment">// 可重入锁</span></span><br><span class="line">       <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">       <span class="comment">// 获取锁</span></span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 元素数组</span></span><br><span class="line">           Object[] elements = getArray();</span><br><span class="line">           <span class="comment">// 数组长度</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">           <span class="comment">// 复制数组</span></span><br><span class="line">           Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">           <span class="comment">// 存放元素e</span></span><br><span class="line">           newElements[len] = e;</span><br><span class="line">           <span class="comment">// 设置数组</span></span><br><span class="line">           setArray(newElements);</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// 释放锁</span></span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="⑥-addIfAbsent-方法"><a href="#⑥-addIfAbsent-方法" class="headerlink" title="⑥. addIfAbsent() 方法"></a>⑥. addIfAbsent() 方法</h2><p><img src="https://img-blog.csdnimg.cn/20210516140643159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该函数用于添加元素（如果数组中不存在，则添加；否则，不添加，直接返回）</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addIfAbsent</span><span class="params">(E e)</span> &#123;</span><br><span class="line">      <span class="comment">//获取当前数组</span></span><br><span class="line">      Object[] snapshot = getArray();</span><br><span class="line">      <span class="keyword">return</span> indexOf(e, snapshot, <span class="number">0</span>, snapshot.length) &gt;= <span class="number">0</span> ? <span class="literal">false</span> :addIfAbsent(e, snapshot);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//该函数用于添加元素（如果数组中不存在，则添加；否则，不添加，直接返回）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addIfAbsent</span><span class="params">(E e, Object[] snapshot)</span> &#123;</span><br><span class="line">      <span class="comment">// 重入锁</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">      <span class="comment">// 获取锁</span></span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 获取当前数组 current</span></span><br><span class="line">          Object[] current = getArray();</span><br><span class="line">          <span class="comment">// 数组长度 len</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> current.length;</span><br><span class="line">          <span class="comment">// 快照不等于当前数组，对数组进行了修改</span></span><br><span class="line">          <span class="keyword">if</span> (snapshot != current) &#123;</span><br><span class="line">              <span class="comment">// 取较小者</span></span><br><span class="line">              <span class="type">int</span> <span class="variable">common</span> <span class="operator">=</span> Math.min(snapshot.length, len);</span><br><span class="line">              <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; common; i++)</span><br><span class="line">                  <span class="comment">// 当前数组的元素与快照的元素不相等并且e与当前元素相等</span></span><br><span class="line">                  <span class="keyword">if</span> (current[i] != snapshot[i] &amp;&amp; eq(e, current[i]))</span><br><span class="line">                      <span class="comment">// 表示在snapshot与current之间修改了数组，并且设置了数组某一元素为e，已经存在</span></span><br><span class="line">                      <span class="comment">// 直接返回false</span></span><br><span class="line">                      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">              <span class="comment">// 在当前数组中找到e元素</span></span><br><span class="line">              <span class="keyword">if</span> (indexOf(e, current, common, len) &gt;= <span class="number">0</span>)</span><br><span class="line">                  <span class="comment">// 返回</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 复制数组</span></span><br><span class="line">          Object[] newElements = Arrays.copyOf(current, len + <span class="number">1</span>);</span><br><span class="line">          <span class="comment">// 对数组len索引的元素赋值为e</span></span><br><span class="line">          newElements[len] = e;</span><br><span class="line">          <span class="comment">// 设置当前数组</span></span><br><span class="line">          setArray(newElements);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// 释放锁</span></span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="⑦-set-int-index-E-element-方法"><a href="#⑦-set-int-index-E-element-方法" class="headerlink" title="⑦. set(int index, E element)方法"></a>⑦. set(int index, E element)方法</h2><p><img src="https://img-blog.csdnimg.cn/20210516140948792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 获取index索引的元素</span></span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> get(elements, index);</span><br><span class="line">        <span class="comment">// 旧值等于element</span></span><br><span class="line">        <span class="keyword">if</span> (oldValue != element) &#123; /</span><br><span class="line">            <span class="comment">// 数组长度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">            <span class="comment">// 复制数组</span></span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">            <span class="comment">// 重新赋值index索引的值</span></span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            <span class="comment">// 设置数组</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 设置数组</span></span><br><span class="line">            setArray(elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回旧值</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑧-remove-int-index-方法"><a href="#⑧-remove-int-index-方法" class="headerlink" title="⑧. remove(int index) 方法"></a>⑧. remove(int index) 方法</h2><ol><li><p>获取锁，获取数组elements，数组长度为length，获取索引的值elements[index]，计算需要移动的元素个数（length - index - 1）,若个数为0，则表示移除的是数组的最后一个元素，复制elements数组，复制长度为length-1，然后设置数组进入步骤3；否则，进入步骤2。</p></li><li><p>先复制index索引前的元素，再复制index索引后的元素，然后设置数组。</p></li><li><p>释放锁，返回旧值。</p></li></ol><p><img src="https://img-blog.csdnimg.cn/20210516141215592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ4MDc4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过下标移除元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取数组 elements</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 数组长度 length</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        <span class="comment">// 获取旧值</span></span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> get(elements, index);</span><br><span class="line">        <span class="comment">// 需要移动的元素个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 移动个数为0 则表示移除的是数组的最后一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 复制elements数组，复制长度为length-1，然后设置数组</span></span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 移动个数不为0</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 新生数组</span></span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> <span class="title class_">Object</span>[len - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 复制index索引之前的元素</span></span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            <span class="comment">// 复制index索引之后的元素</span></span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,numMoved);</span><br><span class="line">            <span class="comment">// 设置当前数组</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回旧值</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="三-CopyOnWriteArrayList为什么并发安全且性能比Vector好"><a href="#三-CopyOnWriteArrayList为什么并发安全且性能比Vector好" class="headerlink" title="三. CopyOnWriteArrayList为什么并发安全且性能比Vector好"></a>三. CopyOnWriteArrayList为什么并发安全且性能比Vector好</h1><ul><li>Vector是增删改查方法都加了synchronized，保证同步，但是每个方法执行的时候都要去获得锁，性能就会大大下降，而CopyOnWriteArrayList 只是在增删改上加锁，但是读不加锁，在读方面的性能就好于Vector，CopyOnWriteArrayList支持读多写少的并发情况。</li></ul><h1 id="四-CopyOnWriteArrayList优缺点"><a href="#四-CopyOnWriteArrayList优缺点" class="headerlink" title="四. CopyOnWriteArrayList优缺点"></a>四. CopyOnWriteArrayList优缺点</h1><blockquote><p><font color='red' size=4> 优点</p></blockquote><ul><li>读操作性能很高，因为无需任何同步措施，比较适用于读多写少的并发场景。</li><li>Java的list在遍历时，若中途有别的线程对list容器进行修改，则会抛出ConcurrentModificationException异常。而CopyOnWriteArrayList由于其”读写分离”的思想，遍历和修改操作分别作用在不同的list容器，所以在使用迭代器进行遍历时候，也就不会抛出ConcurrentModificationException异常了</li></ul><blockquote><p><font color='red' size=4> 缺点</p></blockquote><ol><li><strong>内存占用问题</strong>，毕竟每次执行写操作都要将原容器拷贝一份，数据量大时，对内存压力较大，可能会引起频繁GC；</li><li><strong>无法保证实时性</strong>，Vector对于读写操作均加锁同步，可以保证读和写的强一致性。而CopyOnWriteArrayList由于其实现策略的原因，写和读分别作用在新老不同容器上，在写操作执行过程中，读不会阻塞但读取到的却是老容器的数据。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
